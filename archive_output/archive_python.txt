================================================================================
File: a-files.py
Path: .\a-files.py
Size: 2388
Modified: 2025-05-02T10:52:19.479814
Created: 2025-03-31T18:10:05.312675
Hash: ae975bd0212c6dfdbdcc6a7107bf4cdddf759f0b906f707f90a0ea0310a6cb56
Lines: 57
================================================================================
import os
import datetime

def create_file_list(start_dir=".", output_file="file_list.txt"):
    """
    Creates a text file containing a listing of all files and directories
    within the specified directories ("backend", "front-end", "schemas") and their subdirectories,
    excluding the "node_modules" directory.

    Args:
        start_dir (str): The root directory to start the listing from. Defaults to the current directory.
        output_file (str): The name of the output text file. Defaults to "file_list.txt".
    """

    included_dirs = ["backend", "front-end", "schemas"]

    try:
        with open(output_file, "w") as f:
            f.write(f"File and Directory Listing - {datetime.datetime.now()}\n")
            f.write("-" * 40 + "\n")

            for top_level_dir in included_dirs:
                full_path = os.path.join(start_dir, top_level_dir)
                if not os.path.isdir(full_path):
                    print(f"Warning: Directory '{full_path}' not found. Skipping.")
                    continue  # Skip to the next directory if it doesn't exist

                for root, dirs, files in os.walk(full_path):
                    # Exclude "node_modules" directory
                    if "node_modules" in root.split(os.sep):  # Check if node_modules is in the path
                        continue

                    # Write the directory name
                    f.write(f"Directory: {root}\n")

                    # Write the files in the directory
                    for file in files:
                        f.write(f"  - File: {file}\n")

                    # Add a separator after each directory (optional)
                    f.write("-" * 20 + "\n")

        print(f"File list created successfully: {output_file}")

    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == "__main__":
    # Get the directory from the user (optional - can be hardcoded if needed)
    dir_to_list = input("Enter the base directory to list (or press Enter for current directory): ")
    if not dir_to_list:
        dir_to_list = "." #Current Directory
    output_filename = input("Enter the output filename (or press Enter for 'file_list.txt'): ")
    if not output_filename:
        output_filename = "file_list.txt"
    create_file_list(dir_to_list, output_filename)

================================================================================
File: application.py
Path: .\application.py
Size: 831
Modified: 2025-05-02T10:52:19.479814
Created: 2025-04-16T16:38:14.502589
Hash: 75592464e06592b2227da7662acbf117a78089cfa9eca00afd2f51a5c099257e
Lines: 21
================================================================================
from backend.app import app as application
import os

# Set environment variables if they're not already set
if 'DATABASE_URL' in os.environ and 'DB_HOST' not in os.environ:
    # Parse DATABASE_URL into individual components
    db_url = os.environ['DATABASE_URL']
    # Format: postgresql://username:password@host:port/dbname
    parts = db_url.replace('postgresql://', '').split('@')
    credentials = parts[0].split(':')
    host_port_db = parts[1].split('/')
    host_port = host_port_db[0].split(':')
    
    os.environ['DB_USER'] = credentials[0]
    os.environ['DB_PASSWORD'] = credentials[1]
    os.environ['DB_HOST'] = host_port[0]
    os.environ['DB_PORT'] = host_port[1] if len(host_port) > 1 else '5432'
    os.environ['DB_NAME'] = host_port_db[1]

if __name__ == '__main__':
    application.run()

================================================================================
File: check_deployment.py
Path: .\check_deployment.py
Size: 3885
Modified: 2025-05-02T10:52:19.496346
Created: 2025-04-18T17:28:52.170515
Hash: 133c788e930eb771580a2cdaf128cac3733fb579d2a2e5ade298c6fa743c35ab
Lines: 115
================================================================================
#!/usr/bin/env python
# check_deployment.py - Script to check deployment status

import os
import sys
import requests
import json
import logging
from dotenv import load_dotenv

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
    ]
)
log = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Configuration
API_URL = os.getenv('REACT_APP_API_URL', 'https://icmp-api.onrender.com')
FRONTEND_URL = os.getenv('FRONTEND_URL', 'https://icmp.onrender.com')
FB_VERIFY_TOKEN = os.getenv('FB_VERIFY_TOKEN')
FB_PAGE_ACCESS_TOKEN = os.getenv('FB_PAGE_ACCESS_TOKEN')

def check_api_health():
    """Check if the API is healthy"""
    try:
        response = requests.get(f"{API_URL}/health")
        if response.status_code == 200:
            log.info(f"API health check passed: {response.json()}")
            return True
        else:
            log.error(f"API health check failed with status code {response.status_code}: {response.text}")
            return False
    except Exception as e:
        log.error(f"Error checking API health: {str(e)}")
        return False

def check_facebook_integration():
    """Check if Facebook integration is configured"""
    if not FB_VERIFY_TOKEN:
        log.error("FB_VERIFY_TOKEN is not set")
        return False
    
    if not FB_PAGE_ACCESS_TOKEN:
        log.error("FB_PAGE_ACCESS_TOKEN is not set")
        return False
    
    log.info("Facebook integration tokens are set")
    return True

def check_database_connection():
    """Check if the database connection is working"""
    try:
        from backend.db import get_db_connection, release_db_connection
        
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1")
        result = cursor.fetchone()
        release_db_connection(conn)
        
        if result and result[0] == 1:
            log.info("Database connection is working")
            return True
        else:
            log.error("Database connection test failed")
            return False
    except Exception as e:
        log.error(f"Error checking database connection: {str(e)}")
        return False

def check_frontend_connection():
    """Check if the frontend can connect to the API"""
    try:
        response = requests.get(f"{FRONTEND_URL}")
        if response.status_code == 200:
            log.info(f"Frontend is accessible: {FRONTEND_URL}")
            return True
        else:
            log.error(f"Frontend is not accessible with status code {response.status_code}")
            return False
    except Exception as e:
        log.error(f"Error checking frontend: {str(e)}")
        return False

def main():
    """Main function to run all checks"""
    log.info("Starting deployment checks...")
    
    api_health = check_api_health()
    facebook_integration = check_facebook_integration()
    database_connection = check_database_connection()
    frontend_connection = check_frontend_connection()
    
    log.info("Deployment check results:")
    log.info(f"API Health: {'✅' if api_health else '❌'}")
    log.info(f"Facebook Integration: {'✅' if facebook_integration else '❌'}")
    log.info(f"Database Connection: {'✅' if database_connection else '❌'}")
    log.info(f"Frontend Connection: {'✅' if frontend_connection else '❌'}")
    
    if all([api_health, facebook_integration, database_connection, frontend_connection]):
        log.info("All checks passed! Deployment is working correctly.")
        return 0
    else:
        log.error("Some checks failed. Please fix the issues above.")
        return 1

if __name__ == "__main__":
    sys.exit(main())

================================================================================
File: clean_templates.py
Path: .\clean_templates.py
Size: 3903
Modified: 2025-05-02T10:52:19.512566
Created: 2025-04-15T23:22:37.402725
Hash: 2ac3517a7623388e2ce78bfb6b47f01b682c267fae587fe7b6f94db9f1d4cb97
Lines: 121
================================================================================
#!/usr/bin/env python3
"""
Script to clean up templates that are not registered to any stage.
This script will:
1. Find all templates that are not referenced in any stage's template fields
2. Delete those unused templates
3. Log the cleanup process
"""

import logging
import sys
import os

# Add the backend directory to the Python path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

from db import get_db_connection, release_db_connection

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
log = logging.getLogger(__name__)

def find_unused_templates(conn):
    """
    Find templates that are not referenced in any stage.
    
    Args:
        conn: Database connection
        
    Returns:
        List of template IDs that are not used by any stage
    """
    cursor = conn.cursor()
    
    # Get all template IDs that are not referenced in any stage
    cursor.execute("""
        SELECT t.template_id, t.template_name, t.template_type
        FROM templates t
        WHERE NOT EXISTS (
            SELECT 1 FROM stages s
            WHERE s.stage_selection_template_id = t.template_id
            OR s.data_extraction_template_id = t.template_id
            OR s.response_generation_template_id = t.template_id
        )
    """)
    
    unused_templates = cursor.fetchall()
    return unused_templates

def delete_unused_templates(conn, unused_templates):
    """
    Delete the unused templates from the database.
    
    Args:
        conn: Database connection
        unused_templates: List of (template_id, template_name, template_type) tuples
    """
    cursor = conn.cursor()
    
    for template_id, template_name, template_type in unused_templates:
        try:
            cursor.execute("DELETE FROM templates WHERE template_id = %s", (template_id,))
            log.info(f"Deleted unused template: {template_name} (ID: {template_id}, Type: {template_type})")
        except Exception as e:
            log.error(f"Error deleting template {template_id}: {str(e)}")
            conn.rollback()
            return False
    
    conn.commit()
    return True

def main():
    """Main function to clean up unused templates."""
    conn = None
    try:
        log.info("Starting template cleanup process...")
        
        # Get database connection
        conn = get_db_connection()
        
        # Find unused templates
        unused_templates = find_unused_templates(conn)
        
        if not unused_templates:
            log.info("No unused templates found. Database is clean.")
            return
        
        # Log found templates
        log.info(f"Found {len(unused_templates)} unused templates:")
        for template_id, template_name, template_type in unused_templates:
            log.info(f"- {template_name} (ID: {template_id}, Type: {template_type})")
        
        # Confirm deletion
        response = input("\nDo you want to delete these unused templates? (yes/no): ")
        if response.lower() != 'yes':
            log.info("Template cleanup cancelled by user.")
            return
        
        # Delete unused templates
        if delete_unused_templates(conn, unused_templates):
            log.info("Successfully cleaned up unused templates.")
        else:
            log.error("Failed to clean up some templates. Check the logs for details.")
            
    except Exception as e:
        log.error(f"Error during template cleanup: {str(e)}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            release_db_connection(conn)
            log.info("Database connection closed.")

if __name__ == "__main__":
    main()

================================================================================
File: create_data_extraction_template.py
Path: .\create_data_extraction_template.py
Size: 3811
Modified: 2025-05-02T10:52:19.512566
Created: 2025-04-17T11:12:48.251224
Hash: 871569e20d0e9ae9d8fd1c27c54a00ff78c20910210b45c9f15ed14744829bcc
Lines: 109
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid
import json

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def create_data_extraction_template(business_id, template_name, extraction_fields):
    """
    Create a new data extraction template.
    
    Args:
        business_id (str): The business ID
        template_name (str): Name of the template
        extraction_fields (dict): Dictionary of field names and their regex patterns
    """
    try:
        print("Connecting to PostgreSQL database...")
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor(cursor_factory=DictCursor)
        
        # Generate template content from extraction fields
        content = "Extract the following information from the message:\n"
        for field, pattern in extraction_fields.items():
            content += f"- {field}: {pattern}\n"
        
        # Create system prompt
        system_prompt = """You are a data extraction assistant. Extract the requested information from the user's message.
Return the data in JSON format with the specified field names.
If a field is not found in the message, set its value to null."""
        
        # Insert the template
        template_id = str(uuid.uuid4())
        cursor.execute(
            """
            INSERT INTO templates
            (template_id, business_id, template_name, template_type, content, system_prompt)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING template_id
            """,
            (
                template_id,
                business_id,
                template_name,
                'data_extraction',
                content,
                system_prompt
            )
        )
        
        # Commit the transaction
        conn.commit()
        
        print(f"Created data extraction template: {template_name}")
        print(f"Template ID: {template_id}")
        print("\nTemplate Content:")
        print(content)
        print("\nSystem Prompt:")
        print(system_prompt)
        
        return template_id
        
    except Exception as e:
        print(f"Error creating template: {str(e)}")
        if conn:
            conn.rollback()
        raise
    finally:
        if conn:
            conn.close()

def main():
    # Example usage
    business_id = "your_business_id"  # Replace with actual business ID
    
    # Define extraction fields and their patterns
    extraction_fields = {
        "name": "(?:name|call me|i am|this is) ([A-Za-z\\s]+)",
        "email": "([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})",
        "phone": "(\\+\\d{1,3}[-.\\s]?\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4})",
        "address": "(?:address|location|live at|located at) ([A-Za-z0-9\\s,.-]+)",
        "order_number": "(?:order|order number|order #|order#) ([A-Z0-9-]+)",
        "product_name": "(?:product|item) ([A-Za-z0-9\\s-]+)",
        "quantity": "(?:quantity|qty|amount) (\\d+)"
    }
    
    try:
        template_id = create_data_extraction_template(
            business_id=business_id,
            template_name="Customer Information Extraction",
            extraction_fields=extraction_fields
        )
        print(f"\nTemplate created successfully with ID: {template_id}")
    except Exception as e:
        print(f"Failed to create template: {str(e)}")

if __name__ == "__main__":
    main()

================================================================================
File: create_llm_calls_table.py
Path: .\create_llm_calls_table.py
Size: 2776
Modified: 2025-05-02T10:52:19.529051
Created: 2025-04-13T00:35:00.213914
Hash: 720d12c6fd15494146476bee95dc4761fb4f8cc11f882550f0d55ca680d96614
Lines: 81
================================================================================
import os
import psycopg2
from psycopg2.extras import DictCursor
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def main():
    conn = None
    cursor = None
    try:
        print("Connecting to PostgreSQL database...")
        print(f"Using database: {DB_CONFIG['dbname']}")
        print(f"Using user: {DB_CONFIG['user']}")
        print(f"Using host: {DB_CONFIG['host']}:{DB_CONFIG['port']}")
        
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor(cursor_factory=DictCursor)
        
        # Create the llm_calls table
        print("\nCreating llm_calls table...")
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS llm_calls (
                call_id UUID PRIMARY KEY,
                business_id UUID NOT NULL,
                input_text TEXT NOT NULL,
                response TEXT NOT NULL,
                system_prompt TEXT,
                call_type VARCHAR(50),
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        
        # Create indexes
        print("Creating indexes...")
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_llm_calls_business_id 
            ON llm_calls (business_id);
        """)
        
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_llm_calls_timestamp 
            ON llm_calls (timestamp);
        """)
        
        conn.commit()
        print("Table and indexes created successfully!")
        
    except psycopg2.OperationalError as e:
        print("\nError: Could not connect to the database.")
        print("Please ensure:")
        print("1. PostgreSQL is running")
        print("2. The user 'icmp_user' exists in PostgreSQL")
        print("3. The password in .env file matches the user's password")
        print("\nTo create the user and set the password, run these commands in psql:")
        print("CREATE USER icmp_user WITH PASSWORD 'icmp_password';")
        print("ALTER USER icmp_user WITH SUPERUSER;")
        print("CREATE DATABASE icmp_db OWNER icmp_user;")
        print("\nDetailed error:", str(e))
    except Exception as e:
        print(f"\nError: {str(e)}")
        if conn:
            conn.rollback()
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

if __name__ == "__main__":
    main()

================================================================================
File: delete_all.py
Path: .\delete_all.py
Size: 3873
Modified: 2025-05-02T10:52:19.529051
Created: 2025-04-15T23:28:16.136283
Hash: 0c0e558041577a75ab17aff6b310814a05869efaaf15e323ee61ea7e7e36bc4f
Lines: 126
================================================================================
#!/usr/bin/env python3
"""
Script to delete all conversation and message records from the system.
This script will:
1. Delete all messages from the messages table
2. Delete all conversations from the conversations table
3. Log the cleanup process
"""

import logging
import sys
import os

# Add the backend directory to the Python path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

from db import get_db_connection, release_db_connection

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
log = logging.getLogger(__name__)

def get_record_counts(conn):
    """
    Get the current count of conversations and messages.
    
    Args:
        conn: Database connection
        
    Returns:
        Tuple of (conversation_count, message_count)
    """
    cursor = conn.cursor()
    
    # Get conversation count
    cursor.execute("SELECT COUNT(*) FROM conversations")
    conversation_count = cursor.fetchone()[0]
    
    # Get message count
    cursor.execute("SELECT COUNT(*) FROM messages")
    message_count = cursor.fetchone()[0]
    
    return conversation_count, message_count

def delete_all_records(conn):
    """
    Delete all records from the messages and conversations tables.
    
    Args:
        conn: Database connection
        
    Returns:
        Tuple of (deleted_conversation_count, deleted_message_count)
    """
    cursor = conn.cursor()
    
    # Get counts before deletion
    before_conv_count, before_msg_count = get_record_counts(conn)
    
    # Delete all messages first (due to foreign key constraints)
    cursor.execute("DELETE FROM messages")
    deleted_message_count = cursor.rowcount
    
    # Delete all conversations
    cursor.execute("DELETE FROM conversations")
    deleted_conversation_count = cursor.rowcount
    
    # Commit the transaction
    conn.commit()
    
    return deleted_conversation_count, deleted_message_count

def main():
    """Main function to delete all conversation and message records."""
    conn = None
    try:
        log.info("Starting database cleanup process...")
        
        # Get database connection
        conn = get_db_connection()
        
        # Get current record counts
        conversation_count, message_count = get_record_counts(conn)
        
        if conversation_count == 0 and message_count == 0:
            log.info("No records found. Database is already clean.")
            return
        
        # Log current counts
        log.info(f"Current record counts:")
        log.info(f"- Conversations: {conversation_count}")
        log.info(f"- Messages: {message_count}")
        
        # Confirm deletion
        response = input("\nWARNING: This will delete ALL conversations and messages from the database.\n"
                         "This action cannot be undone. Are you sure you want to continue? (yes/no): ")
        
        if response.lower() != 'yes':
            log.info("Database cleanup cancelled by user.")
            return
        
        # Delete all records
        deleted_conv_count, deleted_msg_count = delete_all_records(conn)
        
        # Log results
        log.info(f"Database cleanup completed successfully:")
        log.info(f"- Deleted {deleted_conv_count} conversations")
        log.info(f"- Deleted {deleted_msg_count} messages")
        
    except Exception as e:
        log.error(f"Error during database cleanup: {str(e)}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            release_db_connection(conn)
            log.info("Database connection closed.")

if __name__ == "__main__":
    main()

================================================================================
File: deploy.py
Path: .\deploy.py
Size: 2464
Modified: 2025-05-02T10:52:19.537224
Created: 2025-04-18T17:28:31.984287
Hash: ba39be9565cc2bdd0487a7f4d06f27bc5eeaf8b64e8dd03159a29ce1aa5b3ccf
Lines: 74
================================================================================
#!/usr/bin/env python
# deploy.py - Script to deploy the ICMP Events API

import os
import sys
import subprocess
import platform
import venv
import shutil
from pathlib import Path

def create_virtual_environment():
    """Create a virtual environment if it doesn't exist."""
    venv_path = Path("venv")
    if not venv_path.exists():
        print("Creating virtual environment...")
        venv.create(venv_path, with_pip=True)
    else:
        print("Virtual environment already exists.")

def get_python_executable():
    """Get the path to the Python executable in the virtual environment."""
    if platform.system() == "Windows":
        return os.path.join("venv", "Scripts", "python.exe")
    else:
        return os.path.join("venv", "bin", "python")

def get_pip_executable():
    """Get the path to the pip executable in the virtual environment."""
    if platform.system() == "Windows":
        return os.path.join("venv", "Scripts", "pip.exe")
    else:
        return os.path.join("venv", "bin", "pip")

def install_dependencies():
    """Install the required dependencies."""
    print("Installing dependencies...")
    pip_executable = get_pip_executable()
    subprocess.run([pip_executable, "install", "-r", "requirements.txt"], check=True)
    subprocess.run([pip_executable, "install", "-r", "backend/requirements.txt"], check=True)

def setup_environment():
    """Set up the environment variables."""
    print("Setting up environment variables...")
    # Check if .env file exists, if not create it
    if not os.path.exists(".env"):
        with open(".env", "w") as f:
            f.write("""DB_NAME=icmp_db
DB_USER=icmp_user
DB_PASSWORD=your_password
DB_HOST=localhost
DB_PORT=5432
POSTGRES_PASSWORD=postgres""")
        print("Created .env file with default values. Please update with your actual database credentials.")

def run_application():
    """Run the application."""
    print("Starting the application...")
    python_executable = get_python_executable()
    subprocess.run([python_executable, "application.py"], check=True)

def main():
    """Main function to deploy the application."""
    try:
        create_virtual_environment()
        install_dependencies()
        setup_environment()
        run_application()
    except Exception as e:
        print(f"Error during deployment: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

================================================================================
File: install.py
Path: .\install.py
Size: 4404
Modified: 2025-05-02T10:52:19.545449
Created: 2025-04-18T18:08:18.899249
Hash: b7f4a445a5cdceb4ce01fc748e07198cc33276c88ea6968d77fdc5fabb00f307
Lines: 148
================================================================================
import os
import shutil
import subprocess
import sys
from pathlib import Path

def check_python_version():
    """Check if Python version is compatible."""
    if sys.version_info < (3, 9):
        print("Python 3.9 or higher is required")
        sys.exit(1)

def install_requirements():
    """Install required Python packages."""
    print("\n📦 Installing Python requirements...")
    requirements_files = ['requirements.txt', 'backend/requirements.txt']
    for req_file in requirements_files:
        if os.path.exists(req_file):
            subprocess.run([sys.executable, '-m', 'pip', 'install', '-r', req_file])

def setup_directories():
    """Create necessary directories."""
    print("\n📁 Setting up directories...")
    directories = ['logs', 'uploads', 'temp']
    for directory in directories:
        os.makedirs(directory, exist_ok=True)
    print("✅ Directories created successfully")

def prepare_env_file():
    """Check if .env file exists and is properly configured."""
    print("\n🔧 Checking environment configuration...")
    required_vars = [
        'DB_NAME',
        'DB_USER',
        'DB_PASSWORD',
        'DB_HOST',
        'DB_PORT',
        'DATABASE_URL'
    ]
    
    if not os.path.exists('.env'):
        print("❌ .env file not found!")
        return False
    
    with open('.env', 'r') as f:
        env_content = f.read()
    
    missing_vars = []
    for var in required_vars:
        if var not in env_content:
            missing_vars.append(var)
    
    if missing_vars:
        print("❌ Missing environment variables:", ', '.join(missing_vars))
        return False
    
    print("✅ Environment configuration verified")
    return True

def setup_database():
    """Set up the database using setup_database.py."""
    print("\n🗄️ Setting up database...")
    try:
        import setup_database
        setup_database.setup_database()
        print("✅ Database setup completed")
        return True
    except Exception as e:
        print(f"❌ Database setup failed: {str(e)}")
        return False

def prepare_render_files():
    """Prepare files for Render deployment."""
    print("\n📤 Preparing files for upload...")
    
    # Create a temporary directory for the upload package
    temp_dir = Path('temp/render_upload')
    temp_dir.mkdir(parents=True, exist_ok=True)
    
    # Files and directories to include
    include_items = [
        'backend/',
        'requirements.txt',
        'application.py',
        'build.sh',
        'render.yaml',
        'database_setup.sql',
        'setup_database.py',
        '.env'
    ]
    
    # Copy files to temp directory
    for item in include_items:
        src = Path(item)
        dst = temp_dir / src.name
        
        if src.is_file():
            shutil.copy2(src, dst)
        elif src.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(src, dst)
    
    # Create zip file
    shutil.make_archive('render_upload', 'zip', temp_dir)
    
    # Cleanup
    shutil.rmtree(temp_dir)
    
    print("✅ Files prepared successfully")
    print("📦 Upload package created: render_upload.zip")

def main():
    """Main installation process."""
    print("🚀 Starting installation process...")
    
    # Check Python version
    check_python_version()
    
    # Install requirements
    install_requirements()
    
    # Setup directories
    setup_directories()
    
    # Check environment configuration
    if not prepare_env_file():
        print("\n❌ Installation failed: Environment configuration issues")
        return
    
    # Setup database
    if not setup_database():
        print("\n❌ Installation failed: Database setup issues")
        return
    
    # Prepare files for upload
    prepare_render_files()
    
    print("\n✨ Installation completed successfully!")
    print("\nNext steps:")
    print("1. Find the 'render_upload.zip' file in your current directory")
    print("2. Go to render.com and create a new Web Service")
    print("3. Upload the zip file when prompted")
    print("4. Configure the environment variables in the Render dashboard")
    print("5. Deploy your application")

if __name__ == "__main__":
    main()

================================================================================
File: llm_debugger.py
Path: .\llm_debugger.py
Size: 16875
Modified: 2025-05-02T10:52:19.561669
Created: 2025-04-12T22:27:14.574076
Hash: 6a3474935a6ae4b8ef8097eaa8ee4954748a614ab98ca501b8232d37715da181
Lines: 364
================================================================================
#!/usr/bin/env python
# llm_debugger.py - Command-line debugger for ICMP LLM system

import os
import sys
import json
import argparse
import requests
from datetime import datetime
from tabulate import tabulate
from colorama import Fore, Style, init
import time

# Initialize colorama
init(autoreset=True)

# Default configuration
DEFAULT_API_BASE_URL = 'http://127.0.0.1:5000'
DEFAULT_BUSINESS_ID = '7ae167a0-d864-43b9-bdaf-fcba35b33f27'
DEFAULT_API_KEY = 'da828cae6a3e46228aa09d65ba9066e3'

class LLMDebugger:
    """Command-line debugger for ICMP LLM system"""
    
    def __init__(self, api_base_url, business_id, api_key, owner_id=None):
        """Initialize the debugger with API credentials"""
        self.api_base_url = api_base_url
        self.business_id = business_id
        self.api_key = api_key
        self.owner_id = owner_id
        self.is_logged_in = False
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'businessapikey': api_key
        })
    
    def login(self):
        """Login to the API using business ID and API key"""
        if not self.owner_id:
            print(f"{Fore.YELLOW}No owner ID provided. Attempting to look up owner...{Style.RESET_ALL}")
            self.lookup_owner()
        
        if not self.owner_id:
            print(f"{Fore.RED}Failed to get owner ID. Cannot login.{Style.RESET_ALL}")
            return False
        
        url = f"{self.api_base_url}/api/verify-owner"
        data = {
            "userId": self.owner_id,
            "businessId": self.business_id,
            "businessApiKey": self.api_key
        }
        
        try:
            response = self.session.post(url, json=data)
            if response.status_code == 200:
                result = response.json()
                if result.get('success'):
                    self.is_logged_in = True
                    print(f"{Fore.GREEN}Login successful!{Style.RESET_ALL}")
                    return True
                else:
                    print(f"{Fore.RED}Login failed: {result.get('error', 'Unknown error')}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}Login failed with status code: {response.status_code}{Style.RESET_ALL}")
                try:
                    error_data = response.json()
                    print(f"{Fore.RED}Error: {error_data.get('error', 'Unknown error')}{Style.RESET_ALL}")
                except:
                    print(f"{Fore.RED}Error: {response.text}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Login error: {str(e)}{Style.RESET_ALL}")
        
        return False
    
    def lookup_owner(self):
        """Look up the owner ID for the business"""
        url = f"{self.api_base_url}/api/lookup-owner"
        data = {
            "businessId": self.business_id,
            "businessApiKey": self.api_key
        }
        
        try:
            response = self.session.post(url, json=data)
            if response.status_code == 200:
                result = response.json()
                if result.get('success'):
                    self.owner_id = result.get('owner_id')
                    print(f"{Fore.GREEN}Owner ID found: {self.owner_id}{Style.RESET_ALL}")
                    return True
                else:
                    print(f"{Fore.RED}Lookup failed: {result.get('error', 'Unknown error')}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}Lookup failed with status code: {response.status_code}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Lookup error: {str(e)}{Style.RESET_ALL}")
        
        return False
    
    def make_llm_call(self, input_text, system_prompt=None, call_type="general"):
        """Make an LLM call to the API"""
        if not self.is_logged_in:
            print(f"{Fore.YELLOW}Not logged in. Attempting to login...{Style.RESET_ALL}")
            if not self.login():
                print(f"{Fore.RED}Login failed. Cannot make LLM call.{Style.RESET_ALL}")
                return None
        
        url = f"{self.api_base_url}/api/llm/generate"
        data = {
            "business_id": self.business_id,
            "input_text": input_text,
            "system_prompt": system_prompt,
            "call_type": call_type
        }
        
        try:
            print(f"{Fore.CYAN}Making LLM call...{Style.RESET_ALL}")
            print(f"{Fore.CYAN}Input text: {input_text}{Style.RESET_ALL}")
            if system_prompt:
                print(f"{Fore.CYAN}System prompt: {system_prompt}{Style.RESET_ALL}")
            print(f"{Fore.CYAN}Call type: {call_type}{Style.RESET_ALL}")
            
            start_time = datetime.now()
            response = self.session.post(url, json=data)
            end_time = datetime.now()
            processing_time = (end_time - start_time).total_seconds() * 1000  # in milliseconds
            
            if response.status_code == 200:
                result = response.json()
                if result.get('success'):
                    print(f"{Fore.GREEN}LLM call successful!{Style.RESET_ALL}")
                    print(f"{Fore.GREEN}Processing time: {processing_time:.2f} ms{Style.RESET_ALL}")
                    print(f"{Fore.GREEN}Response:{Style.RESET_ALL}")
                    print(f"{Fore.WHITE}{result.get('response', '')}{Style.RESET_ALL}")
                    return result
                else:
                    print(f"{Fore.RED}LLM call failed: {result.get('error', 'Unknown error')}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}LLM call failed with status code: {response.status_code}{Style.RESET_ALL}")
                try:
                    error_data = response.json()
                    print(f"{Fore.RED}Error: {error_data.get('error', 'Unknown error')}{Style.RESET_ALL}")
                except:
                    print(f"{Fore.RED}Error: {response.text}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}LLM call error: {str(e)}{Style.RESET_ALL}")
        
        return None
    
    def get_recent_calls(self, limit=10):
        """Get recent LLM calls"""
        if not self.is_logged_in:
            print(f"{Fore.YELLOW}Not logged in. Attempting to login...{Style.RESET_ALL}")
            if not self.login():
                print(f"{Fore.RED}Login failed. Cannot get recent calls.{Style.RESET_ALL}")
                return None
        
        url = f"{self.api_base_url}/api/llm/calls/recent?business_id={self.business_id}&limit={limit}"
        
        try:
            response = self.session.get(url)
            if response.status_code == 200:
                calls = response.json()
                if calls:
                    print(f"{Fore.GREEN}Found {len(calls)} recent LLM calls:{Style.RESET_ALL}")
                    
                    # Prepare data for tabulate
                    table_data = []
                    for call in calls:
                        timestamp = datetime.fromisoformat(call.get('timestamp', '')).strftime('%Y-%m-%d %H:%M:%S') if call.get('timestamp') else 'N/A'
                        table_data.append([
                            call.get('call_id', 'N/A'),
                            call.get('call_type', 'general'),
                            timestamp,
                            call.get('input_text', '')[:50] + '...' if len(call.get('input_text', '')) > 50 else call.get('input_text', '')
                        ])
                    
                    # Print table
                    print(tabulate(table_data, headers=['Call ID', 'Type', 'Timestamp', 'Input Text'], tablefmt='grid'))
                    return calls
                else:
                    print(f"{Fore.YELLOW}No recent LLM calls found.{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}Failed to get recent calls with status code: {response.status_code}{Style.RESET_ALL}")
                try:
                    error_data = response.json()
                    print(f"{Fore.RED}Error: {error_data.get('error', 'Unknown error')}{Style.RESET_ALL}")
                except:
                    print(f"{Fore.RED}Error: {response.text}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Error getting recent calls: {str(e)}{Style.RESET_ALL}")
        
        return None
    
    def get_call_details(self, call_id):
        """Get details for a specific LLM call"""
        if not self.is_logged_in:
            print(f"{Fore.YELLOW}Not logged in. Attempting to login...{Style.RESET_ALL}")
            if not self.login():
                print(f"{Fore.RED}Login failed. Cannot get call details.{Style.RESET_ALL}")
                return None
        
        url = f"{self.api_base_url}/api/llm/calls/{call_id}?business_id={self.business_id}"
        
        try:
            response = self.session.get(url)
            if response.status_code == 200:
                call = response.json()
                if call:
                    print(f"{Fore.GREEN}Call details for ID: {call_id}{Style.RESET_ALL}")
                    
                    # Print call details
                    print(f"{Fore.CYAN}Call ID:{Style.RESET_ALL} {call.get('call_id', 'N/A')}")
                    print(f"{Fore.CYAN}Call Type:{Style.RESET_ALL} {call.get('call_type', 'general')}")
                    print(f"{Fore.CYAN}Timestamp:{Style.RESET_ALL} {call.get('timestamp', 'N/A')}")
                    
                    print(f"\n{Fore.CYAN}Input Text:{Style.RESET_ALL}")
                    print(f"{Fore.WHITE}{call.get('input_text', 'N/A')}{Style.RESET_ALL}")
                    
                    if call.get('system_prompt'):
                        print(f"\n{Fore.CYAN}System Prompt:{Style.RESET_ALL}")
                        print(f"{Fore.WHITE}{call.get('system_prompt')}{Style.RESET_ALL}")
                    
                    print(f"\n{Fore.CYAN}Response:{Style.RESET_ALL}")
                    print(f"{Fore.WHITE}{call.get('response', 'N/A')}{Style.RESET_ALL}")
                    
                    # Print performance metrics
                    print(f"\n{Fore.CYAN}Performance Metrics:{Style.RESET_ALL}")
                    print(f"{Fore.WHITE}Processing Time: {call.get('processing_time_ms', 'N/A')} ms{Style.RESET_ALL}")
                    print(f"{Fore.WHITE}Token Usage: {call.get('token_usage', 'N/A')} tokens{Style.RESET_ALL}")
                    print(f"{Fore.WHITE}Estimated Cost: ${call.get('estimated_cost', 'N/A')}{Style.RESET_ALL}")
                    
                    return call
                else:
                    print(f"{Fore.YELLOW}No call details found for ID: {call_id}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}Failed to get call details with status code: {response.status_code}{Style.RESET_ALL}")
                try:
                    error_data = response.json()
                    print(f"{Fore.RED}Error: {error_data.get('error', 'Unknown error')}{Style.RESET_ALL}")
                except:
                    print(f"{Fore.RED}Error: {response.text}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Error getting call details: {str(e)}{Style.RESET_ALL}")
        
        return None
    
    def check_api_health(self):
        """Check if the API server is running"""
        url = f"{self.api_base_url}/health"
        
        try:
            response = requests.get(url)
            if response.status_code == 200:
                data = response.json()
                print(f"{Fore.GREEN}API server is running. Database: {data.get('database', 'Unknown')}{Style.RESET_ALL}")
                return True
            else:
                print(f"{Fore.RED}API server returned status: {response.status_code}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}API server check failed: {str(e)}{Style.RESET_ALL}")
        
        return False
    
    def watch_calls(self, interval=5):
        """Continuously watch for new LLM calls"""
        if not self.is_logged_in:
            print(f"{Fore.YELLOW}Not logged in. Attempting to login...{Style.RESET_ALL}")
            if not self.login():
                print(f"{Fore.RED}Login failed. Cannot watch calls.{Style.RESET_ALL}")
                return
        
        print(f"{Fore.GREEN}Watching for new LLM calls (checking every {interval} seconds)...{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Press Ctrl+C to stop watching{Style.RESET_ALL}")
        
        last_call_id = None
        try:
            while True:
                calls = self.get_recent_calls(limit=1)
                if calls and calls[0]['call_id'] != last_call_id:
                    last_call_id = calls[0]['call_id']
                    print(f"\n{Fore.CYAN}New LLM Call Detected:{Style.RESET_ALL}")
                    print(f"Call ID: {calls[0]['call_id']}")
                    print(f"Timestamp: {calls[0]['timestamp']}")
                    print(f"Type: {calls[0]['call_type']}")
                    print(f"Input: {calls[0]['input_text']}")
                    print(f"Response: {calls[0]['response']}")
                    print("-" * 80)
                
                time.sleep(interval)
        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}Stopped watching LLM calls{Style.RESET_ALL}")

def main():
    """Main function for the command-line interface"""
    # Create the main parser
    parser = argparse.ArgumentParser(description='ICMP LLM API Debugger')
    
    # Add global arguments
    parser.add_argument('--api-url', default=DEFAULT_API_BASE_URL, help='API base URL')
    parser.add_argument('--business-id', default=DEFAULT_BUSINESS_ID, help='Business ID')
    parser.add_argument('--api-key', default=DEFAULT_API_KEY, help='API Key')
    parser.add_argument('--owner-id', help='Owner ID (optional)')
    
    # Create subparsers for commands
    subparsers = parser.add_subparsers(dest='command', help='Command to execute')
    
    # Login command
    login_parser = subparsers.add_parser('login', help='Login to the API')
    
    # Make LLM call command
    call_parser = subparsers.add_parser('call', help='Make an LLM call')
    call_parser.add_argument('--input', required=True, help='Input text for the LLM')
    call_parser.add_argument('--system-prompt', help='System prompt (optional)')
    call_parser.add_argument('--type', default='general', choices=['general', 'stage_selection', 'data_extraction', 'response_generation'], 
                            help='Call type')
    
    # Get recent calls command
    recent_parser = subparsers.add_parser('recent', help='Get recent LLM calls')
    recent_parser.add_argument('--limit', type=int, default=10, help='Number of calls to retrieve')
    
    # Get call details command
    details_parser = subparsers.add_parser('details', help='Get details for a specific LLM call')
    details_parser.add_argument('--call-id', required=True, help='Call ID')
    
    # Health check command
    health_parser = subparsers.add_parser('health', help='Check API health')
    
    # Watch command for continuous monitoring
    watch_parser = subparsers.add_parser('watch', help='Continuously watch for new LLM calls')
    watch_parser.add_argument('--interval', type=int, default=5, help='Check interval in seconds')
    
    # Parse arguments
    args = parser.parse_args()
    
    # Create debugger instance
    debugger = LLMDebugger(args.api_url, args.business_id, args.api_key, args.owner_id)
    
    # Check API health first
    if not debugger.check_api_health():
        print(f"{Fore.RED}API server is not running. Please start the server and try again.{Style.RESET_ALL}")
        return
    
    # Execute command
    if args.command == 'login':
        debugger.login()
    elif args.command == 'call':
        debugger.make_llm_call(args.input, args.system_prompt, args.type)
    elif args.command == 'recent':
        debugger.get_recent_calls(args.limit)
    elif args.command == 'details':
        debugger.get_call_details(args.call_id)
    elif args.command == 'health':
        debugger.check_api_health()
    elif args.command == 'watch':
        debugger.watch_calls(args.interval)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()

================================================================================
File: run.py
Path: .\run.py
Size: 282
Modified: 2025-05-02T11:36:27.881062
Created: 2025-05-02T11:34:21.747720
Hash: a5bb8330a8fcb456b061879c5f30dcad5d9b14ce1b2226c3e3f53ff015292c13
Lines: 12
================================================================================
import os
import sys

# Add the root directory to Python path
root_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, root_dir)

# Now import and run the app
from backend.app import app

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True) 

================================================================================
File: run_local.py
Path: .\run_local.py
Size: 1430
Modified: 2025-05-02T10:52:19.578225
Created: 2025-04-20T02:08:37.029655
Hash: f19d383fcdbdf5d6f9903a68ba0f9c79c2c39613de315ba06f216b3573a0042e
Lines: 41
================================================================================
#!/usr/bin/env python3
"""
Script to run the application locally with the correct environment settings.
This bypasses the Render-specific configuration in application.py.
"""

import os
import sys
from dotenv import load_dotenv

# Load environment variables from .env files
backend_env_path = os.path.join(os.path.dirname(__file__), 'backend', '.env')
if os.path.exists(backend_env_path):
    load_dotenv(backend_env_path)
    print(f"Loaded environment from {backend_env_path}")
else:
    print(f"Warning: {backend_env_path} not found")

# Ensure the backend directory is in the path
current_dir = os.path.dirname(os.path.abspath(__file__))
backend_dir = os.path.join(current_dir, 'backend')
if backend_dir not in sys.path:
    sys.path.append(backend_dir)
if current_dir not in sys.path:
    sys.path.append(current_dir)

# Import directly from backend.app to bypass application.py
try:
    from backend.app import app

    if __name__ == '__main__':
        print("Starting local development server...")
        print(f"Database: {os.environ.get('DB_HOST')}:{os.environ.get('DB_PORT')}/{os.environ.get('DB_NAME')}")
        print(f"User: {os.environ.get('DB_USER')}")
        app.run(host='0.0.0.0', port=5000, debug=True)
except ImportError as e:
    print(f"Error importing app: {e}")
    sys.exit(1)
except Exception as e:
    print(f"Error starting application: {e}")
    sys.exit(1)

================================================================================
File: run_production_migration.py
Path: .\run_production_migration.py
Size: 2170
Modified: 2025-05-02T10:52:19.586420
Created: 2025-04-25T23:56:18.087887
Hash: 55bf3e19b3154798627a89fc25d2600d29af0be82c64fd6e5fbe128eccf3d0a8
Lines: 71
================================================================================
#!/usr/bin/env python3
"""
Script to run database migrations on the production database.
"""

import os
import sys
import psycopg2
import logging
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
log = logging.getLogger(__name__)

def run_migration():
    """Run the migration to add updated_at column to stages table."""
    
    # Load environment variables
    load_dotenv()
    
    # Get database configuration from environment variables
    db_config = {
        "dbname": os.environ.get("DB_NAME"),
        "user": os.environ.get("DB_USER"),
        "password": os.environ.get("DB_PASSWORD"),
        "host": os.environ.get("DB_HOST"),
        "port": os.environ.get("DB_PORT", "5432")
    }
    
    # Ensure all required environment variables are set
    required_vars = ["DB_NAME", "DB_USER", "DB_PASSWORD", "DB_HOST"]
    missing_vars = [var for var in required_vars if not os.environ.get(var)]
    if missing_vars:
        log.error(f"Missing required environment variables: {', '.join(missing_vars)}")
        sys.exit(1)
    
    try:
        # Connect to the database
        log.info("Connecting to database...")
        conn = psycopg2.connect(**db_config)
        conn.autocommit = True
        cursor = conn.cursor()
        
        # Read and execute the migration script
        log.info("Reading migration script...")
        with open('backend/migrations/04_add_updated_at_to_stages.sql', 'r') as sql_file:
            sql_script = sql_file.read()
            
        log.info("Executing migration script...")
        cursor.execute(sql_script)
        
        log.info("Migration completed successfully!")
        
    except Exception as e:
        log.error(f"An error occurred during migration: {str(e)}")
        sys.exit(1)
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

if __name__ == '__main__':
    run_migration()

================================================================================
File: serve_html.py
Path: .\serve_html.py
Size: 1795
Modified: 2025-05-02T10:52:19.594420
Created: 2025-04-12T20:51:44.496113
Hash: a78ce56a89bc9e06ea6c8bcc20b850e57f4a3a635719f7c94902661150fcc77d
Lines: 53
================================================================================
#!/usr/bin/env python3
# serve_html.py - Simple HTTP server to serve HTML files

import http.server
import socketserver
import os
import webbrowser
from urllib.parse import urlparse

# Configuration
PORT = 8000
DIRECTORY = os.path.dirname(os.path.abspath(__file__))

class MyHttpRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        # Add CORS headers
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization, businessapikey, Accept, Origin')
        self.send_header('Access-Control-Expose-Headers', 'Content-Type, Authorization, businessapikey')
        self.send_header('Access-Control-Max-Age', '3600')
        self.send_header('Cache-Control', 'no-store, no-cache, must-revalidate')
        return super().end_headers()
    
    def do_OPTIONS(self):
        # Handle preflight requests
        self.send_response(200)
        self.end_headers()

def run_server():
    # Change to the directory containing the HTML files
    os.chdir(DIRECTORY)
    
    # Create the server
    handler = MyHttpRequestHandler
    httpd = socketserver.TCPServer(("", PORT), handler)
    
    print(f"Server started at http://localhost:{PORT}")
    print(f"Serving files from: {DIRECTORY}")
    print("Press Ctrl+C to stop the server")
    
    # Open the browser to the server
    webbrowser.open(f"http://localhost:{PORT}/llm.html")
    
    # Start the server
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nServer stopped.")
        httpd.server_close()

if __name__ == "__main__":
    run_server()

================================================================================
File: serve_test.py
Path: .\serve_test.py
Size: 723
Modified: 2025-05-02T15:01:18.532207
Created: 2025-05-02T15:01:16.170320
Hash: d58a7a21e370ddf5c4075227d5747bfaca9a62a112499fd9569fa84ca03ca544
Lines: 20
================================================================================
from http.server import HTTPServer, SimpleHTTPRequestHandler
import os

class CORSRequestHandler(SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        super().end_headers()

    def do_OPTIONS(self):
        self.send_response(200)
        self.end_headers()

if __name__ == '__main__':
    port = 8000
    server_address = ('', port)
    httpd = HTTPServer(server_address, CORSRequestHandler)
    print(f"Serving on http://localhost:{port}")
    httpd.serve_forever()

================================================================================
File: setup.py
Path: .\setup.py
Size: 2088
Modified: 2025-05-02T10:52:19.602669
Created: 2025-04-09T16:32:18.804998
Hash: 0149930297eca90209febb25d0111daf96f072fc7002ea6964b3fc0182cb5e4e
Lines: 60
================================================================================
import os
import sys
import psycopg2
from dotenv import load_dotenv

# Add the current directory to Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Load environment variables
load_dotenv()

def create_database():
    """Create the database and user if they don't exist."""
    try:
        # Connect to PostgreSQL with superuser privileges
        conn = psycopg2.connect(
            dbname='postgres',
            user='postgres',
            password=os.environ.get('POSTGRES_PASSWORD', 'postgres'),
            host=os.environ.get('DB_HOST', 'localhost'),
            port=os.environ.get('DB_PORT', '5432')
        )
        conn.autocommit = True
        cur = conn.cursor()

        # Create user if not exists
        cur.execute("SELECT 1 FROM pg_roles WHERE rolname = %s", (os.environ.get('DB_USER'),))
        if not cur.fetchone():
            cur.execute(f"CREATE USER {os.environ.get('DB_USER')} WITH PASSWORD %s", (os.environ.get('DB_PASSWORD'),))
            print(f"Created user {os.environ.get('DB_USER')}")

        # Create database if not exists
        cur.execute("SELECT 1 FROM pg_database WHERE datname = %s", (os.environ.get('DB_NAME'),))
        if not cur.fetchone():
            cur.execute(f"CREATE DATABASE {os.environ.get('DB_NAME')} OWNER {os.environ.get('DB_USER')}")
            print(f"Created database {os.environ.get('DB_NAME')}")

        cur.close()
        conn.close()
        print("Database and user setup completed successfully")
        return True

    except Exception as e:
        print(f"Error setting up database: {str(e)}")
        return False

def setup_schema():
    """Set up the database schema."""
    try:
        from backend.db import setup_database
        setup_database()
        print("Schema setup completed successfully")
        return True
    except Exception as e:
        print(f"Error setting up schema: {str(e)}")
        return False

if __name__ == '__main__':
    if create_database():
        setup_schema()

================================================================================
File: setup_database.py
Path: .\setup_database.py
Size: 1646
Modified: 2025-05-02T10:52:19.602669
Created: 2025-04-18T17:50:45.078827
Hash: 4351a983d925a1953cc8c6ab4c3286d0cfbd9f6356fa07c59bf53dcf92dc72c1
Lines: 50
================================================================================
import psycopg2
import os
from dotenv import load_dotenv

def setup_database():
    # Load environment variables
    load_dotenv()
    
    # Database connection parameters
    db_params = {
        "dbname": os.getenv("DB_NAME", "icmp_db"),
        "user": os.getenv("DB_USER", "icmp_user"),
        "password": os.getenv("DB_PASSWORD", "your_password"),
        "host": os.getenv("DB_HOST", "localhost"),
        "port": os.getenv("DB_PORT", "5432")
    }
    
    # Add check for password as it's often not defaulted
    if not db_params["password"] and not os.getenv("PGPASSWORD"): 
        print("ERROR: DB_PASSWORD environment variable not set and no default provided in script.")
        print("Please set DB_PASSWORD in your .env file.")
        return # Exit if password is truly missing

    try:
        # Connect to the database
        print("Connecting to the database...")
        conn = psycopg2.connect(**db_params)
        conn.autocommit = True
        cursor = conn.cursor()
        
        # Read and execute the SQL script
        print("Reading SQL script...")
        with open('database_setup.sql', 'r') as sql_file:
            sql_script = sql_file.read()
            
        print("Executing SQL script...")
        cursor.execute(sql_script)
        
        print("Database setup completed successfully!")
        
    except Exception as e:
        print(f"An error occurred: {str(e)}")
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

if __name__ == "__main__":
    setup_database()

================================================================================
File: setup_local_database.py
Path: .\setup_local_database.py
Size: 2678
Modified: 2025-05-02T10:52:19.619197
Created: 2025-04-20T02:05:05.649265
Hash: 6e3e4d71e374dae345ddf543f0d9a69757ab1fa48e54b23a370b47a021dda7d3
Lines: 90
================================================================================
#!/usr/bin/env python3
"""
Setup script for creating the local PostgreSQL database for development.
"""

import os
import sys
import psycopg2
from psycopg2 import sql
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
log = logging.getLogger(__name__)

def create_database():
    """Create the ICMP database and tables."""
    
    DB_NAME = os.environ.get("DB_NAME", "icmp_db")
    DB_USER = os.environ.get("DB_USER", "postgres")
    DB_PASSWORD = os.environ.get("DB_PASSWORD", "postgres")
    DB_HOST = os.environ.get("DB_HOST", "localhost")
    DB_PORT = os.environ.get("DB_PORT", "5432")
    
    # Connect to PostgreSQL to create database
    try:
        # Connect to default postgres database first
        conn = psycopg2.connect(
            dbname="postgres",
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        conn.autocommit = True
        cursor = conn.cursor()
        
        # Check if database exists
        cursor.execute("SELECT 1 FROM pg_database WHERE datname = %s", (DB_NAME,))
        exists = cursor.fetchone()
        
        if not exists:
            # Create database
            cursor.execute(sql.SQL("CREATE DATABASE {}").format(sql.Identifier(DB_NAME)))
            log.info(f"Database '{DB_NAME}' created successfully.")
        else:
            log.info(f"Database '{DB_NAME}' already exists.")
            
        cursor.close()
        conn.close()
        
        # Now connect to the newly created database to create tables
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        conn.autocommit = True
        cursor = conn.cursor()
        
        # Create tables
        with open('database_setup.sql', 'r') as f:
            sql_script = f.read()
            cursor.execute(sql_script)
        
        log.info("Tables created successfully.")
        cursor.close()
        conn.close()
        
        return True
        
    except Exception as e:
        log.error(f"Error creating database: {str(e)}")
        return False

if __name__ == "__main__":
    log.info("Starting local database setup...")
    if create_database():
        log.info("Local database setup completed successfully.")
    else:
        log.error("Local database setup failed.")
        sys.exit(1)

================================================================================
File: test_backend_connection.py
Path: .\test_backend_connection.py
Size: 2693
Modified: 2025-05-02T10:52:19.627472
Created: 2025-04-10T10:40:52.971353
Hash: 5149daa7441077928713092812df21bf7d1fdb070994e414952b07f594ec2541
Lines: 73
================================================================================
import requests
import sys
import json

def test_ping():
    """Test if the backend server is running by calling the /ping endpoint."""
    try:
        response = requests.get('http://127.0.0.1:5000/ping')
        if response.status_code == 200:
            print("SUCCESS: Backend server is running!")
            print(f"Response: {response.json()}")
            return True
        else:
            print(f"ERROR: Backend server returned status code {response.status_code}")
            print(f"Response: {response.text}")
            return False
    except requests.exceptions.ConnectionError:
        print("ERROR: Could not connect to backend server at http://127.0.0.1:5000/ping")
        print("Make sure the Flask server is running with 'flask run' in the backend directory")
        return False

def test_login():
    """Test if the backend login endpoint is working."""
    try:
        data = {
            "userId": "00000000-0000-0000-0000-000000000000",
            "businessId": "1c8cde77-0306-42dd-a0b6-c366a07651ad",
            "businessApiKey": "default_api_key"
        }
        
        response = requests.post(
            'http://127.0.0.1:5000/api/save-config',
            json=data,
            headers={
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        )
        
        print(f"Login Status Code: {response.status_code}")
        
        try:
            print(f"Login Response: {response.json()}")
        except json.JSONDecodeError:
            print(f"Login Response (not JSON): {response.text}")
            
        if response.status_code == 200:
            print("SUCCESS: Login endpoint is working!")
            return True
        else:
            print(f"ERROR: Login endpoint returned status code {response.status_code}")
            return False
    except requests.exceptions.ConnectionError:
        print("ERROR: Could not connect to backend server at http://127.0.0.1:5000/api/save-config")
        return False

if __name__ == "__main__":
    print("Testing backend server connectivity...")
    ping_success = test_ping()
    
    if ping_success:
        print("\nTesting login endpoint...")
        login_success = test_login()
        
        if login_success:
            print("\nAll tests passed! The backend server is running and accessible.")
            sys.exit(0)
        else:
            print("\nLogin test failed. Check the error messages above.")
            sys.exit(1)
    else:
        print("\nPing test failed. Make sure the Flask server is running.")
        sys.exit(1)

================================================================================
File: test_conversation_history.py
Path: .\test_conversation_history.py
Size: 2974
Modified: 2025-05-02T23:56:19.631725
Created: 2025-05-02T23:24:15.363425
Hash: 1e6b402e05535a9991feebe5b775873f0afb6fb2a524de2d0678bac3fe81ea37
Lines: 84
================================================================================
#!/usr/bin/env python
import sys
import os
import logging
from datetime import datetime
from backend.db import get_db_connection, release_db_connection
from backend.message_processing.standard_variables import provide_conversation_history
import argparse

# Configure logging
logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

def test_conversation_history(user_id=None):
    # Test parameters
    default_user_id = "2c50e7a1-e9bf-43ef-8450-fcf3b0354c96"
    business_id = "bc7e1824-49b4-4056-aabe-b045a1f79e3b"
    api_key = "cd0fd3314e8f1fe7cef737db4ac21778ccc7d5a97bbb33d9af17612e337231d6"
    user_id = user_id or default_user_id
    log.info(f"Using user_id: {user_id}")
    
    # Get database connection
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
            
        # First, verify the business exists and get a conversation_id
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT c.conversation_id 
            FROM conversations c
            JOIN businesses b ON c.business_id = b.business_id
            WHERE c.business_id = %s 
            AND b.api_key = %s
            AND c.user_id = %s
            LIMIT 1
            """,
            (business_id, api_key, user_id)
        )
        
        result = cursor.fetchone()
        if not result:
            log.error("No conversations found for the given business_id and api_key")
            return
            
        conversation_id = result['conversation_id']
        log.info(f"Found conversation_id: {conversation_id}")
        
        # Test conversation history with different options
        log.info("\nTesting conversation history with default options:")
        history = provide_conversation_history(conn, conversation_id)
        print(history)
        
        log.info("\nTesting conversation history with timestamps:")
        history_with_timestamps = provide_conversation_history(
            conn, 
            conversation_id, 
            include_timestamps=True
        )
        print(history_with_timestamps)
        
        log.info("\nTesting conversation history with limited messages:")
        history_limited = provide_conversation_history(
            conn, 
            conversation_id, 
            max_messages=5
        )
        print(history_limited)
        
    except Exception as e:
        log.error(f"Error during test: {str(e)}", exc_info=True)
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test conversation history for a user.")
    parser.add_argument('--user_id', type=str, help='User ID to test (optional)')
    args = parser.parse_args()
    test_conversation_history(user_id=args.user_id) 

================================================================================
File: history_analyzer.py
Path: .\archive\history_analyzer.py
Size: 2900
Modified: 2025-05-04T20:30:26.544550
Created: 2025-05-04T20:30:24.968227
Hash: 0cee5d90a7d81b5e05aae893c39949b44dc640878937a5ae228aa22245a218de
Lines: 90
================================================================================
import psycopg2
from psycopg2.pool import SimpleConnectionPool
import os
from dotenv import load_dotenv
import openai
import json

load_dotenv()

# Database connection
pool = SimpleConnectionPool(1, 20,
    dbname=os.environ.get("DB_NAME"),
    user=os.environ.get("DB_USER"),
    password=os.environ.get("DB_PASSWORD"),
    host=os.environ.get("DB_HOST"),
    port=os.environ.get("DB_PORT")
)

# OpenAI setup
openai.api_key = os.environ.get("OPENAI_API_KEY")

def fetch_chat_history(business_id, limit=100):
    conn = pool.getconn()
    try:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT user_message, agent_response, extracted_entities, current_stage
                FROM chat_history
                WHERE business_id = %s
                ORDER BY timestamp DESC
                LIMIT %s;
            """, (business_id, limit))
            return cur.fetchall()
    finally:
        pool.putconn(conn)

def fetch_available_stages(business_id):
    conn = pool.getconn()
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT name FROM stages WHERE business_id = %s;", (business_id,))
            return [row[0] for row in cur.fetchall()]
    finally:
        pool.putconn(conn)

def fetch_available_templates(business_id):
    conn = pool.getconn()
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT name, fields FROM templates WHERE business_id = %s;", (business_id,))
            return [{"name": row[0], "fields": row[1]} for row in cur.fetchall()]
    finally:
        pool.putconn(conn)

def analyze_history_for_suggestions(business_id):
    history = fetch_chat_history(business_id)
    stages = fetch_available_stages(business_id)
    templates = fetch_available_templates(business_id)
    
    with open("suggestion_template.txt", "r") as f:
        prompt_template = f.read()
    
    history_str = json.dumps([{
        "user_message": row[0],
        "agent_response": row[1],
        "entities": row[2],
        "stage": row[3]
    } for row in history], indent=2)
    
    prompt = prompt_template.replace("{{user_messages}}", history_str)\
                           .replace("{{available_stages}}", json.dumps(stages))\
                           .replace("{{available_templates}}", json.dumps(templates))
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are an expert in conversational AI design."},
            {"role": "user", "content": prompt}
        ]
    )
    
    return json.loads(response.choices[0].message.content)

def suggest_stages_and_templates(business_id):
    suggestions = analyze_history_for_suggestions(business_id)
    return suggestions

if __name__ == "__main__":
    suggestions = suggest_stages_and_templates("example_business_id")
    print(json.dumps(suggestions, indent=2))

================================================================================
File: add_template_type.py
Path: .\backend\add_template_type.py
Size: 1303
Modified: 2025-05-02T10:52:19.644892
Created: 2025-04-06T22:20:40.690530
Hash: c2fe119ed2af1c3272334953f124cce3966b3215c6d4b617e0e5f6e4d412f732
Lines: 45
================================================================================
import psycopg2
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Database configuration
db_config = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

# Connect to the database
conn = psycopg2.connect(**db_config)
conn.autocommit = True
cursor = conn.cursor()

try:
    # Check if column exists
    cursor.execute("""
        SELECT column_name 
        FROM information_schema.columns 
        WHERE table_name = 'prompt_templates' AND column_name = 'template_type'
    """)
    
    if cursor.fetchone():
        print("Column 'template_type' already exists in prompt_templates table")
    else:
        # Add the column
        cursor.execute("""
            ALTER TABLE prompt_templates 
            ADD COLUMN template_type VARCHAR(50) DEFAULT 'stage_selection'
        """)
        print("Successfully added 'template_type' column to prompt_templates table")
        
    print("Migration completed successfully")
except Exception as e:
    print(f"Error: {str(e)}")
finally:
    cursor.close()
    conn.close()

================================================================================
File: add_template_type_column.py
Path: .\backend\add_template_type_column.py
Size: 2424
Modified: 2025-05-02T10:52:19.644892
Created: 2025-04-06T22:03:05.028274
Hash: b0e4fef846a4c3f6ab00bc4f015f3b5694d01ce6361ecf2a426c5f8168ab657f
Lines: 74
================================================================================
#!/usr/bin/env python
"""
This script adds a template_type column to the prompt_templates table if it doesn't exist.
Run this script to update your database schema.
"""

import os
import logging
import sys

# Ensure the backend directory is in the path
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)

from db import get_db_connection, release_db_connection

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def add_template_type_column():
    """Add template_type column to prompt_templates table if it doesn't exist."""
    conn = get_db_connection()
    if not conn:
        logger.error("Failed to connect to database")
        return False
    
    try:
        cursor = conn.cursor()
        
        # Check if the column already exists
        cursor.execute("""
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'prompt_templates' AND column_name = 'template_type'
        """)
        
        if cursor.fetchone():
            logger.info("Column 'template_type' already exists in prompt_templates table")
            return True
        
        # Add the column
        cursor.execute("""
            ALTER TABLE prompt_templates 
            ADD COLUMN template_type VARCHAR(50) DEFAULT 'stage_selection'
        """)
        
        # Update existing templates to have a default type
        cursor.execute("""
            UPDATE prompt_templates
            SET template_type = 'stage_selection'
            WHERE template_type IS NULL
        """)
        
        conn.commit()
        logger.info("Successfully added 'template_type' column to prompt_templates table")
        return True
        
    except Exception as e:
        conn.rollback()
        logger.error(f"Error adding template_type column: {str(e)}", exc_info=True)
        return False
    finally:
        release_db_connection(conn)

if __name__ == "__main__":
    logger.info("Starting database migration to add template_type column")
    success = add_template_type_column()
    if success:
        logger.info("Migration completed successfully")
    else:
        logger.error("Migration failed")
        sys.exit(1)

================================================================================
File: app.py
Path: .\backend\app.py
Size: 21722
Modified: 2025-05-10T18:41:52.871584
Created: 2025-03-30T15:12:25.167734
Hash: 09037b1f41a2acf72ead9345e1a594436e154a5792ed4860f764480fea87549d
Lines: 513
================================================================================
#!/usr/bin/env python
# app.py - Main Flask application entry point

import sys
import os
import secrets
import logging
from flask import Flask, jsonify, request, Response, make_response
from flask_cors import CORS
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from logging.handlers import RotatingFileHandler
from datetime import datetime, timedelta
import json
import uuid

# Ensure the backend directory is in the path
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.append(parent_dir)
if current_dir not in sys.path:
    sys.path.append(current_dir)

# Load environment variables from backend/.env
from dotenv import load_dotenv
env_path = os.path.join(current_dir, '.env')
load_dotenv(env_path)

# Import modules from our app
from backend.auth import require_api_key, require_auth
from backend.db import (
    get_db_connection,
    release_db_connection,
    execute_query,
    CONNECTION_POOL,
    initialize_connection_pool
)
from backend.config import Config
from backend.messenger import setup_messenger_routes
from backend.whatsapp import setup_whatsapp_routes
from backend.message_processing.ai_control_service import ai_control_service  # Import AI control service

# Routes imports
from backend.routes.message_handling import bp as message_bp
from backend.routes.routing import bp as routing_bp
from backend.routes.templates import templates_bp
from backend.routes.stages import stages_bp
from backend.routes.template_management import template_admin_bp
from backend.routes.conversation_management import conversation_bp
from backend.routes.businesses import bp as businesses_bp
from backend.routes.auth_bp import bp as auth_bp
from backend.routes.configuration import bp as config_bp
from backend.routes.agents import agents_bp
from backend.routes.users import bp as users_bp
from backend.routes.template_variables import template_variables_bp
from backend.routes.llm import llm_bp
from backend.routes.data_extraction import data_extraction_bp
from backend.routes.privacy import privacy_bp
from backend.routes.template_test import bp as template_test_bp
from backend.routes.message_simulator import bp as message_simulator_bp
from backend.routes.user_stats import bp as user_stats_bp

# Import here to avoid circular imports
from create_default_stage import create_default_stage

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),  # Log to console
    ]
)
log = logging.getLogger(__name__)
log.info("--- Logging configured (basicConfig) ---")

# Function to create and initialize the default stage
def initialize_default_stage():
    """Create default stage if one doesn't exist."""
    try:
        log.info("Creating default stage if needed...")
        default_stage_id = create_default_stage()
        log.info(f"Default stage ID: {default_stage_id}")
        return default_stage_id
    except Exception as e:
        log.error(f"Error creating default stage: {str(e)}", exc_info=True)
        return None

# Create the Flask app
def create_app(test_config=None):
    # Create and configure the app
    app = Flask(__name__)
    
    # Configure CORS
    CORS(app, resources={
        r"/api/*": {
            "origins": ["http://localhost:3000"],
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
            "allow_headers": ["Content-Type", "Authorization", "X-API-Key", "businessapikey", "Accept", "Origin"],
            "expose_headers": ["Content-Type", "Authorization", "businessapikey", "X-API-Key"],
            "supports_credentials": True,
            "max_age": 3600  # Cache preflight requests for 1 hour
        }
    })
    
    # Configure schema validation
    app.config['SCHEMAS'] = {}
    
    # Configure API key
    app.config['ICMP_API_KEY'] = Config.ICMP_API_KEY
    log.info(f"ICMP_API_KEY loaded: {app.config['ICMP_API_KEY']}")
    
    # Configure limiter
    limiter = Limiter(
        lambda: get_remote_address(),
        app=app,
        default_limits=["100 per minute"],
        storage_uri="memory://",
    )
    
    # Disable limiter in certain environments
    if os.environ.get('DISABLE_RATE_LIMITS') or app.config.get('TESTING'):
        limiter.enabled = False
    
    # --- Request Logging ---
    log.info("--- Registering @app.before_request hook ---")
    @app.before_request
    def log_request_info():
        """Log basic info about each request."""
        log.info("!!! Request received: %s %s from %s !!!", 
                  request.method, request.path, request.remote_addr)
        # Log more detailed info at DEBUG level
        log.info({
            'method': request.method,
            'path': request.path,
            'remote_addr': request.remote_addr
        })
        
    log.info("--- Registering @app.after_request hook ---")
    @app.after_request
    def log_response_info(response):
        """Log info about the response to each request."""
        log.info("!!! Request finished: %s, Status: %s !!!", 
                  request.path, response.status_code)
        return response
    
    # --- Route Handlers ---
    @app.route('/')
    def home():
        """Home route."""
        return jsonify({
            "message": "ICMP Events API is running",
            "version": "1.0.0",
            "status": "ok"
        })
    
    @app.route('/ping')
    def ping():
        """Health check route."""
        log.info("--- Inside /ping route handler ---")
        return jsonify({
            "response": "pong",
            "timestamp": datetime.now().isoformat()
        })

    @app.route('/health', methods=['GET'])
    def health():
        """Health check route with more detailed status."""
        conn = None
        try:
            conn = get_db_connection()
            is_db_connected = conn is not None
            
            return jsonify({
                "status": "healthy",
                "date": datetime.now().isoformat(),
                "database": "connected" if is_db_connected else "disconnected",
                "schemas_loaded": app.config.get('SCHEMAS') is not None
            })
        except Exception as e:
            log.error(f"Health check error: {str(e)}")
            return jsonify({
                "status": "unhealthy",
                "date": datetime.now().isoformat(),
                "database": "error",
                "error": str(e)
            }), 500
        finally:
            if conn:
                release_db_connection(conn)

    @app.route('/api/admin-check', methods=['GET'])
    @require_api_key
    def admin_check():
        """Simple endpoint to verify the Admin Master API Key."""
        log.info("Admin API Key validation successful via /api/admin-check")
        return jsonify({"message": "Admin key is valid"}), 200

    @app.route('/api/save-config', methods=['POST', 'OPTIONS'])
    def save_config():
        if request.method == 'OPTIONS':
            return '', 204  # Return a 204 No Content response for preflight requests
        try:
            data = request.get_json()
            log.info(f"Received data: {data}")
            # Validate required fields
            required_fields = ['userId', 'businessId', 'businessApiKey']
            missing_fields = [field for field in required_fields if field not in data]
            if missing_fields:
                log.error(f"Missing required fields: {missing_fields}")
                return jsonify({
                    'error': 'Missing required fields',
                    'missing_fields': missing_fields
                }), 400
            # Extract fields and trim whitespace
            user_id = data.get('userId', '').strip()
            business_id = data.get('businessId', '').strip()
            business_api_key = data.get('businessApiKey', '').strip()
            # Validate fields
            if not all([user_id, business_id, business_api_key]):
                log.error("Empty or invalid fields")
                return jsonify({
                    'error': 'Empty or invalid fields',
                    'details': {
                        'userId': bool(user_id),
                        'businessId': bool(business_id),
                        'businessApiKey': bool(business_api_key)
                    }
                }), 400
            # Save to database
            conn = get_db_connection()
            try:
                cursor = conn.cursor()
                # Check if user exists
                cursor.execute(
                    """
                    SELECT user_id
                    FROM users
                    WHERE user_id = %s;
                    """, (user_id,)
                )
                user_exists = cursor.fetchone() is not None
                if not user_exists:
                    # Create a minimal user record if it doesn't exist
                    cursor.execute(
                        """
                        INSERT INTO users (user_id, first_name, last_name, email)
                        VALUES (%s, %s, %s, %s);
                        """, (user_id, 'User', 'User', f"{user_id}@example.com")
                    )
                # Check if business exists
                cursor.execute(
                    """
                    SELECT business_id
                    FROM businesses
                    WHERE business_id = %s;
                    """, (business_id,)
                )
                business_exists = cursor.fetchone() is not None
                if not business_exists:
                    # Create a new business with the user as owner
                    cursor.execute(
                        """
                        INSERT INTO businesses (business_id, api_key, owner_id, business_name)
                        VALUES (%s, %s, %s, %s);
                        """, (business_id, business_api_key, user_id, f"Business {business_id[:8]}")
                    )
                else:
                    # Update the business's API key and owner_id
                    cursor.execute(
                        """
                        UPDATE businesses
                        SET api_key = %s, owner_id = %s
                        WHERE business_id = %s;
                        """, (business_api_key, user_id, business_id)
                    )
                conn.commit()
                log.info(f"Successfully saved configuration for user {user_id} and business {business_id}")
                # Set the businessApiKey cookie
                response = jsonify({
                    'message': 'Configuration saved successfully',
                    'user_id': user_id,
                    'business_id': business_id,
                    'success': True
                })
                # Set the cookie with HttpOnly flag for security
                response.set_cookie(
                    'businessApiKey',
                    business_api_key,
                    httponly=True,
                    secure=False,  # Set to True in production with HTTPS
                    samesite='Lax',
                    max_age=86400  # 24 hours
                )
                return response
            finally:
                if conn:
                    release_db_connection(conn)
        except Exception as e:
            log.error(f"Error in save_config: {str(e)}", exc_info=True)
            return jsonify({'error': 'Server error', 'details': str(e)}), 500

    @app.route('/api/lookup-owner', methods=['POST', 'OPTIONS'])
    def lookup_owner():
        """Look up the owner ID for a business."""
        # Handle CORS preflight requests
        if request.method == 'OPTIONS':
            response = jsonify({'success': True})
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey')
            response.headers.add('Access-Control-Allow-Methods', 'POST,OPTIONS')
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            return response
            
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'}), 400
        
        # Extract values first
        business_id_raw = data.get('businessId')
        business_api_key_raw = data.get('businessApiKey')
        
        # Convert to string and strip only if the values exist
        business_id = business_id_raw.strip() if isinstance(business_id_raw, str) else business_id_raw
        business_api_key = business_api_key_raw.strip() if isinstance(business_api_key_raw, str) else business_api_key_raw

        # Check for missing parameters
        if not all([business_id, business_api_key]):
            logging.error("Missing parameters in lookup_owner")
            return jsonify({'success': False, 'error': 'Missing parameters'}), 400

        # Verify credentials and lookup owner
        conn = get_db_connection()
        try:
            cursor = conn.cursor()
            # Validate business credentials and get owner ID
            cursor.execute(
                """
                SELECT owner_id
                FROM businesses
                WHERE business_id = %s AND api_key = %s;
                """, (business_id, business_api_key)
            )
            result = cursor.fetchone()

            if not result:
                logging.error(f"Invalid business credentials in lookup_owner: business_id={business_id}")
                return jsonify({'success': False, 'error': 'Invalid business credentials'}), 401

            owner_id = result[0]
            response = jsonify({
                'success': True,
                'owner_id': owner_id,
                'business_id': business_id
            })
            
            # Set CORS headers on the response
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            
            return response

        except Exception as e:
            logging.error(f"Error in lookup_owner: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500
        finally:
            if conn:
                release_db_connection(conn)

    @app.route('/api/verify-owner', methods=['POST', 'OPTIONS'])
    def verify_owner():
        """Verify if a user is the owner of a business."""
        # Handle CORS preflight requests
        if request.method == 'OPTIONS':
            response = jsonify({'success': True})
            # When allowing credentials, we can't use wildcard origin
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey')
            response.headers.add('Access-Control-Allow-Methods', 'POST,OPTIONS')
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            return response
            
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'}), 400
        
        # Extract values first
        user_id_raw = data.get('userId')
        business_id_raw = data.get('businessId')
        business_api_key_raw = data.get('businessApiKey')
        
        # Convert to string and strip only if the values exist
        user_id = user_id_raw.strip() if isinstance(user_id_raw, str) else user_id_raw
        business_id = business_id_raw.strip() if isinstance(business_id_raw, str) else business_id_raw
        business_api_key = business_api_key_raw.strip() if isinstance(business_api_key_raw, str) else business_api_key_raw

        # Check for missing parameters
        if not all([user_id, business_id, business_api_key]):
            logging.error("Missing parameters in verify_owner")
            return jsonify({'success': False, 'error': 'Missing parameters'}), 400

        # Check for invalid types
        if not all(isinstance(value, str) for value in [user_id, business_id, business_api_key]):
            logging.error("Invalid parameter types in verify_owner")
            return jsonify({'success': False, 'error': 'Invalid parameter types'}), 400

        # Verify owner status
        conn = get_db_connection()
        try:
            cursor = conn.cursor()
            # Validate business credentials and check if user is the owner
            cursor.execute(
                """
                SELECT 1
                FROM businesses
                WHERE business_id = %s AND api_key = %s AND owner_id = %s;
                """, (business_id, business_api_key, user_id)
            )
            is_owner = cursor.fetchone() is not None

            if not is_owner:
                # Check if credentials are valid but user is not the owner
                cursor.execute(
                    """
                    SELECT 1
                    FROM businesses
                    WHERE business_id = %s AND api_key = %s;
                    """, (business_id, business_api_key)
                )
                valid_credentials = cursor.fetchone() is not None
                
                if valid_credentials:
                    logging.error(f"User {user_id} attempted to access owner features but is not the owner of business {business_id}")
                    return jsonify({'success': False, 'error': 'Access denied: Not the business owner'}), 403
                else:
                    logging.error(f"Invalid business credentials in verify_owner: business_id={business_id}")
                    return jsonify({'success': False, 'error': 'Invalid business credentials'}), 401

            response = jsonify({'success': True})
            # Set CORS headers on the response
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            
            # Set cookies with proper security attributes
            # Use secure=False for HTTP development
            response.set_cookie(
                'businessApiKey',
                str(business_api_key),
                httponly=True,
                secure=False,  # Set to False for HTTP development
                samesite='Lax',  # Changed to Lax for better compatibility
                max_age=3600  # 1 hour expiry
            )

            return response

        except Exception as e:
            logging.error(f"Error in verify_owner: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500
        finally:
            if conn:
                release_db_connection(conn)

    # Register blueprints
    log.info("--- Registering blueprints ---")
    app.register_blueprint(message_bp, url_prefix='/api/messages')
    app.register_blueprint(routing_bp, url_prefix='/api/routing')
    app.register_blueprint(templates_bp, url_prefix='/api/templates')
    app.register_blueprint(stages_bp, url_prefix='/api/stages')
    app.register_blueprint(template_admin_bp, url_prefix='/api/template-admin')
    app.register_blueprint(conversation_bp, url_prefix='/api/conversations')
    app.register_blueprint(businesses_bp, url_prefix='/api/businesses')
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(config_bp, url_prefix='/api/config')
    app.register_blueprint(agents_bp, url_prefix='/api/agents')
    app.register_blueprint(users_bp, url_prefix='/api/users')
    app.register_blueprint(template_variables_bp, url_prefix='/api/template-variables')
    app.register_blueprint(llm_bp, url_prefix='/api/llm')
    app.register_blueprint(data_extraction_bp, url_prefix='/api/data-extraction')
    app.register_blueprint(privacy_bp, url_prefix='/api/privacy')
    app.register_blueprint(template_test_bp, url_prefix='/api/template-test')
    app.register_blueprint(message_simulator_bp, url_prefix='/api/simulate')
    app.register_blueprint(user_stats_bp)
    
    # Setup Facebook Messenger routes
    setup_messenger_routes(app)
    
    # Setup WhatsApp routes
    setup_whatsapp_routes(app)
    
    # Initialize the default stage
    with app.app_context():
        initialize_default_stage()
    
    # Initialize the database connection pool if not already initialized
    if not CONNECTION_POOL:
        log.info("--- Initializing Database Connection Pool ---")
        try:
            initialize_connection_pool()
            log.info("Database connection pool initialized successfully.")
        except Exception as e:
            log.error(f"Error initializing database connection pool: {str(e)}", exc_info=True)

    log.info("--- Flask App Initialization Complete ---")
    return app

# Create the app
app = create_app()

if __name__ == '__main__':
    # Run the app
    app.run(host='0.0.0.0', debug=True)

================================================================================
File: auth.py
Path: .\backend\auth.py
Size: 7875
Modified: 2025-05-09T23:22:18.478836
Created: 2025-03-30T15:12:25.177570
Hash: 5d591dd5de911d599dbbe5a13ca608dfb1ae525caff5060c1b84a474b21df214
Lines: 211
================================================================================
"""
Authentication and authorization module.

This module provides functionality for:
- API key validation
- User authentication
- Authorization checks
"""

import logging
import functools
from flask import jsonify, request, current_app, g, make_response
# Remove check_password_hash if no longer used for user passwords
# from werkzeug.security import check_password_hash
from backend.db import get_db_connection, release_db_connection
from backend.utils import is_valid_uuid
from functools import wraps
import uuid
from typing import Optional, Callable, Any

log = logging.getLogger(__name__)

def validate_business_key(key: str) -> bool:
    """Validate a business API key."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1 FROM businesses WHERE api_key = %s", (key,))
        return cursor.fetchone() is not None
    finally:
        if conn:
            release_db_connection(conn)

def validate_internal_key(key: str) -> bool:
    """Validate an internal API key."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1 FROM businesses WHERE internal_api_key = %s", (key,))
        return cursor.fetchone() is not None
    finally:
        if conn:
            release_db_connection(conn)

def require_auth(f):
    """
    Decorator to require either admin API key or business API key for authentication.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.method == 'OPTIONS':
            return f(*args, **kwargs)

        # Check for admin API key first
        config_api_key = current_app.config.get("ICMP_API_KEY")
        if config_api_key:
            auth_header = request.headers.get("Authorization")
            if auth_header and auth_header.startswith("Bearer "):
                provided_key = auth_header.split(" ", 1)[1]
                if provided_key == config_api_key:
                    log.debug("Admin API key validated successfully.")
                    return f(*args, **kwargs)

        # If not admin, check for business API key
        business_api_key = request.cookies.get('businessApiKey')
        if not business_api_key:
            log.warning("Unauthorized access attempt - Missing business API key.")
            return jsonify({
                "error_code": "UNAUTHORIZED",
                "message": "Missing business API key"
            }), 401

        # Verify business API key
        conn = get_db_connection()
        try:
            cursor = conn.cursor()
            cursor.execute(
                """
                SELECT business_id 
                FROM businesses 
                WHERE api_key = %s
                """,
                (business_api_key,)
            )
            result = cursor.fetchone()
            
            if not result:
                log.warning("Unauthorized access attempt - Invalid business API key.")
                return jsonify({
                    "error_code": "UNAUTHORIZED",
                    "message": "Invalid business API key"
                }), 401
                
            # Store business_id in request context for later use
            g.business_id = result[0]
            log.debug(f"Business API key validated successfully for business {g.business_id}")
            return f(*args, **kwargs)
            
        except Exception as e:
            log.error(f"Error verifying business API key: {str(e)}")
            return jsonify({
                "error_code": "SERVER_ERROR",
                "message": "Error verifying credentials"
            }), 500
        finally:
            if conn:
                release_db_connection(conn)

    return decorated_function

# Keep for Admin/Master Key tasks
def require_api_key(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.method == 'OPTIONS':
            return f(*args, **kwargs)

        config_api_key = current_app.config.get("ICMP_API_KEY")
        if not config_api_key:
            log.error("ICMP_API_KEY not configured in the application.")
            return jsonify({
                "error_code": "CONFIG_ERROR",
                "message": "Server configuration error"
            }), 500

        provided_key = None
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            provided_key = auth_header.split(" ", 1)[1]
            log.debug("Found Bearer token in Authorization header for master key check.")
        # Remove cookie check unless specifically needed for master key
        # elif 'icmpApiKey' in request.cookies:
        #     provided_key = request.cookies.get('icmpApiKey')
        #     log.debug("Found icmpApiKey in cookies.")

        if not provided_key or provided_key != config_api_key:
            log.warning("Unauthorized access attempt - Invalid or missing Master API key.")
            return jsonify({
                "error_code": "UNAUTHORIZED",
                "message": "Invalid or missing Master API key"
            }), 401
        
        log.debug("Master API key validated successfully.")
        # Optionally attach admin context if needed
        # g.is_admin = True 
        return f(*args, **kwargs)

    return decorated_function

# New decorator for internal keys passed by handlers
def require_internal_key(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.method == 'OPTIONS':
            return f(*args, **kwargs)

        provided_key = None
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            provided_key = auth_header.split(" ", 1)[1]
        
        if not provided_key:
            log.warning("Missing Authorization Bearer token for internal key.")
            return jsonify({
                "error_code": "UNAUTHORIZED",
                "message": "Authorization token required"
            }), 401

        conn = None
        business = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            # Fetch business details based on the unique internal key
            # Ensure internal_api_key column exists and is indexed for performance
            cursor.execute("""
                SELECT business_id, business_name FROM businesses 
                WHERE internal_api_key = %s
            """, (provided_key,))
            business_row = cursor.fetchone()
            
            if not business_row:
                log.warning(f"Invalid internal API key provided.")
                return jsonify({
                    "error_code": "UNAUTHORIZED",
                    "message": "Invalid internal API key"
                }), 401
            
            # Attach business context to the request global `g`
            g.business_id = str(business_row[0])
            g.business_name = business_row[1]
            log.info(f"Internal API key validated successfully for business_id: {g.business_id}")
            return f(*args, **kwargs)
            
        except Exception as e:
            log.error(f"Database error during internal API key validation: {str(e)}", exc_info=True)
            return jsonify({
                "error_code": "SERVER_ERROR",
                "message": "Failed to validate credentials"
            }), 500
        finally:
            if conn:
                release_db_connection(conn)

    return decorated_function

# Remove the old require_business_api_key decorator entirely
# def require_business_api_key(f):
#    ...

================================================================================
File: check_cors.py
Path: .\backend\check_cors.py
Size: 2413
Modified: 2025-05-02T10:52:19.669519
Created: 2025-04-16T15:41:35.558091
Hash: 2a2b2056130dfddddd0f359f3bab9a2ad830f3d3063d7dd65cf602210d854075
Lines: 72
================================================================================
#!/usr/bin/env python
"""
Script to check CORS headers on API endpoints.
"""

import requests
import json
import sys
import logging

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

def check_cors(base_url='http://127.0.0.1:5000'):
    """Check CORS headers for various endpoints"""
    
    # Define endpoints to test
    endpoints = [
        '/api/message',
        '/api/message/logs/recent',
        '/health',
        '/ping'
    ]
    
    # Test each endpoint with an OPTIONS request
    for endpoint in endpoints:
        url = f"{base_url}{endpoint}"
        log.info(f"Testing OPTIONS request for {url}")
        
        try:
            # Use OPTIONS method for preflight request
            response = requests.options(
                url,
                headers={
                    'Origin': 'http://localhost:3000',
                    'Access-Control-Request-Method': 'GET',
                    'Access-Control-Request-Headers': 'Content-Type, Authorization'
                }
            )
            
            # Check response status code
            log.info(f"Status code: {response.status_code}")
            
            # Print headers
            log.info("Response headers:")
            for key, value in response.headers.items():
                if key.lower().startswith('access-control'):
                    log.info(f"  {key}: {value}")
            
            # Check if key CORS headers are present
            cors_headers = [
                'Access-Control-Allow-Origin',
                'Access-Control-Allow-Methods',
                'Access-Control-Allow-Headers'
            ]
            
            missing_headers = [h for h in cors_headers if h not in response.headers]
            if missing_headers:
                log.error(f"Missing CORS headers: {missing_headers}")
            else:
                log.info(f"All required CORS headers present for {endpoint}")
                
            log.info("-" * 80)
            
        except requests.exceptions.RequestException as e:
            log.error(f"Error testing {url}: {e}")
            log.info("-" * 80)

if __name__ == "__main__":
    # Use custom base URL if provided as command line argument
    base_url = sys.argv[1] if len(sys.argv) > 1 else 'http://127.0.0.1:5000'
    check_cors(base_url)

================================================================================
File: check_db.py
Path: .\backend\check_db.py
Size: 3174
Modified: 2025-05-02T10:52:19.677759
Created: 2025-04-03T19:57:51.917796
Hash: 3ad0270292d0efedbef9b94aa207ede6c2a363efbe0c7992353d1661d0bffc4b
Lines: 81
================================================================================
from db import get_db_connection, release_db_connection
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def check_database():
    conn = None
    try:
        logger.info("Connecting to database...")
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Check the stages table structure
        logger.info("Checking stages table structure...")
        cursor.execute("""
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns
            WHERE table_name = 'stages'
            ORDER BY ordinal_position;
        """)
        
        print("\n=== STAGES TABLE STRUCTURE ===")
        rows = cursor.fetchall()
        for row in rows:
            print(f"Column: {row[0]}, Type: {row[1]}, Nullable: {row[2]}")
        
        # Check the default_templates table structure
        logger.info("Checking default_templates table structure...")
        cursor.execute("""
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns
            WHERE table_name = 'default_templates'
            ORDER BY ordinal_position;
        """)
        
        print("\n=== DEFAULT_TEMPLATES TABLE STRUCTURE ===")
        rows = cursor.fetchall()
        for row in rows:
            print(f"Column: {row[0]}, Type: {row[1]}, Nullable: {row[2]}")
        
        # Count the number of records in stages
        logger.info("Counting stages records...")
        cursor.execute("SELECT COUNT(*) FROM stages;")
        count = cursor.fetchone()[0]
        print(f"\nNumber of records in stages: {count}")
        
        # Count the number of records in default_templates
        logger.info("Counting default_templates records...")
        cursor.execute("SELECT COUNT(*) FROM default_templates;")
        count = cursor.fetchone()[0]
        print(f"Number of records in default_templates: {count}")
        
        # Try to diagnose the 500 error
        print("\n=== CHECKING FOR NULL TEMPLATE IDS IN STAGES ===")
        cursor.execute("""
            SELECT stage_id, 
                   stage_selection_template_id IS NULL AS selection_null, 
                   data_extraction_template_id IS NULL AS extraction_null, 
                   response_generation_template_id IS NULL AS response_null
            FROM stages 
            WHERE stage_selection_template_id IS NULL 
               OR data_extraction_template_id IS NULL 
               OR response_generation_template_id IS NULL;
        """)
        rows = cursor.fetchall()
        if rows:
            print("Found stages with NULL template IDs:")
            for row in rows:
                print(f"Stage ID: {row[0]}, Selection null: {row[1]}, Extraction null: {row[2]}, Response null: {row[3]}")
        else:
            print("No stages with NULL template IDs")
        
    except Exception as e:
        logger.error(f"Error checking database: {e}")
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    check_database()

================================================================================
File: check_logs.py
Path: .\backend\check_logs.py
Size: 3262
Modified: 2025-05-02T10:52:19.686619
Created: 2025-04-03T20:55:37.439957
Hash: 624a3b93d9923d4cd4a3afe2d2fcf9633d2dc24cc21130c8d92ebe24ef63a08d
Lines: 80
================================================================================
import os
import re
from datetime import datetime, timedelta

def main():
    """Search log files for template update entries in the last 24 hours"""
    # Default log locations
    log_paths = [
        'app.log',
        '../app.log',
        'logs/app.log',
        '../logs/app.log',
    ]
    
    # Try to find log files
    valid_log_files = [path for path in log_paths if os.path.exists(path)]
    
    if not valid_log_files:
        print("No log files found. Please specify the location of your log file.")
        log_path = input("Enter log file path: ")
        if os.path.exists(log_path):
            valid_log_files = [log_path]
        else:
            print(f"Log file not found at {log_path}")
            return
    
    # Time threshold - 24 hours ago
    time_threshold = datetime.now() - timedelta(hours=24)
    
    # Template update patterns
    update_patterns = [
        r"Received update for stage .+ with data: \{.*\}",
        r"Template fields in request: \[.*\]",
        r"Processing .+ -> .+ with template_id: .+",
        r"Updating template .+ with text: .+",
        r"Updated template .+ in .+ for stage .+, rows affected: \d+"
    ]
    
    print(f"Searching for template updates in logs...")
    
    for log_path in valid_log_files:
        print(f"\nChecking log file: {log_path}")
        try:
            with open(log_path, 'r') as f:
                log_content = f.readlines()
                
            # Extract relevant log entries
            update_entries = []
            for line in log_content:
                if any(re.search(pattern, line) for pattern in update_patterns):
                    # Try to extract timestamp
                    timestamp_match = re.search(r'^\[([^\]]+)\]', line)
                    if timestamp_match:
                        try:
                            # Parse timestamp, assuming ISO format
                            timestamp_str = timestamp_match.group(1)
                            timestamp = datetime.fromisoformat(timestamp_str)
                            
                            # Check if within time threshold
                            if timestamp >= time_threshold:
                                update_entries.append(line.strip())
                        except ValueError:
                            # If timestamp parsing fails, include the line anyway
                            update_entries.append(line.strip())
                    else:
                        # If no timestamp found, include the line anyway
                        update_entries.append(line.strip())
            
            if update_entries:
                print(f"Found {len(update_entries)} relevant log entries:")
                for i, entry in enumerate(update_entries[-20:], 1):  # Show last 20 entries
                    print(f"{i}. {entry}")
                print(f"\nShowing last 20 of {len(update_entries)} entries. Full logs in {log_path}")
            else:
                print("No template update log entries found.")
        except Exception as e:
            print(f"Error reading log file {log_path}: {str(e)}")
    
if __name__ == "__main__":
    main()

================================================================================
File: check_prompt_templates.py
Path: .\backend\check_prompt_templates.py
Size: 6446
Modified: 2025-05-02T10:52:19.686619
Created: 2025-04-03T20:43:16.310067
Hash: 275687f8c4f21bd3935b30cc9b44720b7ee5c5ff52669061c34becc4913740b4
Lines: 143
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def main():
    try:
        print("Connecting to PostgreSQL database...")
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor(cursor_factory=DictCursor)
        
        # Check prompt_templates table structure
        print("\nChecking prompt_templates table structure:")
        cursor.execute("SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'prompt_templates';")
        columns = cursor.fetchall()
        for col in columns:
            print(f"- {col[0]}: {col[1]}")
        
        # Count templates
        cursor.execute("SELECT COUNT(*) FROM prompt_templates;")
        count = cursor.fetchone()[0]
        print(f"\nTotal templates in prompt_templates: {count}")
        
        # Check for empty template text
        cursor.execute("SELECT COUNT(*) FROM prompt_templates WHERE template_text IS NULL OR template_text = '';")
        empty_count = cursor.fetchone()[0]
        print(f"Empty templates: {empty_count}")
        
        # Show some template records
        if count > 0:
            print("\nTemplate records (max 10):")
            cursor.execute("SELECT template_id, template_name, template_text FROM prompt_templates LIMIT 10;")
            templates = cursor.fetchall()
            for template in templates:
                print(f"ID: {template[0]}")
                print(f"Name: {template[1]}")
                if template[2]:
                    print(f"Text preview: {template[2][:50]}{'...' if len(template[2]) > 50 else ''}")
                else:
                    print("Text: None or empty")
                print("-" * 50)
        
        # Check stages with template references
        print("\nChecking stages with template references:")
        cursor.execute("""
            SELECT stage_id, stage_name, 
                   stage_selection_template_id, data_extraction_template_id, response_generation_template_id,
                   selection_template_id, extraction_template_id, response_template_id
            FROM stages
            LIMIT 5;
        """)
        stages = cursor.fetchall()
        for stage in stages:
            print(f"Stage ID: {stage['stage_id']}")
            print(f"Name: {stage['stage_name']}")
            print(f"New template IDs:")
            print(f"  - Selection: {stage['stage_selection_template_id']}")
            print(f"  - Extraction: {stage['data_extraction_template_id']}")
            print(f"  - Response: {stage['response_generation_template_id']}")
            print(f"Old template IDs:")
            print(f"  - Selection: {stage['selection_template_id']}")
            print(f"  - Extraction: {stage['extraction_template_id']}")
            print(f"  - Response: {stage['response_template_id']}")
            
            # Check template details
            template_ids = []
            if stage['stage_selection_template_id']:
                template_ids.append(stage['stage_selection_template_id'])
            elif stage['selection_template_id']:
                template_ids.append(stage['selection_template_id'])
                
            if stage['data_extraction_template_id']:
                template_ids.append(stage['data_extraction_template_id'])
            elif stage['extraction_template_id']:
                template_ids.append(stage['extraction_template_id'])
                
            if stage['response_generation_template_id']:
                template_ids.append(stage['response_generation_template_id'])
            elif stage['response_template_id']:
                template_ids.append(stage['response_template_id'])
            
            if template_ids:
                print("\nTemplate details for this stage:")
                placeholders = ', '.join(['%s'] * len(template_ids))
                try:
                    cursor.execute(f"SELECT template_id, template_name, template_text FROM prompt_templates WHERE template_id IN ({placeholders})", template_ids)
                    stage_templates = cursor.fetchall()
                    
                    for template in stage_templates:
                        print(f"  Template ID: {template[0]}")
                        print(f"  Name: {template[1]}")
                        if template[2]:
                            print(f"  Text preview: {template[2][:50]}{'...' if len(template[2]) > 50 else ''}")
                        else:
                            print(f"  Text: None or empty")
                        print("  " + "-" * 40)
                except Exception as e:
                    print(f"  Error retrieving templates: {str(e)}")
            
            print("-" * 50)
            
        # Option to check a specific stage or template
        print("\nWould you like to check a specific template? Enter template ID or press Enter to skip:")
        template_id_input = input()
        
        if template_id_input:
            try:
                cursor.execute("SELECT * FROM prompt_templates WHERE template_id = %s", (template_id_input,))
                template = cursor.fetchone()
                
                if template:
                    print(f"\nTemplate details for {template['template_id']}:")
                    for key, value in template.items():
                        if key == 'template_text':
                            print(f"{key}: {value}")
                        else:
                            print(f"{key}: {value}")
                else:
                    print(f"No template found with ID: {template_id_input}")
            except Exception as e:
                print(f"Error retrieving template: {str(e)}")
    
    except Exception as e:
        print(f"Error: {str(e)}")
    finally:
        if 'conn' in locals():
            conn.close()
            print("\nDatabase connection closed.")

if __name__ == "__main__":
    main()

================================================================================
File: check_stage.py
Path: .\backend\check_stage.py
Size: 2666
Modified: 2025-05-02T10:52:19.694657
Created: 2025-04-03T20:00:31.836872
Hash: 307c75b5aea5851c135711e63e8a5eb55a2baa6656b1632b3b25304e289386a0
Lines: 76
================================================================================
from db import get_db_connection, release_db_connection
import uuid
import logging
import json
import sys

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def check_stage(stage_id=None):
    """Check a specific stage or list all stages"""
    conn = None
    try:
        logger.info("Connecting to database...")
        conn = get_db_connection()
        cursor = conn.cursor()
        
        if stage_id:
            # Check a specific stage
            logger.info(f"Checking stage with ID: {stage_id}")
            cursor.execute("""
                SELECT * FROM stages WHERE stage_id = %s;
            """, (stage_id,))
            
            row = cursor.fetchone()
            if not row:
                print(f"No stage found with ID: {stage_id}")
                return
            
            # Get column names
            cursor.execute("""
                SELECT column_name FROM information_schema.columns 
                WHERE table_name = 'stages' ORDER BY ordinal_position;
            """)
            columns = [col[0] for col in cursor.fetchall()]
            
            print("\n=== STAGE DETAILS ===")
            stage_data = {}
            for i, col in enumerate(columns):
                if isinstance(row[i], uuid.UUID):
                    stage_data[col] = str(row[i])
                elif hasattr(row[i], 'isoformat'):
                    stage_data[col] = row[i].isoformat()
                else:
                    stage_data[col] = row[i]
                print(f"{col}: {stage_data[col]}")
            
            # Pretty print for inspection
            print("\nJSON representation:")
            print(json.dumps(stage_data, indent=2))
            
        else:
            # List all stages with relevant info
            logger.info("Listing all stages...")
            cursor.execute("""
                SELECT stage_id, business_id, stage_name, stage_type, created_at
                FROM stages ORDER BY created_at DESC;
            """)
            
            rows = cursor.fetchall()
            print("\n=== ALL STAGES ===")
            for row in rows:
                print(f"ID: {row[0]}, Business: {row[1]}, Name: {row[2]}, Type: {row[3]}, Created: {row[4]}")
    
    except Exception as e:
        logger.error(f"Error checking stage: {e}")
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    # Use command line arg if provided, otherwise list all stages
    if len(sys.argv) > 1:
        check_stage(sys.argv[1])
    else:
        check_stage()

================================================================================
File: check_tables.py
Path: .\backend\check_tables.py
Size: 997
Modified: 2025-05-02T10:52:19.694657
Created: 2025-04-03T19:59:03.267621
Hash: 376b2f9961348fe890c62c7b505a8f3d338d273e40495469a63b527aa8302385
Lines: 35
================================================================================
from db import get_db_connection, release_db_connection
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def check_tables():
    conn = None
    try:
        logger.info("Connecting to database...")
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # List all tables in the database
        logger.info("Listing all tables...")
        cursor.execute("""
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public'
            ORDER BY table_name;
        """)
        
        print("\n=== ALL TABLES IN DATABASE ===")
        tables = cursor.fetchall()
        for table in tables:
            print(f"Table: {table[0]}")
        
    except Exception as e:
        logger.error(f"Error checking tables: {e}")
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    check_tables()

================================================================================
File: check_templates.py
Path: .\backend\check_templates.py
Size: 9801
Modified: 2025-05-02T10:52:19.694657
Created: 2025-04-03T20:37:23.437776
Hash: 7e5f923f55ec03e2d3d3580cf393744c0240b16b0bfeb4772c2fd2eafb6b98a8
Lines: 189
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def main():
    try:
        print("Connecting to PostgreSQL database...")
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor(cursor_factory=DictCursor)
        
        # List all tables in the database
        print("\nListing all tables:")
        cursor.execute("SELECT table_name FROM information_schema.tables WHERE table_schema='public';")
        tables = cursor.fetchall()
        for table in tables:
            print(f"- {table[0]}")
        
        # Check if prompt_templates table exists
        if any(table[0] == 'prompt_templates' for table in tables):
            print("\nChecking prompt_templates table:")
            cursor.execute("SELECT COUNT(*) FROM prompt_templates;")
            count = cursor.fetchone()[0]
            print(f"Total templates: {count}")
            
            # Count templates by type
            cursor.execute("SELECT template_type, COUNT(*) FROM prompt_templates GROUP BY template_type;")
            type_counts = cursor.fetchall()
            print("\nTemplates by type:")
            for type_count in type_counts:
                print(f"- {type_count[0]}: {type_count[1]}")
            
            # Check for empty template text
            cursor.execute("SELECT COUNT(*) FROM prompt_templates WHERE template_text IS NULL OR template_text = '';")
            empty_count = cursor.fetchone()[0]
            print(f"\nEmpty templates: {empty_count}")
            
            if empty_count > 0:
                print("\nEmpty template records:")
                cursor.execute("SELECT template_id, template_name, template_type FROM prompt_templates WHERE template_text IS NULL OR template_text = '';")
                empty_templates = cursor.fetchall()
                for template in empty_templates:
                    print(f"ID: {template[0]}")
                    print(f"Name: {template[1]}")
                    print(f"Type: {template[2]}")
                    print("-" * 50)
            
            # Show regular template samples
            cursor.execute("SELECT COUNT(*) FROM prompt_templates WHERE template_type NOT LIKE 'default_%';")
            regular_count = cursor.fetchone()[0]
            if regular_count > 0:
                print("\nRegular Template samples (max 5):")
                cursor.execute("SELECT template_id, template_name, template_type, template_text FROM prompt_templates WHERE template_type NOT LIKE 'default_%' LIMIT 5;")
                templates = cursor.fetchall()
                for template in templates:
                    print(f"ID: {template[0]}")
                    print(f"Name: {template[1]}")
                    print(f"Type: {template[2]}")
                    print(f"Text preview: {template[3][:50]}{'...' if len(template[3]) > 50 else ''}")
                    print("-" * 50)
            
            # Show default template samples
            cursor.execute("SELECT COUNT(*) FROM prompt_templates WHERE template_type LIKE 'default_%';")
            default_count = cursor.fetchone()[0]
            if default_count > 0:
                print("\nDefault Template samples (max 5):")
                cursor.execute("SELECT template_id, template_name, template_type, template_text FROM prompt_templates WHERE template_type LIKE 'default_%' LIMIT 5;")
                templates = cursor.fetchall()
                for template in templates:
                    print(f"ID: {template[0]}")
                    print(f"Name: {template[1]}")
                    print(f"Type: {template[2]}")
                    print(f"Text preview: {template[3][:50]}{'...' if len(template[3]) > 50 else ''}")
                    print("-" * 50)
        else:
            print("\nprompt_templates table does not exist!")
            
        # Check if stages table exists and how it's structured
        if any(table[0] == 'stages' for table in tables):
            print("\nChecking stages table structure:")
            cursor.execute("SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'stages';")
            columns = cursor.fetchall()
            for col in columns:
                print(f"- {col[0]}: {col[1]}")
                
            # Check a sample of stages data
            print("\nSample stages data (max 5):")
            cursor.execute("SELECT stage_id, stage_name, stage_selection_template_id, data_extraction_template_id, response_generation_template_id FROM stages LIMIT 5;")
            stages = cursor.fetchall()
            for stage in stages:
                print(f"Stage ID: {stage[0]}")
                print(f"Name: {stage[1]}")
                print(f"Selection Template ID: {stage[2]}")
                print(f"Extraction Template ID: {stage[3]}")
                print(f"Response Template ID: {stage[4]}")
                
                # Check template details for this stage
                print("\nTemplate details for this stage:")
                template_ids = [stage[2], stage[3], stage[4]]
                valid_ids = [tid for tid in template_ids if tid is not None]
                
                if valid_ids:
                    # Convert to string format for SQL placeholders
                    placeholders = ', '.join(['%s'] * len(valid_ids))
                    cursor.execute(f"SELECT template_id, template_name, template_type, template_text FROM prompt_templates WHERE template_id IN ({placeholders})", valid_ids)
                    stage_templates = cursor.fetchall()
                    
                    for template in stage_templates:
                        print(f"  Template ID: {template[0]}")
                        print(f"  Name: {template[1]}")
                        print(f"  Type: {template[2]}")
                        if template[3]:
                            print(f"  Text preview: {template[3][:50]}{'...' if len(template[3]) > 50 else ''}")
                        else:
                            print(f"  Text: None or empty")
                        print("  " + "-" * 40)
                else:
                    print("  No template IDs found for this stage")
                
                print("-" * 50)
                
            # Option to check a specific stage
            print("\nWould you like to check a specific stage? Enter stage ID or press Enter to skip:")
            stage_id_input = input()
            
            if stage_id_input:
                try:
                    # Validate UUID format
                    stage_id = uuid.UUID(stage_id_input)
                    cursor.execute("SELECT stage_id, stage_name, stage_selection_template_id, data_extraction_template_id, response_generation_template_id FROM stages WHERE stage_id = %s", (str(stage_id),))
                    stage = cursor.fetchone()
                    
                    if stage:
                        print(f"\nStage details for {stage[0]}:")
                        print(f"Name: {stage[1]}")
                        print(f"Selection Template ID: {stage[2]}")
                        print(f"Extraction Template ID: {stage[3]}")
                        print(f"Response Template ID: {stage[4]}")
                        
                        # Check linked templates
                        print("\nLinked template details:")
                        template_types = ["Selection", "Extraction", "Response"]
                        template_ids = [stage[2], stage[3], stage[4]]
                        
                        for i, template_id in enumerate(template_ids):
                            template_type = template_types[i]
                            if template_id:
                                cursor.execute("SELECT template_id, template_name, template_type, template_text FROM prompt_templates WHERE template_id = %s", (template_id,))
                                template = cursor.fetchone()
                                
                                if template:
                                    print(f"\n{template_type} Template:")
                                    print(f"  ID: {template[0]}")
                                    print(f"  Name: {template[1]}")
                                    print(f"  Type: {template[2]}")
                                    if template[3]:
                                        print(f"  Text: {template[3]}")
                                    else:
                                        print(f"  Text: None or empty")
                                else:
                                    print(f"\n{template_type} Template: ID exists in stage but no matching template found!")
                            else:
                                print(f"\n{template_type} Template: No template ID set")
                    else:
                        print(f"No stage found with ID: {stage_id}")
                except ValueError:
                    print("Invalid UUID format")
    
    except Exception as e:
        print(f"Error: {str(e)}")
    finally:
        if 'conn' in locals():
            conn.close()
            print("\nDatabase connection closed.")

if __name__ == "__main__":
    main()

================================================================================
File: config.py
Path: .\backend\config.py
Size: 2563
Modified: 2025-05-05T13:15:54.311936
Created: 2025-03-31T17:17:36.554300
Hash: 0e052e01a37e6e03fd016a91665718408c896e360f7ae4b8f34918e7c063815c
Lines: 74
================================================================================
# backend/config.py
import os
import json
import logging
import openai
from dotenv import load_dotenv

log = logging.getLogger(__name__)

# Load environment variables
env_path = os.path.join(os.path.dirname(__file__), '.env')
load_dotenv(env_path)

class Config:
    """Configuration class for the ICMP backend."""

    # Database Configuration
    DB_NAME = os.environ.get("DB_NAME", "icmp_db")
    DB_USER = os.environ.get("DB_USER", "icmp_user")
    DB_PASSWORD = os.environ.get("DB_PASSWORD")
    DB_HOST = os.environ.get("DB_HOST", "localhost")
    DB_PORT = os.environ.get("DB_PORT", "5432")

    # API Configuration
    ICMP_API_KEY = os.environ.get("ICMP_API_KEY")
    if not ICMP_API_KEY:
        log.error("ICMP_API_KEY is not set in environment variables")
        raise ValueError("ICMP_API_KEY environment variable is required")

    # OpenAI Configuration
    OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
    if not OPENAI_API_KEY:
        log.warning("OPENAI_API_KEY not set - some features may be limited")
    
    # Create OpenAI client or use mock
    if OPENAI_API_KEY:
        try:
            client = openai.OpenAI(api_key=OPENAI_API_KEY)
            log.info("OpenAI client initialized successfully")
        except Exception as e:
            log.error(f"Failed to initialize OpenAI client: {str(e)}")
            client = None
    else:
        client = None
        log.warning("Using mock OpenAI client due to missing API key")

    # Update path HERE:
    schemas_dir = os.path.join(os.path.dirname(__file__), 'schemas')

    @staticmethod
    def load_schemas(schemas_dir):
        """Loads JSON schemas from the specified directory."""
        schemas = {}
        try:
            for filename in os.listdir(schemas_dir):
                if filename.endswith('.json'):
                    with open(os.path.join(schemas_dir, filename), 'r') as f:
                        schema_name = os.path.splitext(filename)[0]
                        schemas[schema_name] = json.load(f)
            return schemas
        except Exception as e:
            log.error(f"Error loading schemas: {str(e)}")
            return {}

# Update the path to the schemas directory
schemas_dir = os.path.join(os.path.dirname(__file__), 'schemas')
schemas = Config.load_schemas(schemas_dir)

if __name__ == "__main__":
    try:
        app.run(debug=True, host="0.0.0.0", port=5000)
    except Exception as e:
        logging.error(f"Failed to start app: {str(e)}")
        raise

================================================================================
File: conftest.py
Path: .\backend\conftest.py
Size: 297
Modified: 2025-05-02T10:52:19.711109
Created: 2025-04-02T13:49:53.247075
Hash: 228ef0293538fc7ae8fe8d89658e646cd2712ca6e174507ba22b9ff39648671d
Lines: 9
================================================================================
import sys
import os

# Add the 'backend' directory to the Python path
project_root = os.path.dirname(__file__)
backend_dir = os.path.join(project_root, 'backend') # Construct path to backend
sys.path.insert(0, backend_dir)

# You can also define project-wide fixtures here later if needed

================================================================================
File: connection_test.py
Path: .\backend\connection_test.py
Size: 753
Modified: 2025-05-06T15:45:10.945467
Created: 2025-03-31T16:02:29.283836
Hash: 2dcb46ca0907d08f7f6203330a9e6edfb6de7e7c18fc9a9415989642b8a56f37
Lines: 28
================================================================================
# connection_test.py

import os
import sys
from pathlib import Path

# Add the parent directory to the Python path
current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent
sys.path.append(str(parent_dir))

from backend.db import get_db_connection, release_db_connection
from dotenv import load_dotenv # Import load_dotenv

load_dotenv()  # Load environment variables from .env file

conn = None
try:
    conn = get_db_connection()
    cursor = conn.cursor()  # Get a cursor from the connection
    cursor.execute("SELECT 1;")
    result = cursor.fetchone()
    print(f"Query Result: {result}")
except Exception as e:
    print(f"Test Failed: {e}")
finally:
    if conn:
        release_db_connection(conn)

================================================================================
File: create_default_stage.py
Path: .\backend\create_default_stage.py
Size: 7020
Modified: 2025-05-02T10:52:19.719241
Created: 2025-04-09T09:48:13.513006
Hash: 8081d63a22ed5ffcc972726bda6db06078363ae2ecd3224936a1f530ea30c7b8
Lines: 174
================================================================================
#!/usr/bin/env python
# backend/create_default_stage.py
"""
Script to create a default stage and templates in the database.
This can be run to ensure there's always at least one valid stage ID in the database.
"""

import uuid
import logging
import psycopg2
from psycopg2.extras import RealDictCursor
import sys
import os
from datetime import datetime

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log = logging.getLogger(__name__)

# Import from parent directory
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from backend.db import get_db_connection, release_db_connection

def create_default_stage(business_id=None):
    """Create a default stage for a business if it doesn't exist."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Create templates table if it doesn't exist
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS templates (
                template_id UUID PRIMARY KEY,
                business_id UUID NOT NULL REFERENCES businesses(business_id),
                template_name VARCHAR(255) NOT NULL,
                template_type VARCHAR(50) NOT NULL,
                content TEXT NOT NULL,
                system_prompt TEXT,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
        log.info("Ensured templates table exists")
        
        # If no business_id provided, try to find a default business
        if not business_id:
            log.info("No business_id provided, trying to find a default business...")
            cursor.execute("SELECT business_id FROM businesses LIMIT 1")
            result = cursor.fetchone()
            
            if result:
                business_id = result[0]
                log.info(f"Found existing business: {business_id}")
            else:
                log.warning("No businesses found in the database. Creating default business...")
                # Create a default business
                business_id = str(uuid.uuid4())
                owner_id = str(uuid.uuid4())  # Generate a default owner ID
                
                # Get the API key from environment variable
                api_key = os.environ.get('ICMP_API_KEY', 'default_api_key')
                log.info(f"Using API key from environment: {api_key}")
                
                cursor.execute("""
                    INSERT INTO businesses (
                        business_id, business_name, business_description, 
                        created_at, api_key, owner_id
                    ) VALUES (%s, %s, %s, %s, %s, %s)
                """, (
                    business_id,
                    "Default Business",
                    "A default business for testing",
                    datetime.now(),
                    api_key,
                    owner_id
                ))
                conn.commit()
                log.info(f"Created default business: {business_id}")
        
        # Check if a default stage already exists
        cursor.execute("""
            SELECT stage_id FROM stages 
            WHERE business_id = %s AND stage_name = 'Default Conversation Stage'
        """, (business_id,))
        
        if cursor.fetchone():
            log.info("Default stage already exists")
            return None
            
        log.info("Creating default templates...")
        
        # Create default templates
        selection_template_id = str(uuid.uuid4())
        extraction_template_id = str(uuid.uuid4())
        response_template_id = str(uuid.uuid4())
        
        # Insert templates
        cursor.execute("""
            INSERT INTO templates (template_id, business_id, template_name, template_type, content, system_prompt)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (selection_template_id, business_id, "Default Selection Template", "default_stage_selection", 
              "Process this message: {{message_content}}", "You are a helpful assistant."))
        log.info(f"Created stage selection template: {selection_template_id}")
        
        cursor.execute("""
            INSERT INTO templates (template_id, business_id, template_name, template_type, content, system_prompt)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (extraction_template_id, business_id, "Default Extraction Template", "default_data_extraction",
              "Extract key information from: {{message_content}}", "Extract relevant information."))
        log.info(f"Created data extraction template: {extraction_template_id}")
        
        cursor.execute("""
            INSERT INTO templates (template_id, business_id, template_name, template_type, content, system_prompt)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (response_template_id, business_id, "Default Response Template", "default_response_generation",
              "Generate a response to: {{message_content}}", "Generate a helpful response."))
        log.info(f"Created response generation template: {response_template_id}")
        
        # Create the default stage
        stage_id = str(uuid.uuid4())
        cursor.execute("""
            INSERT INTO stages (
                stage_id, business_id, stage_name, stage_description,
                stage_type, stage_selection_template_id, data_extraction_template_id,
                response_generation_template_id, created_at
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, NOW()
            )
        """, (
            stage_id,
            business_id,
            "Default Conversation Stage",
            "Initial stage for new conversations",
            "conversation",
            selection_template_id,
            extraction_template_id,
            response_template_id
        ))
        
        conn.commit()
        log.info(f"Created default stage: {stage_id}")
        return stage_id
        
    except Exception as e:
        if conn:
            conn.rollback()
        log.error(f"Error creating default stage: {str(e)}")
        raise
    finally:
        if conn:
            release_db_connection(conn)

def main():
    """Run the script."""
    try:
        business_id = None
        if len(sys.argv) > 1:
            business_id = sys.argv[1]
            log.info(f"Using business ID from command line: {business_id}")
        
        result = create_default_stage(business_id)
        log.info(f"Default stage created or found: {result}")
        
    except Exception as e:
        log.error(f"Script failed: {str(e)}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()

================================================================================
File: db.py
Path: .\backend\db.py
Size: 10639
Modified: 2025-05-04T17:24:18.320107
Created: 2025-03-26T15:10:35.953705
Hash: 1bd598afefc18e9191cc8ac58ec79d56379bdcf14c37d5a41e8fed6b1e606f13
Lines: 258
================================================================================
import os
import logging
import psycopg2
from psycopg2 import pool
from psycopg2.extras import DictCursor, RealDictCursor
from dotenv import load_dotenv
import sys
from backend.db_config import get_db_config

load_dotenv()
log = logging.getLogger(__name__)

# Force testing mode with environment variable or if running with pytest
TESTING = os.environ.get('TESTING') == 'True' or 'pytest' in sys.modules or '--pytest' in sys.argv

# Get database configuration
DB_CONFIG = get_db_config()

# Add TCP-specific parameters to force TCP connection
if 'host' in DB_CONFIG:
    if DB_CONFIG['host'] != 'localhost':
        DB_CONFIG['client_encoding'] = 'utf8'

# Log configuration (with sensitive information masked)
masked_config = DB_CONFIG.copy()
if 'password' in masked_config:
    masked_config['password'] = '****'
log.info(f"Attempting database connection with configuration: {masked_config}")

# Initialize connection pool
CONNECTION_POOL = None

# Skip real DB connection entirely during tests
if not TESTING:
    try:
        CONNECTION_POOL = psycopg2.pool.SimpleConnectionPool(
            minconn=1,  # Start with fewer connections
            maxconn=10,  # Reduce max connections
            **DB_CONFIG,
            cursor_factory=DictCursor  # Use DictCursor for easier access to columns by name
        )
        if CONNECTION_POOL:
            # Test the connection
            test_conn = CONNECTION_POOL.getconn()
            if test_conn:
                log.info("Database connection test successful")
                CONNECTION_POOL.putconn(test_conn)
            log.info("Database connection pool created successfully")
    except Exception as e:
        log.error(f"Error creating connection pool: {e}")
        CONNECTION_POOL = None
else:
    log.info("Running in test mode - using mock database connection")

def get_db_connection():
    """Get a connection from the pool."""
    # Always return a mock for tests
    if TESTING:
        from unittest.mock import MagicMock
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_conn.cursor.return_value = mock_cursor
        mock_conn.autocommit = False
        return mock_conn
        
    # Regular connection logic for non-test environments
    try:
        if CONNECTION_POOL:
            conn = CONNECTION_POOL.getconn()
            conn.autocommit = False
            return conn
        else:
            log.error("No connection pool available")
            return None
    except Exception as e:
        log.error(f"Error getting database connection: {e}", exc_info=True)
        return None

def release_db_connection(conn):
    """Return a connection to the pool."""
    if TESTING:
        return
    
    # Don't try to release None connections
    if not conn:
        log.warning("Attempted to release None connection")
        return
        
    # Don't try to release if pool is gone
    if not CONNECTION_POOL:
        log.warning("Connection pool not available when releasing connection")
        return
    
    try:
        # Only check status if psycopg2 connection (skip for mocks)
        if hasattr(conn, 'status'):
            if conn.status != psycopg2.extensions.STATUS_READY:
                try:
                    # If there was an error, rollback is safer
                    conn.rollback()
                    log.debug("Rolling back uncommitted transaction before releasing connection")
                except Exception as e:
                    log.error(f"Error rolling back connection: {e}", exc_info=True)
        
        # Now return the connection to the pool
        CONNECTION_POOL.putconn(conn)
        log.debug("Connection successfully returned to pool")
    except Exception as e:
        log.error(f"Error releasing database connection: {e}", exc_info=True)

def execute_query(conn, query, params=None):
    """Execute a query and return the cursor."""
    if conn is None:
        log.error("Cannot execute query, connection is None")
        if TESTING:
            from unittest.mock import MagicMock
            return MagicMock()
        return None
    
    try:
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute(query, params)
        return cursor
    except Exception as e:
        log.error(f"Error executing query: {str(e)}", exc_info=True)
        try:
            conn.rollback() # Rollback in case of an error
        except:
            pass
        
        # Always re-raise the exception, even in testing mode
        raise

def get_db_pool():
    """Get the database connection pool."""
    if TESTING:
        from unittest.mock import MagicMock
        mock_pool = MagicMock()
        mock_pool.getconn.return_value = get_db_connection()
        mock_pool.putconn = release_db_connection
        return mock_pool
    return CONNECTION_POOL

def setup_database():
    conn = None
    try:
        conn = get_db_connection()
        # Drop tables with CASCADE
        execute_query(conn, 'DROP TABLE IF EXISTS messages CASCADE;')
        execute_query(conn, 'DROP TABLE IF EXISTS ai_control_settings CASCADE;')
        execute_query(conn, 'DROP TABLE IF EXISTS conversations CASCADE;')
        execute_query(conn, 'DROP TABLE IF EXISTS stages CASCADE;')
        execute_query(conn, 'DROP TABLE IF EXISTS businesses CASCADE;')
        execute_query(conn, 'DROP TABLE IF EXISTS users CASCADE;')

        # Businesses table
        execute_query(conn, '''CREATE TABLE IF NOT EXISTS businesses (
            business_id UUID PRIMARY KEY NOT NULL,
            api_key TEXT NOT NULL,
            owner_id UUID NOT NULL,
            business_name TEXT NOT NULL UNIQUE,
            business_description TEXT,
            address TEXT,
            phone_number TEXT,
            website TEXT,
            first_stage_id UUID,
            agent_list JSONB DEFAULT '[]',
            product_list JSONB DEFAULT '[]',
            service_list JSONB DEFAULT '[]',
            created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
        );''')

        # Users table
        execute_query(conn, '''CREATE TABLE IF NOT EXISTS users (
            user_id UUID PRIMARY KEY NOT NULL,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            email TEXT NOT NULL UNIQUE,
            created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
        );''')
        execute_query(conn, 'CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);')

        # Stages table
        execute_query(conn, '''CREATE TABLE IF NOT EXISTS stages (
            stage_id UUID PRIMARY KEY NOT NULL,
            business_id UUID NOT NULL,
            agent_id UUID,
            stage_name TEXT NOT NULL,
            stage_description TEXT NOT NULL,
            stage_type TEXT NOT NULL,
            stage_selection_template_id UUID,
            data_extraction_template_id UUID,
            response_generation_template_id UUID,
            created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
            CONSTRAINT fk_business FOREIGN KEY (business_id) REFERENCES businesses(business_id)
        );''')
        execute_query(conn, 'CREATE INDEX IF NOT EXISTS idx_stages_business_id ON stages (business_id);')

        # Conversations table
        execute_query(conn, '''CREATE TABLE IF NOT EXISTS conversations (
            conversation_id UUID PRIMARY KEY NOT NULL,
            business_id UUID NOT NULL,
            user_id UUID NOT NULL,
            agent_id UUID,
            stage_id UUID,
            session_id TEXT NOT NULL,
            start_time TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
            last_updated TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
            status TEXT NOT NULL DEFAULT 'active',
            CONSTRAINT fk_business FOREIGN KEY (business_id) REFERENCES businesses(business_id),
            CONSTRAINT fk_stage FOREIGN KEY (stage_id) REFERENCES stages(stage_id)
        );''')
        execute_query(conn, 'CREATE INDEX IF NOT EXISTS idx_conversations_business_id ON conversations (business_id);')

        # AI Control Settings table
        execute_query(conn, '''CREATE TABLE IF NOT EXISTS ai_control_settings (
            id UUID PRIMARY KEY NOT NULL DEFAULT gen_random_uuid(),
            user_id UUID REFERENCES users(user_id) ON DELETE CASCADE,
            conversation_id UUID REFERENCES conversations(conversation_id) ON DELETE CASCADE,
            is_stopped BOOLEAN NOT NULL DEFAULT false,
            stop_time TIMESTAMP WITH TIME ZONE,
            expiration_time TIMESTAMP WITH TIME ZONE,
            created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
            CONSTRAINT check_entity CHECK (
                (user_id IS NOT NULL AND conversation_id IS NULL) OR
                (user_id IS NULL AND conversation_id IS NOT NULL)
            )
        );''')
        execute_query(conn, 'CREATE INDEX IF NOT EXISTS idx_ai_control_user_id ON ai_control_settings(user_id);')
        execute_query(conn, 'CREATE INDEX IF NOT EXISTS idx_ai_control_conversation_id ON ai_control_settings(conversation_id);')

        # Messages table
        execute_query(conn, '''CREATE TABLE IF NOT EXISTS messages (
            message_id UUID PRIMARY KEY NOT NULL,
            conversation_id UUID NOT NULL,
            user_id UUID NOT NULL,
            message_content TEXT NOT NULL,
            sender_type TEXT NOT NULL,
            status TEXT NOT NULL DEFAULT 'delivered',
            created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
            CONSTRAINT fk_conversation FOREIGN KEY (conversation_id) REFERENCES conversations(conversation_id) ON DELETE CASCADE,
            CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(user_id)
        );''')
        execute_query(conn, 'CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages (conversation_id);')
        execute_query(conn, 'CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages (created_at);')

        conn.commit()
        log.info({"message": "Database setup completed successfully"})
    except psycopg2.Error as e:
        log.error({"message": "Database error during setup", "error": str(e)}, exc_info=True)
        raise
    finally:
        if conn:
            conn.close()

if __name__ == '__main__':
    setup_database()

================================================================================
File: db_config.py
Path: .\backend\db_config.py
Size: 2457
Modified: 2025-05-04T17:12:37.579649
Created: 2025-04-19T01:56:06.699691
Hash: f871e2b74f08f2a44948d43611a765b76a5e892ff77c758d00250c135f7bb5af
Lines: 61
================================================================================
import os
from urllib.parse import urlparse
import logging

log = logging.getLogger(__name__)

def get_db_config():
    """Get database configuration from environment variables."""
    
    # If DATABASE_URL is provided, parse it
    database_url = os.environ.get('DATABASE_URL')
    if database_url:
        try:
            # Parse the URL
            parsed = urlparse(database_url)
            
            # Ensure we're using the full hostname for Render
            hostname = parsed.hostname
            if not hostname.endswith('.render.com') and 'dpg-' in hostname:
                hostname = f"{hostname}.oregon-postgres.render.com"
            
            config = {
                "dbname": parsed.path[1:],  # Remove leading slash
                "user": parsed.username,
                "password": parsed.password,
                "host": hostname,
                "port": str(parsed.port or 5432),
                "sslmode": "require" if 'render.com' in hostname else "disable",  # Only require SSL for Render
                "client_encoding": "utf8"
            }
            log.info(f"Using database configuration from DATABASE_URL with host: {config['host']}")
            return config
        except Exception as e:
            log.error(f"Error parsing DATABASE_URL: {e}")
    
    # Otherwise use individual environment variables
    host = os.environ.get("DB_HOST", "localhost")
    # Ensure we're using the full hostname for Render
    if not host.endswith('.render.com') and 'dpg-' in host:
        host = f"{host}.oregon-postgres.render.com"
    
    # Determine if we're in production (Render) or local development
    is_production = 'render.com' in host or os.environ.get('ENVIRONMENT') == 'production'
    
    config = {
        "dbname": os.environ.get("DB_NAME", "icmp_db"),
        "user": os.environ.get("DB_USER", "icmp_user"),
        "password": os.environ.get("DB_PASSWORD"),
        "host": host,
        "port": os.environ.get("DB_PORT", "5432"),
        "sslmode": "require" if is_production else "disable",  # Only require SSL in production
        "client_encoding": "utf8"
    }
    
    # Log the configuration (with sensitive information masked)
    masked_config = config.copy()
    if 'password' in masked_config:
        masked_config['password'] = '****'
    log.info(f"Using database configuration: {masked_config}")
    
    return config

================================================================================
File: direct_template_update.py
Path: .\backend\direct_template_update.py
Size: 6890
Modified: 2025-05-02T10:52:19.752276
Created: 2025-04-03T21:00:25.313383
Hash: 9435e6d154bf1294574f5354708db6f9fd8ab23126af9bb7e30664dffe801f89
Lines: 202
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid
import sys

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def update_all_templates():
    """Update all templates with new content"""
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor(cursor_factory=DictCursor)
    
    try:
        # Find all templates
        cursor.execute("SELECT template_id, template_name, template_text FROM prompt_templates")
        templates = cursor.fetchall()
        
        if not templates:
            print("No templates found in database")
            return
        
        print(f"Found {len(templates)} templates")
        
        # Update each template
        for template in templates:
            template_id = template['template_id']
            template_name = template['template_name'] or "Unnamed Template"
            template_text = template['template_text'] or ""
            
            # Create new text with a timestamp to ensure it's different
            new_text = template_text + f"\n\n# Updated at {uuid.uuid4()}"
            
            cursor.execute("""
                UPDATE prompt_templates
                SET template_text = %s
                WHERE template_id = %s
            """, (new_text, template_id))
            
            print(f"Updated template: {template_id} - {template_name}")
        
        conn.commit()
        print("\nAll templates updated successfully!")
        
        # Verify updates
        print("\nVerifying updates...")
        cursor.execute("SELECT template_id, template_name, template_text FROM prompt_templates")
        updated_templates = cursor.fetchall()
        
        for template in updated_templates:
            template_id = template['template_id']
            template_text = template['template_text'] or ""
            
            if "# Updated at" in template_text:
                print(f"Template {template_id} verified ✓")
            else:
                print(f"Template {template_id} update failed ✗")
    
    finally:
        conn.close()

def update_specific_template(template_id=None):
    """Update a specific template by ID"""
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor(cursor_factory=DictCursor)
    
    try:
        # If no template ID provided, list all and ask user to select
        if not template_id:
            cursor.execute("SELECT template_id, template_name, template_text FROM prompt_templates")
            templates = cursor.fetchall()
            
            if not templates:
                print("No templates found in database")
                return
            
            print("\nAvailable templates:")
            for i, template in enumerate(templates, 1):
                name = template['template_name'] or "Unnamed Template"
                text_preview = template['template_text'][:50] + "..." if template['template_text'] else "No text"
                print(f"{i}. {name} ({template['template_id']}) - {text_preview}")
            
            choice = input("\nEnter template number to update (or 'q' to quit): ")
            if choice.lower() == 'q':
                return
            
            try:
                index = int(choice) - 1
                if 0 <= index < len(templates):
                    template_id = templates[index]['template_id']
                else:
                    print("Invalid selection")
                    return
            except ValueError:
                print("Invalid input")
                return
        
        # Get template details
        cursor.execute("""
            SELECT template_id, template_name, template_text 
            FROM prompt_templates
            WHERE template_id = %s
        """, (template_id,))
        
        template = cursor.fetchone()
        if not template:
            print(f"Template with ID {template_id} not found")
            return
        
        template_name = template['template_name'] or "Unnamed Template"
        template_text = template['template_text'] or ""
        
        print(f"\nSelected template: {template_name} ({template_id})")
        print(f"Current text:\n{template_text}\n")
        
        # Update template with new content
        print("Updating template...")
        new_text = template_text + f"\n\n# Updated at {uuid.uuid4()}"
        
        cursor.execute("""
            UPDATE prompt_templates
            SET template_text = %s
            WHERE template_id = %s
        """, (new_text, template_id))
        
        conn.commit()
        print(f"Template {template_id} updated successfully!")
        
        # Verify update
        cursor.execute("""
            SELECT template_text 
            FROM prompt_templates
            WHERE template_id = %s
        """, (template_id,))
        
        updated = cursor.fetchone()
        if updated and "# Updated at" in updated['template_text']:
            print("Verification successful - template was updated")
        else:
            print("Verification failed - template was not updated")
        
    finally:
        conn.close()

def main():
    print("Direct Template Update Tool")
    print("===========================")
    
    # Check if prompt_templates table exists
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_name = 'prompt_templates'
        );
    """)
    
    if not cursor.fetchone()[0]:
        print("prompt_templates table does not exist in the database")
        conn.close()
        return
    
    conn.close()
    
    # Check for command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == "--all":
            update_all_templates()
            return
        elif sys.argv[1] == "--id" and len(sys.argv) > 2:
            update_specific_template(sys.argv[2])
            return
    
    print("\n1. Update all templates")
    print("2. Update a specific template")
    print("3. Exit")
    
    choice = input("\nSelect an option (1-3): ")
    
    if choice == '1':
        update_all_templates()
    elif choice == '2':
        update_specific_template()
    elif choice == '3':
        print("Exiting...")
    else:
        print("Invalid option")

if __name__ == "__main__":
    main()

================================================================================
File: fix_templates.py
Path: .\backend\fix_templates.py
Size: 8060
Modified: 2025-05-02T10:52:19.752359
Created: 2025-04-03T20:38:53.771246
Hash: 8edfe21bce270f0c132262720ffa45d3ca3540963f1abe2ae35ce7a7defda50e
Lines: 187
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

# Default template texts
DEFAULT_TEMPLATES = {
    "stage_selection": """You are the Stage Selection Engine.

User request: {user_message}

Your task is to select the appropriate stage to handle this request based on its content.
Analyze the message carefully and select the most appropriate stage.

Stage options:
{stage_options}

Return only the stage ID that should handle this message.""",

    "data_extraction": """Extract key information from the following user message.

User message: {user_message}

Extract the following details (return as JSON):
- Main request type
- Specific entities mentioned
- Any time constraints or deadlines
- Priority level (if mentioned)
- Any additional relevant details""",

    "response_generation": """Generate a professional and helpful response to the user's query.

User query: {user_message}

Context information: {context}

Instructions:
- Be concise and directly address the user's query
- Include relevant information from the context provided
- Maintain a professional but friendly tone
- If you need more information, politely ask follow-up questions
- Format your response for readability"""
}

def main():
    try:
        print("Connecting to PostgreSQL database...")
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor(cursor_factory=DictCursor)
        
        # Check if default_templates table exists
        cursor.execute("SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'default_templates')")
        table_exists = cursor.fetchone()[0]
        
        if not table_exists:
            print("The default_templates table doesn't exist. Creating it...")
            cursor.execute("""
                CREATE TABLE default_templates (
                    template_id UUID PRIMARY KEY,
                    template_name VARCHAR(255) NOT NULL,
                    template_text TEXT NOT NULL,
                    variables TEXT[] DEFAULT '{}',
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
                )
            """)
            conn.commit()
            print("Table created successfully.")
        
        # Find empty templates
        cursor.execute("SELECT template_id, template_name FROM default_templates WHERE template_text IS NULL OR template_text = ''")
        empty_templates = cursor.fetchall()
        
        if empty_templates:
            print(f"Found {len(empty_templates)} empty templates. Fixing them...")
            
            for template in empty_templates:
                template_id = template[0]
                template_name = template[1].lower()
                template_text = None
                
                # Determine which default template to use based on name
                if "selection" in template_name:
                    template_text = DEFAULT_TEMPLATES["stage_selection"]
                elif "extraction" in template_name:
                    template_text = DEFAULT_TEMPLATES["data_extraction"]
                elif "response" in template_name or "generation" in template_name:
                    template_text = DEFAULT_TEMPLATES["response_generation"]
                else:
                    # Generic template if we can't determine the type
                    template_text = "Default template text. Please update with appropriate content."
                
                # Update the template
                cursor.execute(
                    "UPDATE default_templates SET template_text = %s WHERE template_id = %s",
                    (template_text, template_id)
                )
                print(f"Fixed template: {template_id} - {template_name}")
            
            conn.commit()
            print("All empty templates have been fixed.")
        else:
            print("No empty templates found.")
        
        # Check stages with missing template references
        cursor.execute("""
            SELECT stage_id, stage_name 
            FROM stages 
            WHERE stage_selection_template_id IS NULL 
               OR data_extraction_template_id IS NULL 
               OR response_generation_template_id IS NULL
        """)
        stages_with_missing_templates = cursor.fetchall()
        
        if stages_with_missing_templates:
            print(f"\nFound {len(stages_with_missing_templates)} stages with missing template references.")
            
            fix_stages = input("Do you want to fix these stages by creating missing templates? (y/n): ")
            if fix_stages.lower() == 'y':
                for stage in stages_with_missing_templates:
                    stage_id = stage[0]
                    stage_name = stage[1]
                    
                    # Get current template IDs
                    cursor.execute("""
                        SELECT stage_selection_template_id, data_extraction_template_id, response_generation_template_id
                        FROM stages
                        WHERE stage_id = %s
                    """, (stage_id,))
                    template_ids = cursor.fetchone()
                    
                    # Create missing templates
                    template_fields = ['stage_selection_template_id', 'data_extraction_template_id', 'response_generation_template_id']
                    template_types = ['stage_selection', 'data_extraction', 'response_generation']
                    template_names = [f"{stage_name} - Stage Selection", f"{stage_name} - Data Extraction", f"{stage_name} - Response Generation"]
                    
                    updates = {}
                    
                    for i, field in enumerate(template_fields):
                        if template_ids[i] is None:
                            # Create new template
                            new_template_id = str(uuid.uuid4())
                            cursor.execute(
                                """
                                INSERT INTO default_templates (template_id, template_name, template_text, variables)
                                VALUES (%s, %s, %s, %s)
                                """,
                                (new_template_id, template_names[i], DEFAULT_TEMPLATES[template_types[i]], ['user_message'])
                            )
                            updates[field] = new_template_id
                            print(f"Created new {template_types[i]} template for stage {stage_name}")
                    
                    # Update stage if needed
                    if updates:
                        set_clause = ", ".join([f"{field} = %s" for field in updates.keys()])
                        query = f"UPDATE stages SET {set_clause} WHERE stage_id = %s"
                        params = list(updates.values()) + [stage_id]
                        cursor.execute(query, params)
                        print(f"Updated stage {stage_name} with new template references")
                
                conn.commit()
                print("All stages have been fixed with proper template references.")
        else:
            print("All stages have valid template references.")
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        print(f"Error: {str(e)}")
    finally:
        if 'conn' in locals():
            conn.close()
            print("\nDatabase connection closed.")

if __name__ == "__main__":
    main()

================================================================================
File: fix_template_names.py
Path: .\backend\fix_template_names.py
Size: 3727
Modified: 2025-05-02T10:52:19.752359
Created: 2025-04-03T20:47:25.115571
Hash: 6974fd02f17feffe5ab03c348273ab3c0432adbcbc25409b6120718fa7bce88e
Lines: 96
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def main():
    try:
        print("Connecting to PostgreSQL database...")
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor(cursor_factory=DictCursor)
        
        # Find templates with NULL names
        cursor.execute("SELECT template_id FROM prompt_templates WHERE template_name IS NULL")
        templates_needing_names = cursor.fetchall()
        
        if not templates_needing_names:
            print("No templates found with NULL names.")
            return
            
        print(f"Found {len(templates_needing_names)} templates with NULL names.")
        
        # For each template, find linked stage and update template name
        for template_row in templates_needing_names:
            template_id = template_row[0]
            print(f"Processing template: {template_id}")
            
            # Check if it's linked to a stage
            cursor.execute("""
                SELECT 
                    stage_id, stage_name, 
                    CASE 
                        WHEN stage_selection_template_id = %s THEN 'Stage Selection'
                        WHEN data_extraction_template_id = %s THEN 'Data Extraction'
                        WHEN response_generation_template_id = %s THEN 'Response Generation'
                        ELSE NULL
                    END as template_type
                FROM 
                    stages 
                WHERE 
                    stage_selection_template_id = %s OR 
                    data_extraction_template_id = %s OR 
                    response_generation_template_id = %s
                LIMIT 1
            """, [template_id, template_id, template_id, template_id, template_id, template_id])
            
            stage_row = cursor.fetchone()
            
            if stage_row:
                stage_id = stage_row[0]
                stage_name = stage_row[1] or "Unnamed Stage"
                template_type = stage_row[2]
                
                # Create a new template name
                template_name = f"{stage_name} - {template_type}"
                
                # Update the template name
                cursor.execute(
                    "UPDATE prompt_templates SET template_name = %s WHERE template_id = %s",
                    (template_name, template_id)
                )
                
                print(f"  Updated template with name: {template_name}")
            else:
                # Standalone template, use a generic name
                cursor.execute(
                    "UPDATE prompt_templates SET template_name = %s WHERE template_id = %s",
                    (f"Standalone Template {template_id[:8]}", template_id)
                )
                print(f"  Updated with generic name (not linked to a stage)")
        
        # Commit all updates
        conn.commit()
        print("All template names have been updated successfully.")
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        print(f"Error: {e}")
    finally:
        if 'conn' in locals():
            conn.close()
            print("Database connection closed.")

if __name__ == "__main__":
    main()

================================================================================
File: health_check.py
Path: .\backend\health_check.py
Size: 1062
Modified: 2025-05-02T10:52:19.760543
Created: 2025-03-27T23:49:24.425544
Hash: 71ab69612304365a9061dc0aea700ee4eca07b2fc7cfabaaa0c68f4b7c0c82b9
Lines: 26
================================================================================
from flask import jsonify
from db import get_db_connection, release_db_connection
from datetime import datetime
import psycopg2
import logging

log = logging.getLogger(__name__)

def register(app, require_api_key, limiter, schemas):
    @app.route('/health', methods=['GET'])
    @require_api_key
    #@limiter.limit("100 per minute")  # Added rate limiting
    def health_check():
        status = {"status": "healthy", "date": datetime.now().isoformat()}
        try:
            conn = get_db_connection()
            with conn.cursor() as cursor:
                cursor.execute("SELECT 1")
            status["database"] = "connected"
            release_db_connection(conn)
        except psycopg2.Error as e:  # Narrowed exception
            status["status"] = "unhealthy"
            status["database"] = "disconnected"
            log.error(f"Database health check failed: {str(e)}", exc_info=True)
        status["schemas_loaded"] = len(schemas) > 0
        return jsonify(status), 200 if status["status"] == "healthy" else 503

================================================================================
File: init_db.py
Path: .\backend\init_db.py
Size: 4357
Modified: 2025-05-02T10:52:19.760543
Created: 2025-04-19T13:47:25.117217
Hash: c05d7224ee99631717aeb133976057c20e5b613b8a1f49486543eb7cc12ab395
Lines: 116
================================================================================
import os
import logging
import psycopg2
from dotenv import load_dotenv
from db_config import get_db_config

load_dotenv()
logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

def init_database():
    """Initialize the database with required tables."""
    config = get_db_config()
    log.info("Attempting to connect to database...")
    
    try:
        # Connect directly without connection pool
        conn = psycopg2.connect(**config)
        conn.autocommit = True
        cursor = conn.cursor()
        
        # Create llm_calls table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS llm_calls (
            call_id UUID PRIMARY KEY,
            business_id UUID,
            input_text TEXT,
            response TEXT,
            system_prompt TEXT,
            call_type TEXT,
            timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );''')
        
        # Create businesses table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS businesses (
            business_id UUID PRIMARY KEY,
            api_key TEXT NOT NULL,
            owner_id UUID NOT NULL,
            business_name TEXT NOT NULL UNIQUE,
            business_description TEXT,
            address TEXT,
            phone_number TEXT,
            website TEXT,
            first_stage_id UUID,
            agent_list JSONB DEFAULT '[]',
            product_list JSONB DEFAULT '[]',
            service_list JSONB DEFAULT '[]',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );''')

        # Create users table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id UUID PRIMARY KEY,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            email TEXT NOT NULL UNIQUE,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );''')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);')

        # Create agents table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS agents (
            agent_id UUID PRIMARY KEY NOT NULL,
            business_id UUID NOT NULL REFERENCES businesses(business_id) ON DELETE CASCADE,
            agent_name TEXT NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
        );''')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_agents_business_id ON agents (business_id);')

        # Create stages table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS stages (
            stage_id UUID PRIMARY KEY,
            business_id UUID REFERENCES businesses(business_id),
            agent_id UUID REFERENCES agents(agent_id),
            stage_name TEXT NOT NULL,
            stage_description TEXT NOT NULL,
            stage_type TEXT NOT NULL,
            stage_selection_template_id UUID,
            data_extraction_template_id UUID,
            response_generation_template_id UUID,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );''')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_stages_business_id ON stages (business_id);')

        # Create conversations table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS conversations (
            conversation_id UUID PRIMARY KEY,
            business_id UUID REFERENCES businesses(business_id),
            user_id UUID,
            agent_id UUID REFERENCES agents(agent_id),
            stage_id UUID REFERENCES stages(stage_id),
            session_id TEXT NOT NULL,
            start_time TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            status TEXT NOT NULL DEFAULT 'active'
        );''')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_conversations_business_id ON conversations (business_id);')

        log.info("Database tables created successfully!")
        
    except Exception as e:
        log.error(f"Error initializing database: {str(e)}")
        raise
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

if __name__ == "__main__":
    init_database()

================================================================================
File: messenger.py
Path: .\backend\messenger.py
Size: 5015
Modified: 2025-05-02T10:52:19.777006
Created: 2025-04-25T18:24:32.538134
Hash: 2a29a2ba2a983b6bfebc802fc07a622777448aba8112375766c6066dbd78984c
Lines: 139
================================================================================
from flask import Flask, request, jsonify
import os
import hmac
import hashlib
import json
import uuid
import logging
from functools import wraps
from db import get_db_connection, release_db_connection

# Set up logging
log = logging.getLogger(__name__)

# Facebook Messenger verification token
VERIFY_TOKEN = os.getenv('FB_VERIFY_TOKEN')
PAGE_ACCESS_TOKEN = os.getenv('FB_PAGE_ACCESS_TOKEN')

def verify_fb_token(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.method == 'GET':
            token_sent = request.args.get('hub.verify_token')
            if token_sent == VERIFY_TOKEN:
                return request.args.get('hub.challenge')
            return 'Invalid verification token'
        return f(*args, **kwargs)
    return decorated_function

def handle_message(sender_id, message):
    """Handle incoming messages from Facebook Messenger"""
    log.info(f"Received message from {sender_id}: {message}")
    
    # Get a database connection
    conn = get_db_connection()
    try:
        # Check if this user exists in our system
        cursor = conn.cursor()
        cursor.execute("SELECT user_id FROM users WHERE external_id = %s", (sender_id,))
        result = cursor.fetchone()
        
        if result:
            user_id = result[0]
        else:
            # Create a new user if they don't exist
            user_id = str(uuid.uuid4())
            cursor.execute(
                "INSERT INTO users (user_id, external_id, first_name, last_name) VALUES (%s, %s, %s, %s)",
                (user_id, sender_id, "Facebook", "User")
            )
            conn.commit()
        
        # Get the business ID (using a default for now)
        cursor.execute("SELECT business_id FROM businesses LIMIT 1")
        business_result = cursor.fetchone()
        
        if not business_result:
            log.error("No business found in the database")
            return {
                'recipient': {'id': sender_id},
                'message': {'text': "Sorry, there was an error processing your message."}
            }
        
        business_id = business_result[0]
        
        # Process the message using the message handler
        from backend.message_processing.message_handler import MessageHandler
        from backend.db import get_db_pool
        
        message_handler = MessageHandler(get_db_pool())
        result = message_handler.process_message({
            'business_id': business_id,
            'user_id': user_id,
            'content': message,
            'source': 'facebook_messenger'
        })
        
        if result.get('success'):
            response_text = result.get('response', '')
        else:
            response_text = "Sorry, there was an error processing your message."
            log.error(f"Error processing message: {result.get('error')}")
        
        return {
            'recipient': {'id': sender_id},
            'message': {'text': response_text}
        }
    except Exception as e:
        log.error(f"Error handling message: {str(e)}", exc_info=True)
        return {
            'recipient': {'id': sender_id},
            'message': {'text': "Sorry, there was an error processing your message."}
        }
    finally:
        release_db_connection(conn)

def send_message(recipient_id, response):
    """Send message to Facebook Messenger"""
    import requests
    
    if not PAGE_ACCESS_TOKEN:
        log.error("Facebook PAGE_ACCESS_TOKEN is not set")
        return None
    
    params = {
        "access_token": PAGE_ACCESS_TOKEN
    }
    headers = {
        "Content-Type": "application/json"
    }
    data = json.dumps(response)
    
    url = "https://graph.facebook.com/v18.0/me/messages"
    
    try:
        result = requests.post(url, params=params, headers=headers, data=data)
        log.info(f"Facebook API response: {result.status_code} - {result.text}")
        return result.json()
    except Exception as e:
        log.error(f"Error sending message: {e}", exc_info=True)
        return None

def setup_messenger_routes(app):
    @app.route('/webhook', methods=['GET', 'POST'])
    @verify_fb_token
    def webhook():
        if request.method == 'POST':
            output = request.get_json()
            log.info(f"Received webhook data: {json.dumps(output)}")
            
            for event in output['entry']:
                messaging = event['messaging']
                for message in messaging:
                    if message.get('message'):
                        sender_id = message['sender']['id']
                        if message['message'].get('text'):
                            message_text = message['message']['text']
                            response = handle_message(sender_id, message_text)
                            send_message(sender_id, response)
        return "Message Processed"

================================================================================
File: openai_helper.py
Path: .\backend\openai_helper.py
Size: 2336
Modified: 2025-05-02T10:52:19.785234
Created: 2025-03-30T15:12:25.216462
Hash: 07930a5750eb405498cd92d560cafe32820d99bcab1963bb3ef27e0ac7dd7061
Lines: 58
================================================================================
# backend/openai_helper.py
import openai
import logging
import os
from dotenv import load_dotenv
from template_management import TemplateManager
from db import get_db_connection, release_db_connection #added
from config import Config

load_dotenv()

log = logging.getLogger(__name__)


def render_prompt(template_id: str, context: dict) -> str:
    """Generate ready-to-use prompt"""
    try:
        if template_id:
           return TemplateManager.render(template_id, context)
        return "Default prompt" #return default if there is no template ID
    except Exception as e:
        raise ValueError(f"Prompt rendering failed: {str(e)}")

def call_openai(prompt):
    """Call OpenAI API with the given prompt. Returns a mock response if the API call fails."""
    try:
        # Get the API key from environment variables
        api_key = os.environ.get('OPENAI_API_KEY')
        
        if not api_key:
            log.warning("OPENAI_API_KEY not set in environment variables. Using mock response.")
            return f"This is a mock response to: '{prompt[:50]}...'. API key not configured."
        
        # Check if the API key is properly formatted (should start with "sk-")
        if not api_key.startswith('sk-'):
            log.warning("OPENAI_API_KEY appears to be invalid (should start with 'sk-'). Using mock response.")
            return f"This is a mock response to: '{prompt[:50]}...'. API key format is invalid."
        
        # Create a client instance with the API key
        client = openai.OpenAI(api_key=api_key)
        
        # Make the API call
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": prompt}
            ]
        )
        
        # Return the response content
        return response.choices[0].message.content
    except Exception as e:
        log.error(f"OpenAI API error: {str(e)}", exc_info=True)
        
        # Return a descriptive mock response for debugging
        return f"This is a mock response. The OpenAI API call failed with error: {str(e)[:100]}... Please check your API key and configuration."
#full file drafted by AI

================================================================================
File: run.py
Path: .\backend\run.py
Size: 520
Modified: 2025-05-02T10:52:19.793271
Created: 2025-04-05T00:02:36.679621
Hash: ede118ab370270ee4ed8b52fbce04220fa49378605e5beb684c99c9b07cc5f10
Lines: 19
================================================================================
#!/usr/bin/env python
"""
Run script for the ICMP Events API backend
This script sets up the Python path correctly and runs the app
"""
import os
import sys

# Add the current directory to the Python path
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)

# Import and run the app
from app import app

if __name__ == "__main__":
    print("Starting ICMP Events API server...")
    app.run(debug=True, host="0.0.0.0", port=5000)

================================================================================
File: schemas_loader.py
Path: .\backend\schemas_loader.py
Size: 1286
Modified: 2025-05-02T10:52:19.793271
Created: 2025-03-26T14:51:12.441532
Hash: ff2c15ddb63a2649f557e270e2e276d7f958c6ad5967ab876eef0ab9c7246ee3
Lines: 29
================================================================================
# schemas_loader.py
import os  # Add this import
import json
import logging
from pythonjsonlogger import jsonlogger

log = logging.getLogger(__name__)
log_handler = logging.StreamHandler()
log_handler.setFormatter(jsonlogger.JsonFormatter())
log.addHandler(log_handler)

def load_schemas(schemas_dir):
    """Loads JSON schemas from the specified directory using schema titles as keys."""
    schemas = {}
    for filename in os.listdir(schemas_dir):
        if filename.endswith(".json"):
            schema_name = filename[:-5]  # Fallback to filename without .json
            filepath = os.path.join(schemas_dir, filename)
            try:
                with open(filepath, "r") as f:
                    schema = json.load(f)
                # Use schema title if present, otherwise fallback to filename
                schema_key = schema.get("title", schema_name).lower().replace(" ", "_")
                schemas[schema_key] = schema
                log.info({"message": f"Schema loaded: {schema_key}"})
            except (FileNotFoundError, json.JSONDecodeError) as e:
                log.error({"message": f"Failed to load schema {filename}", "error": str(e)})
                continue  # Skip this schema and move to the next
    return schemas

================================================================================
File: setup_database.py
Path: .\backend\setup_database.py
Size: 4708
Modified: 2025-05-06T15:23:08.645083
Created: 2025-05-06T15:23:06.543489
Hash: 2caeed1d4fb291509a362c245e94c92073d161bfe26b58702531a06018e2cb21
Lines: 137
================================================================================
import psycopg2
import os
import logging
from dotenv import load_dotenv
from typing import Dict, Optional
import sys

# Configure logging
logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

class DatabaseSetup:
    def __init__(self):
        self.db_params = self._load_db_params()
        self.conn = None
        self.cursor = None

    def _load_db_params(self) -> Dict[str, str]:
        """Load database parameters from environment variables"""
        load_dotenv()
        
        params = {
            "dbname": os.getenv("DB_NAME", "icmp_db"),
            "user": os.getenv("DB_USER", "icmp_user"),
            "password": os.getenv("DB_PASSWORD"),
            "host": os.getenv("DB_HOST", "localhost"),
            "port": os.getenv("DB_PORT", "5432")
        }
        
        # Validate required parameters
        if not params["password"]:
            log.error("DB_PASSWORD environment variable not set")
            raise ValueError("DB_PASSWORD is required")
            
        return params

    def connect(self) -> None:
        """Establish database connection"""
        try:
            log.info("Connecting to database...")
            self.conn = psycopg2.connect(**self.db_params)
            self.conn.autocommit = True
            self.cursor = self.conn.cursor()
            log.info("Database connection established successfully")
        except Exception as e:
            log.error(f"Database connection failed: {str(e)}")
            raise

    def close(self) -> None:
        """Close database connection"""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        log.info("Database connection closed")

    def execute_sql_file(self, file_path: str) -> None:
        """Execute SQL commands from a file"""
        try:
            log.info(f"Reading SQL file: {file_path}")
            with open(file_path, 'r') as sql_file:
                sql_script = sql_file.read()
            
            log.info("Executing SQL script...")
            self.cursor.execute(sql_script)
            log.info("SQL script executed successfully")
        except Exception as e:
            log.error(f"SQL execution failed: {str(e)}")
            raise

    def create_database(self) -> None:
        """Create the database if it doesn't exist"""
        # Connect to default database first
        default_params = self.db_params.copy()
        default_params['dbname'] = 'postgres'
        
        try:
            log.info("Connecting to default database...")
            conn = psycopg2.connect(**default_params)
            conn.autocommit = True
            cursor = conn.cursor()
            
            # Check if database exists
            cursor.execute("SELECT 1 FROM pg_database WHERE datname = %s", (self.db_params['dbname'],))
            exists = cursor.fetchone()
            
            if not exists:
                log.info(f"Creating database: {self.db_params['dbname']}")
                cursor.execute(f"CREATE DATABASE {self.db_params['dbname']}")
                log.info("Database created successfully")
            else:
                log.info("Database already exists")
                
        except Exception as e:
            log.error(f"Database creation failed: {str(e)}")
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    def setup_database(self) -> None:
        """Main method to set up the database"""
        try:
            # Create database if it doesn't exist
            self.create_database()
            
            # Connect to the new database
            self.connect()
            
            # Execute setup scripts
            scripts_dir = os.path.join(os.path.dirname(__file__), 'migrations')
            for script in sorted(os.listdir(scripts_dir)):
                if script.endswith('.sql'):
                    script_path = os.path.join(scripts_dir, script)
                    self.execute_sql_file(script_path)
            
            log.info("Database setup completed successfully!")
            
        except Exception as e:
            log.error(f"Database setup failed: {str(e)}")
            raise
        finally:
            self.close()

def main():
    """Main entry point"""
    try:
        db_setup = DatabaseSetup()
        db_setup.setup_database()
    except Exception as e:
        log.error(f"Setup failed: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main() 

================================================================================
File: stage_example.py
Path: .\backend\stage_example.py
Size: 2972
Modified: 2025-05-02T10:52:19.793271
Created: 2025-04-03T20:05:43.936881
Hash: f9d64e79bfd775be96bdb52d360a8f113cdff491c88c3ae0462bca8e3bf2bb97
Lines: 74
================================================================================
import json

# This script demonstrates the correct structure for creating and updating stages

# Example of correct request format for creating a new stage
create_stage_example = {
    "business_id": "7ae167a0-d864-43b9-bdaf-fcba35b33f27",  # Required
    "agent_id": "f731ec2a-a68d-4e56-8a27-d77a9ad4978a",     # Optional
    "stage_name": "Customer Greeting",                      # Required
    "stage_description": "Initial greeting stage for customers", # Required
    "stage_type": "greeting",                               # Required
    
    # All three of these config objects are REQUIRED
    "stage_selection_config": {
        "template_text": "This is the prompt template for stage selection."
        # variables field is optional
    },
    "data_extraction_config": {
        "template_text": "This is the prompt template for data extraction."
        # variables field is optional
    },
    "response_generation_config": {
        "template_text": "This is the prompt template for response generation."
        # variables field is optional
    }
}

# Example of correct request format for updating an existing stage
update_stage_example = {
    "business_id": "7ae167a0-d864-43b9-bdaf-fcba35b33f27",  # Required
    # Only include fields you want to update
    "stage_name": "Updated Customer Greeting",              # Optional for update
    
    # Any of these template configs can be included if you want to update them
    "stage_selection_config": {
        "template_text": "Updated prompt template for stage selection."
    }
    # You don't need to include all config objects, only those you want to update
}

# Example of what the response structure looks like for a stage
stage_response_example = {
    "stage_id": "12345678-1234-5678-1234-567812345678",
    "business_id": "7ae167a0-d864-43b9-bdaf-fcba35b33f27",
    "agent_id": "f731ec2a-a68d-4e56-8a27-d77a9ad4978a",
    "stage_name": "Customer Greeting",
    "stage_description": "Initial greeting stage for customers",
    "stage_type": "greeting",
    "created_at": "2023-04-01T12:34:56.789Z",
    
    # Template configs in response
    "stage_selection_config": {
        "template_text": "This is the prompt template for stage selection.",
        "variables": []
    },
    "data_extraction_config": {
        "template_text": "This is the prompt template for data extraction.",
        "variables": []
    },
    "response_generation_config": {
        "template_text": "This is the prompt template for response generation.",
        "variables": []
    }
}

if __name__ == "__main__":
    print("\n=== STAGE CREATION REQUEST FORMAT ===")
    print(json.dumps(create_stage_example, indent=2))
    
    print("\n=== STAGE UPDATE REQUEST FORMAT ===")
    print(json.dumps(update_stage_example, indent=2))
    
    print("\n=== STAGE RESPONSE FORMAT ===")
    print(json.dumps(stage_response_example, indent=2))

================================================================================
File: template_management.py
Path: .\backend\template_management.py
Size: 6255
Modified: 2025-05-06T15:22:54.148983
Created: 2025-03-28T04:29:16.930003
Hash: ca64f382cf3b008fd19ce2f8d3f072b7b6f0648ae8875cf8b8050945172598d6
Lines: 162
================================================================================
from db import get_db_connection, release_db_connection
import logging
import uuid
from typing import Dict, List, Optional, Union
import json

log = logging.getLogger(__name__)

class TemplateManager:
    @staticmethod
    def get(template_id: str) -> dict:
        """Retrieve template with validation metadata"""
        conn = get_db_connection()
        try:
            with conn.cursor() as c:
                c.execute('''
                    SELECT template_id, template_text, variables, template_type, metadata
                    FROM default_templates
                    WHERE template_id = %s;
                ''', (template_id,))
                result = c.fetchone()
                if not result:
                    raise ValueError(f"Template {template_id} not found")
                return {
                    'id': result[0],
                    'text': result[1],
                    'variables': result[2],
                    'type': result[3],
                    'metadata': result[4] if result[4] else {}
                }
        except Exception as e:
            log.error(f"Template fetch failed: {str(e)}")
            raise
        finally:
            release_db_connection(conn)

    @staticmethod
    def validate_placeholders(template_id: str, context: dict) -> bool:
        """Verify all required placeholders are provided"""
        template = TemplateManager.get(template_id)
        if template is None:
            raise ValueError(f"No Template found for: {template_id}")

        required_vars = set(template['variables'])
        provided_vars = set(context.keys())

        missing = required_vars - provided_vars
        if missing:
            raise ValueError(f"Missing variables for template {template_id}: {missing}")
        return True

    @staticmethod
    def render(template_id: str, context: dict) -> str:
        """Render template with context after validation"""
        TemplateManager.validate_placeholders(template_id, context)
        template = TemplateManager.get(template_id)
        if template is None:
            raise ValueError(f"No Template found for: {template_id}")
        return template['text'].format(**context)

    @staticmethod
    def create(template_data: Dict[str, Union[str, List[str], Dict]]) -> str:
        """Create a new template"""
        conn = get_db_connection()
        try:
            template_id = str(uuid.uuid4())
            with conn.cursor() as c:
                c.execute('''
                    INSERT INTO default_templates 
                    (template_id, template_text, variables, template_type, metadata)
                    VALUES (%s, %s, %s, %s, %s)
                    RETURNING template_id;
                ''', (
                    template_id,
                    template_data['text'],
                    template_data['variables'],
                    template_data.get('type', 'default'),
                    json.dumps(template_data.get('metadata', {}))
                ))
                return c.fetchone()[0]
        except Exception as e:
            log.error(f"Template creation failed: {str(e)}")
            raise
        finally:
            release_db_connection(conn)

    @staticmethod
    def update(template_id: str, template_data: Dict[str, Union[str, List[str], Dict]]) -> bool:
        """Update an existing template"""
        conn = get_db_connection()
        try:
            with conn.cursor() as c:
                c.execute('''
                    UPDATE default_templates 
                    SET template_text = %s,
                        variables = %s,
                        template_type = %s,
                        metadata = %s
                    WHERE template_id = %s
                    RETURNING template_id;
                ''', (
                    template_data['text'],
                    template_data['variables'],
                    template_data.get('type', 'default'),
                    json.dumps(template_data.get('metadata', {})),
                    template_id
                ))
                return bool(c.fetchone())
        except Exception as e:
            log.error(f"Template update failed: {str(e)}")
            raise
        finally:
            release_db_connection(conn)

    @staticmethod
    def delete(template_id: str) -> bool:
        """Delete a template"""
        conn = get_db_connection()
        try:
            with conn.cursor() as c:
                c.execute('''
                    DELETE FROM default_templates 
                    WHERE template_id = %s
                    RETURNING template_id;
                ''', (template_id,))
                return bool(c.fetchone())
        except Exception as e:
            log.error(f"Template deletion failed: {str(e)}")
            raise
        finally:
            release_db_connection(conn)

    @staticmethod
    def list_templates(template_type: Optional[str] = None) -> List[Dict]:
        """List all templates, optionally filtered by type"""
        conn = get_db_connection()
        try:
            with conn.cursor() as c:
                if template_type:
                    c.execute('''
                        SELECT template_id, template_text, variables, template_type, metadata
                        FROM default_templates
                        WHERE template_type = %s;
                    ''', (template_type,))
                else:
                    c.execute('''
                        SELECT template_id, template_text, variables, template_type, metadata
                        FROM default_templates;
                    ''')
                results = c.fetchall()
                return [{
                    'id': r[0],
                    'text': r[1],
                    'variables': r[2],
                    'type': r[3],
                    'metadata': r[4] if r[4] else {}
                } for r in results]
        except Exception as e:
            log.error(f"Template listing failed: {str(e)}")
            raise
        finally:
            release_db_connection(conn)

================================================================================
File: test_create_stage.py
Path: .\backend\test_create_stage.py
Size: 2931
Modified: 2025-05-02T10:52:19.801500
Created: 2025-04-03T20:04:55.172966
Hash: 1dcc45fdcd444aac76f1e6e7e4129c6adb10055fe81a0a39061305ef2a020791
Lines: 82
================================================================================
import requests
import json
import uuid
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Replace with your actual API endpoint and authentication
BASE_URL = "http://localhost:5000"  # Adjust if your server runs on a different port
API_KEY = "your_api_key_here"  # Replace with your actual API key
BUSINESS_ID = "7ae167a0-d864-43b9-bdaf-fcba35b33f27"  # Replace with your actual business ID
AGENT_ID = "f731ec2a-a68d-4e56-8a27-d77a9ad4978a"  # Optional, can be None

def test_create_stage():
    """Test creating a stage with the correct field structure"""
    
    # This is the proper structure for creating a new stage
    stage_data = {
        "business_id": BUSINESS_ID,
        "agent_id": AGENT_ID,  # Optional
        "stage_name": "Test Stage",
        "stage_description": "A test stage created via API",
        "stage_type": "information",
        
        # These three config objects are required
        "stage_selection_config": {
            "template_text": "This is the stage selection prompt template. It helps determine which stage to use based on user input."
        },
        "data_extraction_config": {
            "template_text": "This is the data extraction prompt template. It helps extract key information from user messages."
        },
        "response_generation_config": {
            "template_text": "This is the response generation prompt template. It helps generate appropriate responses based on the extracted data."
        }
    }
    
    # Print the request body for debugging
    print("\nRequest Body:")
    print(json.dumps(stage_data, indent=2))
    
    # Make the API request
    try:
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "X-API-KEY": API_KEY
        }
        
        response = requests.post(
            f"{BASE_URL}/stages",
            json=stage_data,
            headers=headers
        )
        
        # Print the response for debugging
        print(f"\nStatus Code: {response.status_code}")
        print("Response Body:")
        if response.text:
            try:
                print(json.dumps(response.json(), indent=2))
            except:
                print(response.text)
        
        if response.status_code == 201:
            print("\nStage created successfully!")
            return response.json().get("stage_id")
        else:
            print("\nFailed to create stage")
            return None
            
    except Exception as e:
        logger.error(f"Error making API request: {e}")
        return None

if __name__ == "__main__":
    print("Testing stage creation...")
    stage_id = test_create_stage()
    if stage_id:
        print(f"Created stage with ID: {stage_id}")
    else:
        print("Stage creation failed")

================================================================================
File: test_frontend_update.py
Path: .\backend\test_frontend_update.py
Size: 7702
Modified: 2025-05-02T10:52:19.801500
Created: 2025-04-04T01:25:01.101087
Hash: c5e0bd530125340372853e3829a1057ed9d0ba4f4ad1fd6d19fb219c822aaf6c
Lines: 218
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid
import json
import requests

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def get_stage_and_templates(stage_id=None):
    """Get a stage and its associated templates"""
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor(cursor_factory=DictCursor)
    
    try:
        # List stages if no ID provided
        if not stage_id:
            cursor.execute("""
                SELECT stage_id, stage_name, business_id, 
                       stage_selection_template_id, data_extraction_template_id, response_generation_template_id 
                FROM stages 
                WHERE stage_selection_template_id IS NOT NULL
                   OR data_extraction_template_id IS NOT NULL
                   OR response_generation_template_id IS NOT NULL
                LIMIT 10
            """)
            
            stages = cursor.fetchall()
            if not stages:
                print("No stages with templates found")
                return None
                
            print("\nAvailable stages:")
            for i, stage in enumerate(stages, 1):
                print(f"{i}. {stage['stage_name']} ({stage['stage_id']})")
                
            choice = input("\nSelect a stage (1-10): ")
            try:
                index = int(choice) - 1
                if 0 <= index < len(stages):
                    stage_id = stages[index]['stage_id']
                else:
                    print("Invalid selection")
                    return None
            except ValueError:
                print("Invalid input")
                return None
        
        # Get stage details
        cursor.execute("""
            SELECT *
            FROM stages
            WHERE stage_id = %s
        """, (stage_id,))
        
        stage = cursor.fetchone()
        if not stage:
            print(f"Stage {stage_id} not found")
            return None
            
        # Get template details
        template_ids = []
        template_mappings = {}
        
        if stage['stage_selection_template_id']:
            template_ids.append(stage['stage_selection_template_id'])
            template_mappings[stage['stage_selection_template_id']] = 'stage_selection_config'
            
        if stage['data_extraction_template_id']:
            template_ids.append(stage['data_extraction_template_id'])
            template_mappings[stage['data_extraction_template_id']] = 'data_extraction_config'
            
        if stage['response_generation_template_id']:
            template_ids.append(stage['response_generation_template_id'])
            template_mappings[stage['response_generation_template_id']] = 'response_generation_config'
            
        if not template_ids:
            print(f"Stage {stage_id} has no associated templates")
            return None
            
        # Get template content
        placeholders = ', '.join(['%s'] * len(template_ids))
        cursor.execute(f"""
            SELECT template_id, template_name, template_text
            FROM prompt_templates
            WHERE template_id IN ({placeholders})
        """, template_ids)
        
        templates = cursor.fetchall()
        templates_dict = {t['template_id']: t for t in templates}
        
        # Get business API key
        cursor.execute("""
            SELECT api_key 
            FROM businesses
            WHERE business_id = %s
        """, (stage['business_id'],))
        
        business = cursor.fetchone()
        api_key = business['api_key'] if business else None
        
        result = {
            'stage': dict(stage),
            'api_key': api_key,
            'templates': templates_dict,
            'template_mappings': template_mappings
        }
        
        return result
        
    finally:
        conn.close()

def simulate_frontend_update(stage_data, api_port=5000):
    """Simulate a frontend request to update a stage with templates"""
    stage = stage_data['stage']
    templates = stage_data['templates']
    template_mappings = stage_data['template_mappings']
    api_key = stage_data['api_key']
    
    if not api_key:
        print("No API key available for this business")
        return
    
    # Create update payload that represents frontend form submission
    update_data = {
        'business_id': stage['business_id'],
        'stage_name': stage['stage_name'],
        'stage_description': stage['stage_description'],
        'stage_type': stage['stage_type'],
        'agent_id': stage['agent_id']
    }
    
    # Add template configs
    for template_id, config_field in template_mappings.items():
        if template_id in templates:
            template = templates[template_id]
            # Add a unique marker to the template text to verify update
            new_text = template['template_text'] + f"\n\n# Frontend update test {uuid.uuid4()}"
            
            update_data[config_field] = {
                'template_text': new_text,
                'template_id': template_id
            }
    
    print(f"\nUpdate payload prepared:")
    print(json.dumps(update_data, indent=2))
    
    # Make API request
    try:
        url = f"http://localhost:{api_port}/stages/{stage['stage_id']}"
        print(f"\nSending PUT request to: {url}")
        
        headers = {
            'Content-Type': 'application/json',
            'Cookie': f'businessApiKey={api_key}'
        }
        
        response = requests.put(
            url,
            data=json.dumps(update_data),
            headers=headers
        )
        
        print(f"Response status: {response.status_code}")
        print(f"Response body: {response.text}")
        
        if response.status_code == 200:
            print("\nVerifying template updates in database...")
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor(cursor_factory=DictCursor)
            
            for template_id in templates:
                cursor.execute("""
                    SELECT template_text
                    FROM prompt_templates
                    WHERE template_id = %s
                """, (template_id,))
                
                updated = cursor.fetchone()
                if updated and "# Frontend update test" in updated['template_text']:
                    print(f"Template {template_id} successfully updated ✓")
                else:
                    print(f"Template {template_id} update failed ✗")
                    
            conn.close()
        
    except Exception as e:
        print(f"Error making API request: {str(e)}")

def main():
    print("Frontend Update Simulation Tool")
    print("===============================")
    
    # Get stage and template data
    stage_data = get_stage_and_templates()
    if not stage_data:
        return
        
    # Ask for API port
    port_input = input("\nEnter API port (default: 5000): ")
    api_port = int(port_input) if port_input.isdigit() else 5000
    
    # Simulate update
    simulate_frontend_update(stage_data, api_port)

if __name__ == "__main__":
    main()

================================================================================
File: test_update_template.py
Path: .\backend\test_update_template.py
Size: 8189
Modified: 2025-05-02T10:52:19.809758
Created: 2025-04-03T20:56:13.760004
Hash: 632d8b5b4f60de3b16ba6875cc2dd2a989b739798648235367331106e9fe29d0
Lines: 240
================================================================================
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid
import requests
import json

load_dotenv()

# Database configuration from environment variables
DB_CONFIG = {
    "dbname": os.environ.get("DB_NAME", "icmp_db"),
    "user": os.environ.get("DB_USER", "icmp_user"),
    "password": os.environ.get("DB_PASSWORD"),
    "host": os.environ.get("DB_HOST", "localhost"),
    "port": os.environ.get("DB_PORT", "5432")
}

def get_test_stage():
    """Find an existing stage to use for testing"""
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor(cursor_factory=DictCursor)
    
    try:
        # Find a stage with associated templates
        cursor.execute("""
            SELECT 
                s.stage_id, s.business_id, s.stage_name,
                s.stage_selection_template_id, s.data_extraction_template_id, s.response_generation_template_id
            FROM stages s
            WHERE s.stage_selection_template_id IS NOT NULL
            LIMIT 1
        """)
        
        stage = cursor.fetchone()
        if not stage:
            print("No suitable stage found for testing")
            return None
        
        print(f"Found stage: {stage['stage_id']}, name: {stage['stage_name']}")
        
        # Get API key for this business
        cursor.execute("SELECT api_key FROM businesses WHERE business_id = %s", (stage['business_id'],))
        business = cursor.fetchone()
        
        if not business:
            print(f"No business found with ID {stage['business_id']}")
            return None
        
        # Get template details
        template_ids = [
            stage['stage_selection_template_id'],
            stage['data_extraction_template_id'],
            stage['response_generation_template_id']
        ]
        
        template_ids = [tid for tid in template_ids if tid]
        if not template_ids:
            print("No template IDs found for this stage")
            return None
        
        # Get template details
        placeholders = ', '.join(['%s'] * len(template_ids))
        cursor.execute(f"""
            SELECT template_id, template_name, template_text
            FROM prompt_templates
            WHERE template_id IN ({placeholders})
        """, template_ids)
        
        templates = cursor.fetchall()
        
        return {
            'stage_id': stage['stage_id'],
            'business_id': stage['business_id'],
            'api_key': business['api_key'],
            'stage_name': stage['stage_name'],
            'templates': [
                {'id': t['template_id'], 'name': t['template_name'], 'text': t['template_text']} 
                for t in templates
            ]
        }
    finally:
        conn.close()

def update_template_via_api(stage_data):
    """Update a template using the API"""
    api_url = 'http://localhost:8000'  # Change if using a different host/port
    
    stage_id = stage_data['stage_id']
    api_key = stage_data['api_key']
    
    # Prepare update data
    template = stage_data['templates'][0]  # Use the first template
    new_text = template['text'] + "\n\n# This is a test update " + str(uuid.uuid4())
    
    # Determine which config field to use
    cursor = psycopg2.connect(**DB_CONFIG).cursor(cursor_factory=DictCursor)
    cursor.execute("""
        SELECT 
            CASE 
                WHEN stage_selection_template_id = %s THEN 'stage_selection_config'
                WHEN data_extraction_template_id = %s THEN 'data_extraction_config'
                WHEN response_generation_template_id = %s THEN 'response_generation_config'
                ELSE NULL
            END as config_field
        FROM stages 
        WHERE stage_id = %s
    """, (template['id'], template['id'], template['id'], stage_id))
    
    result = cursor.fetchone()
    config_field = result[0] if result else 'stage_selection_config'
    
    # Create update payload
    update_data = {
        'business_id': stage_data['business_id'],
        'stage_name': stage_data['stage_name'] + ' (updated)',
        config_field: {
            'template_text': new_text
        }
    }
    
    print(f"Updating stage {stage_id} with data: {json.dumps(update_data, indent=2)}")
    
    # Make API request
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'businessApiKey={api_key}'
    }
    
    response = requests.put(
        f"{api_url}/stages/{stage_id}",
        data=json.dumps(update_data),
        headers=headers
    )
    
    print(f"API Response: {response.status_code}")
    print(response.text)
    
    # Check if update was successful
    if response.status_code == 200:
        print("Template update successful!")
        
        # Verify update in database
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor(cursor_factory=DictCursor)
        cursor.execute("""
            SELECT template_text FROM prompt_templates
            WHERE template_id = %s
        """, (template['id'],))
        
        updated_template = cursor.fetchone()
        if updated_template and updated_template['template_text'] == new_text:
            print("Database verification successful - template text was updated")
        else:
            print("Database verification failed - template text was not updated")
            if updated_template:
                print(f"Current text: {updated_template['template_text'][:100]}...")
        
        conn.close()
    else:
        print("Template update failed!")

def update_template_directly():
    """Update a template directly in the database"""
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor(cursor_factory=DictCursor)
    
    try:
        # Find a template
        cursor.execute("SELECT template_id, template_name, template_text FROM prompt_templates LIMIT 1")
        template = cursor.fetchone()
        
        if not template:
            print("No templates found in database")
            return
        
        # Update the template
        template_id = template['template_id']
        new_text = template['template_text'] + "\n\n# This is a direct database update " + str(uuid.uuid4())
        
        cursor.execute("""
            UPDATE prompt_templates
            SET template_text = %s
            WHERE template_id = %s
        """, (new_text, template_id))
        
        conn.commit()
        
        # Verify update
        cursor.execute("SELECT template_text FROM prompt_templates WHERE template_id = %s", (template_id,))
        updated = cursor.fetchone()
        
        if updated and updated['template_text'] == new_text:
            print(f"Direct database update successful for template {template_id}")
        else:
            print(f"Direct database update failed for template {template_id}")
    finally:
        conn.close()

def main():
    print("Template Update Test Tool")
    print("========================")
    
    # Check if prompt_templates table exists
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_name = 'prompt_templates'
        );
    """)
    
    if not cursor.fetchone()[0]:
        print("prompt_templates table does not exist in the database")
        conn.close()
        return
    
    conn.close()
    
    print("\n1. Test API Update")
    print("2. Test Direct Database Update")
    print("3. Run Both Tests")
    
    choice = input("\nSelect a test to run (1-3): ")
    
    if choice in ('1', '3'):
        print("\nRunning API Update Test...")
        stage_data = get_test_stage()
        if stage_data:
            update_template_via_api(stage_data)
    
    if choice in ('2', '3'):
        print("\nRunning Direct Database Update Test...")
        update_template_directly()

if __name__ == "__main__":
    main()

================================================================================
File: update_templates.py
Path: .\backend\update_templates.py
Size: 4078
Modified: 2025-05-02T10:52:19.809758
Created: 2025-04-10T13:50:52.020644
Hash: 1ceba5ce4509d78468f1fe9fcf78613899f0ef475af981daf196baa64dc80492
Lines: 90
================================================================================
from db import get_db_connection, release_db_connection
import logging
import uuid

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

def main():
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # First, find if default templates exist
        cursor.execute("""
            SELECT template_type, COUNT(*) 
            FROM templates 
            WHERE template_type IN ('default_stage_selection', 'default_data_extraction', 'default_response_generation')
            GROUP BY template_type
        """)
        
        existing_types = {row[0]: row[1] for row in cursor.fetchall()}
        log.info(f"Found existing default templates: {existing_types}")
        
        # Check for business ID - we need it to create templates
        cursor.execute("SELECT business_id FROM businesses LIMIT 1")
        business_row = cursor.fetchone()
        
        if not business_row:
            log.error("No business found in database. Can't create default templates.")
            return
            
        business_id = business_row[0]
        log.info(f"Using business ID: {business_id}")
        
        # Create missing default templates
        if 'default_stage_selection' not in existing_types:
            selection_template_id = str(uuid.uuid4())
            cursor.execute("""
                INSERT INTO templates (template_id, business_id, template_name, template_type, content, system_prompt)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (selection_template_id, business_id, "Default Selection Template", "default_stage_selection", 
                  "Process this message: {{message_content}}", "You are a helpful assistant."))
            log.info(f"Created missing default_stage_selection template: {selection_template_id}")
        
        if 'default_data_extraction' not in existing_types:
            extraction_template_id = str(uuid.uuid4())
            cursor.execute("""
                INSERT INTO templates (template_id, business_id, template_name, template_type, content, system_prompt)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (extraction_template_id, business_id, "Default Extraction Template", "default_data_extraction",
                  "Extract key information from: {{message_content}}", "Extract relevant information."))
            log.info(f"Created missing default_data_extraction template: {extraction_template_id}")
        
        if 'default_response_generation' not in existing_types:
            response_template_id = str(uuid.uuid4())
            cursor.execute("""
                INSERT INTO templates (template_id, business_id, template_name, template_type, content, system_prompt)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (response_template_id, business_id, "Default Response Template", "default_response_generation",
                  "Generate a response to: {{message_content}}", "Generate a helpful response."))
            log.info(f"Created missing default_response_generation template: {response_template_id}")
        
        # Get all templates again to verify
        cursor.execute("""
            SELECT template_id, template_name, template_type 
            FROM templates 
            WHERE template_type LIKE 'default_%'
        """)
        
        templates = cursor.fetchall()
        
        print('Default templates:')
        for template in templates:
            print(f'{template[0]}: {template[1]} - {template[2]}')
        
        conn.commit()
        log.info(f"Verified {len(templates)} default templates are in the database")
        
    except Exception as e:
        if conn:
            conn.rollback()
        log.error(f"Error updating templates: {str(e)}")
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    main()

================================================================================
File: update_template_types.py
Path: .\backend\update_template_types.py
Size: 2455
Modified: 2025-05-02T10:52:19.809758
Created: 2025-04-10T13:41:37.337654
Hash: c5068e8c3928428b36815298ab1da8e8104fe89d1d758e51b08b0a17d4947f28
Lines: 79
================================================================================
#!/usr/bin/env python
# backend/update_template_types.py
"""
Script to update template types in the database.
This will add the 'default_' prefix to templates that should have it.
"""

import logging
import sys
import os

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log = logging.getLogger(__name__)

# Import from parent directory
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from backend.db import get_db_connection, release_db_connection

def update_template_types():
    """Update template types to include the 'default_' prefix for default templates."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Find templates to update
        cursor.execute("""
            SELECT template_id, template_name, template_type
            FROM templates
            WHERE template_name LIKE 'Default%'
              AND NOT template_type LIKE 'default_%'
        """)
        
        templates_to_update = cursor.fetchall()
        if not templates_to_update:
            log.info("No templates found that need updating.")
            return

        log.info(f"Found {len(templates_to_update)} templates to update.")
        
        # Update each template
        for template_id, template_name, template_type in templates_to_update:
            new_type = f"default_{template_type}"
            
            cursor.execute("""
                UPDATE templates
                SET template_type = %s
                WHERE template_id = %s
            """, (new_type, template_id))
            
            log.info(f"Updated template '{template_name}' (ID: {template_id}): {template_type} -> {new_type}")
        
        conn.commit()
        log.info("Successfully updated all template types.")
        
    except Exception as e:
        if conn:
            conn.rollback()
        log.error(f"Error updating template types: {str(e)}")
        raise
    finally:
        if conn:
            release_db_connection(conn)

def main():
    """Run the script."""
    try:
        update_template_types()
        log.info("Script completed successfully.")
    except Exception as e:
        log.error(f"Script failed: {str(e)}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()

================================================================================
File: utils.py
Path: .\backend\utils.py
Size: 924
Modified: 2025-05-02T10:52:19.817944
Created: 2025-04-06T23:26:35.896014
Hash: ee3fa93ea4b2c96825508d3b3b79c894f2c1eb804b7796d10a77539a114d2bd9
Lines: 36
================================================================================
"""
Common utilities for the ICMP API.
"""
import re
import uuid
import logging

log = logging.getLogger(__name__)

def is_valid_uuid(value):
    """Check if a string is a valid UUID."""
    if not value:
        return False
        
    try:
        uuid_obj = uuid.UUID(str(value))
        return str(uuid_obj) == str(value)
    except (ValueError, AttributeError, TypeError):
        return False
        
def log_request_info(request):
    """Log details about an incoming request."""
    log.info({
        "method": request.method,
        "path": request.path,
        "remote_addr": request.remote_addr,
        "headers": dict(request.headers)
    })
    
    # Log other useful information if available
    if request.args:
        log.info(f"Request args: {request.args}")
    if request.cookies:
        log.info(f"Request cookies: {request.cookies}")
        
    return True

================================================================================
File: whatsapp.py
Path: .\backend\whatsapp.py
Size: 2781
Modified: 2025-05-02T10:52:19.817944
Created: 2025-04-25T18:48:00.925225
Hash: 7d0037a0595fd1b44d07422c04dbabe1c0f9e293f6b9581eb4efda9648b815d6
Lines: 75
================================================================================
from flask import Flask, request, jsonify
import os
import hmac
import hashlib
import json
import requests
from functools import wraps

# WhatsApp API credentials
WHATSAPP_TOKEN = os.getenv('WHATSAPP_TOKEN')
WHATSAPP_PHONE_NUMBER_ID = os.getenv('WHATSAPP_PHONE_NUMBER_ID')
WHATSAPP_VERIFY_TOKEN = os.getenv('WHATSAPP_VERIFY_TOKEN')

def verify_whatsapp_token(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.method == 'GET':
            token_sent = request.args.get('hub.verify_token')
            if token_sent == WHATSAPP_VERIFY_TOKEN:
                return request.args.get('hub.challenge')
            return 'Invalid verification token'
        return f(*args, **kwargs)
    return decorated_function

def handle_whatsapp_message(sender_id, message):
    """Handle incoming messages from WhatsApp"""
    # Your message processing logic here
    response = {
        'messaging_product': 'whatsapp',
        'to': sender_id,
        'type': 'text',
        'text': {'body': f"Received: {message}"}
    }
    return response

def send_whatsapp_message(recipient_id, response):
    """Send message to WhatsApp"""
    url = f"https://graph.facebook.com/v18.0/{WHATSAPP_PHONE_NUMBER_ID}/messages"
    
    headers = {
        'Authorization': f'Bearer {WHATSAPP_TOKEN}',
        'Content-Type': 'application/json'
    }
    
    try:
        result = requests.post(url, headers=headers, json=response)
        return result.json()
    except Exception as e:
        print(f"Error sending WhatsApp message: {e}")
        return None

def setup_whatsapp_routes(app):
    @app.route('/whatsapp-webhook', methods=['GET', 'POST'])
    @verify_whatsapp_token
    def whatsapp_webhook():
        if request.method == 'POST':
            output = request.get_json()
            
            # Handle WhatsApp message
            if 'entry' in output:
                for entry in output['entry']:
                    for change in entry.get('changes', []):
                        if 'value' in change:
                            value = change['value']
                            if 'messages' in value:
                                for message in value['messages']:
                                    if message['type'] == 'text':
                                        sender_id = message['from']
                                        message_text = message['text']['body']
                                        response = handle_whatsapp_message(sender_id, message_text)
                                        send_whatsapp_message(sender_id, response)
            
            return jsonify({'status': 'success'})
        
        return "WhatsApp Webhook Setup"

================================================================================
File: __init__.py
Path: .\backend\__init__.py
Size: 256
Modified: 2025-05-02T10:52:19.834238
Created: 2025-04-14T18:17:50.404589
Hash: 8940bfccf6fc00880f818770f63bd28e380eb43950fdc7674b44776025ac7f72
Lines: 8
================================================================================
"""
ICMP Events API - Backend Package

This package contains the backend implementation of the ICMP Events API,
including the Flask application, database operations, and various services.
"""

# This file makes the backend directory a Python package

================================================================================
File: llm_service.py
Path: .\backend\ai\llm_service.py
Size: 16033
Modified: 2025-05-05T00:50:12.852492
Created: 2025-04-09T02:16:21.016247
Hash: 068e4e0a5a4dbace482671aac1f3cd0bcf92a1ad361c015a4ff19cef74f67ac4
Lines: 331
================================================================================
"""
LLM Service for handling language model interactions.

This module provides functionality for interacting with language models,
including generating responses, managing conversations, and handling
various types of LLM calls.
"""

import logging
import json
import os
import uuid
from typing import Dict, Any, Optional, List
from datetime import datetime
from openai import OpenAI
from backend.db import get_db_connection, release_db_connection, CONNECTION_POOL

log = logging.getLogger(__name__)

class LLMService:
    """
    Service for generating responses using language models.
    
    Provides methods for generating responses using various language models,
    with support for different agents and conversation contexts.
    """
    
    def __init__(self, db_pool=None, api_key: Optional[str] = None):
        """
        Initialize the LLM service.
        
        Args:
            db_pool: Database connection pool
            api_key: Optional API key for the language model service
        """
        self.api_key = api_key or os.environ.get('OPENAI_API_KEY')
        if not self.api_key:
            log.warning("No API key provided for LLM service")
        else:
            self.client = OpenAI(api_key=self.api_key)
        # Store for conversation histories - only used for response generation
        self._conversation_store: Dict[str, List[Dict[str, str]]] = {}
        
        # Initialize database connection pool
        self.db_pool = db_pool or CONNECTION_POOL
        log.info("LLMService initialized with database connection pool")
        
        # Log database connection pool status
        if self.db_pool:
            try:
                conn = self.db_pool.getconn()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("SELECT 1")
                    result = cursor.fetchone()
                    if result and result[0] == 1:
                        log.info("Database connection pool is working correctly")
                    else:
                        log.error("Database connection pool test query failed")
                    self.db_pool.putconn(conn)
                else:
                    log.error("Failed to get connection from pool during initialization")
            except Exception as e:
                log.error(f"Error testing database connection pool: {str(e)}", exc_info=True)
        else:
            log.warning("No database connection pool available")
    
    def _save_llm_call(self, business_id: str, input_text: str, response: str, 
                      system_prompt: str, call_type: str, conversation_id: str = None,
                      llm_call_id: Optional[str] = None) -> None:
        """
        Save an LLM call to the database.
        
        Args:
            business_id: UUID of the business
            input_text: Input text sent to the LLM
            response: Response received from the LLM
            system_prompt: System prompt used for the call
            call_type: Type of call (e.g., 'intent', 'extraction', 'response')
            conversation_id: UUID of the conversation (optional)
            llm_call_id: Optional LLM call ID to use for tracking (if provided, will be used for all calls in the conversation)
        """
        # Validate required fields
        if not business_id:
            log.error("Cannot save LLM call: business_id is required")
            return
            
        # Clean up input_text if it's "[Missing: message]"
        if input_text == "[Missing: message]":
            input_text = "No input text provided"
            log.warning("Input text was [Missing: message], using default text")
            
        if not input_text:
            input_text = "Empty input"
            log.warning("Input text was empty, using default text")
            
        if not response:
            log.error("Cannot save LLM call: response is required")
            return
            
        conn = None
        cursor = None
        try:
            log.info(f"Saving LLM call: type={call_type}, conversation_id={conversation_id}, llm_call_id={llm_call_id}")
            log.debug(f"Input text: {input_text[:100]}...")  # Log first 100 chars of input
            log.debug(f"Response: {response[:100]}...")  # Log first 100 chars of response
            
            conn = get_db_connection()
            if not conn:
                log.error("Failed to get database connection")
                return
                
            cursor = conn.cursor()
            
            # Always generate a new call_id for each LLM call
            call_id = str(uuid.uuid4())
            log.info(f"Generated new call_id for LLM call: {call_id}")
            
            # If conversation_id is provided, update the conversation's llm_call_id
            # This is used for tracking purposes but doesn't affect the individual call IDs
            # Note: This is now managed in the message_handler to prevent reusing the same llm_call_id
            
            # Insert new record with the unique call_id
            cursor.execute(
                """
                INSERT INTO llm_calls (
                    call_id, business_id, input_text, response, 
                    system_prompt, call_type, created_at
                )
                VALUES (%s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP)
                """,
                (call_id, business_id, input_text, response, system_prompt, call_type)
            )
            log.info(f"Created new LLM call record with call_id: {call_id}")
            
            # Commit all changes in a single transaction
            conn.commit()
            log.info(f"Successfully saved LLM call with call_id: {call_id}")
            log.info(f"Saved LLM call with call_type={call_type}, conversation_id={conversation_id}")
                
        except Exception as e:
            log.error(f"Error saving LLM call: {str(e)}", exc_info=True)
            if conn:
                try:
                    conn.rollback()
                except Exception as rollback_error:
                    log.error(f"Error rolling back transaction: {str(rollback_error)}")
        finally:
            if cursor:
                try:
                    cursor.close()
                except Exception as e:
                    log.error(f"Error closing cursor: {str(e)}")
            if conn:
                try:
                    release_db_connection(conn)
                except Exception as e:
                    log.error(f"Error releasing connection: {str(e)}")
    
    def generate_response(self, input_text: str, system_prompt: str = "", 
                         conversation_id: Optional[str] = None,
                         agent_id: Optional[str] = None,
                         call_type: str = "response",
                         available_stages: Optional[List[str]] = None,
                         business_id: Optional[str] = None,
                         llm_call_id: Optional[str] = None) -> str:
        """
        Generate a response using the OpenAI language model.
        
        Args:
            input_text: The input text to generate a response for
            system_prompt: Optional system prompt to guide the model
            conversation_id: Optional conversation ID for context
            agent_id: Optional agent ID to use for response generation
            call_type: Type of call - "intent", "extraction", or "response"
            available_stages: List of available stage names for intent detection
            business_id: UUID of the business (required for saving calls)
            llm_call_id: Optional LLM call ID to use for tracking (if provided, will be used for all calls in the conversation)
            
        Returns:
            The generated response text
        """
        try:
            # Log the request
            log.info(f"Generating {call_type} response for conversation {conversation_id}, agent {agent_id}")
            
            if not self.api_key:
                log.error("No OpenAI API key available")
                return "Error: OpenAI API key not configured"
            
            # Prepare the messages for the API
            messages = []
            
            # Add system prompt if provided
            if system_prompt:
                messages.append({"role": "system", "content": system_prompt})
            else:
                # Default system prompts based on call type
                if call_type == "intent":
                    intent_prompt = (
                        "You are a stage classifier. Your task is to select ONE stage name from the available stages list "
                        "that best matches the user's message. You must ONLY respond with the exact stage name - no other text. "
                        "If unsure, choose 'Default Conversation Stage'."
                    )
                    messages.append({"role": "system", "content": intent_prompt})
                elif call_type == "extraction":
                    messages.append({"role": "system", "content": "You are a data extractor. Extract key information from the input in a structured format."})
                else:
                    messages.append({"role": "system", "content": "You are a helpful assistant."})
            
            # Only include conversation history for response generation
            if call_type == "response" and conversation_id:
                # Fetch conversation history from database
                conn = self.db_pool.getconn()
                try:
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT message_content, sender_type = 'ai' as is_from_ai
                        FROM messages
                        WHERE conversation_id = %s
                        ORDER BY created_at ASC
                        LIMIT 10
                    """, (conversation_id,))
                    
                    history = cursor.fetchall()
                    for msg in history:
                        role = "assistant" if msg[1] else "user"
                        messages.append({"role": role, "content": msg[0]})
                    
                    log.info(f"Included {len(history)} messages from conversation history for {conversation_id}")
                finally:
                    self.db_pool.putconn(conn)
            
            # For intent detection, format the input to include available stages
            if call_type == "intent" and available_stages:
                formatted_input = (
                    f"Available stages:\n"
                    f"{', '.join(available_stages)}\n\n"
                    f"User message: {input_text}\n\n"
                    f"Select exactly one stage name from the above list."
                )
                messages.append({"role": "user", "content": formatted_input})
            else:
                # Add the current user message as is for other call types
                messages.append({"role": "user", "content": input_text})
            
            # Set temperature based on call type
            temperature = 0.0 if call_type == "intent" else 0.3 if call_type == "extraction" else 0.7
            
            # Call the OpenAI API
            log.info(f"Calling OpenAI API for {call_type} with temperature {temperature}")
            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo",  # You can adjust to gpt-4 or other models
                messages=messages,
                temperature=temperature,  # Lower temperature for more deterministic responses
                max_tokens=500
            )
            
            # Extract the response text
            assistant_message = response.choices[0].message.content
            log.info(f"Received response from OpenAI API for {call_type} (length: {len(assistant_message)})")
            
            # Save the call to the database if business_id is available
            if business_id:
                try:
                    # If business_id is not provided but conversation_id is, try to get business_id from the conversation
                    if not business_id and conversation_id:
                        conn = self.db_pool.getconn()
                        try:
                            cursor = conn.cursor()
                            cursor.execute(
                                """
                                SELECT business_id FROM conversations WHERE conversation_id = %s
                                """,
                                (conversation_id,)
                            )
                            result = cursor.fetchone()
                            if result and result[0]:
                                business_id = result[0]
                                log.info(f"Retrieved business_id {business_id} from conversation {conversation_id}")
                        finally:
                            self.db_pool.putconn(conn)
                    
                    if business_id:
                        # Always save the LLM call with a unique call_id
                        self._save_llm_call(
                            business_id=business_id,
                            input_text=input_text,
                            response=assistant_message,
                            system_prompt=system_prompt,
                            call_type=call_type,
                            conversation_id=conversation_id,
                            llm_call_id=llm_call_id
                        )
                        log.info(f"Saved LLM call with call_type={call_type}, conversation_id={conversation_id}")
                    else:
                        log.warning("Could not determine business_id for saving LLM call")
                except Exception as e:
                    log.error(f"Failed to save LLM call: {str(e)}", exc_info=True)
                    # Continue execution even if saving fails
            else:
                log.warning(f"Not saving LLM call: business_id is required but not provided")
            
            # For intent detection, ensure we only return the stage name
            if call_type == "intent":
                # Clean up the response to only include the stage name
                assistant_message = assistant_message.strip().split('\n')[0].strip()
                # Remove any common prefixes/suffixes that might be added
                assistant_message = assistant_message.replace('Stage:', '').replace('stage:', '').strip()
                assistant_message = assistant_message.split('(')[0].strip()  # Remove confidence levels if present
                
                # Validate the response is one of the available stages
                if available_stages and assistant_message not in available_stages:
                    assistant_message = "Default Conversation Stage"
            
            return assistant_message
                
        except Exception as e:
            log.error(f"Error generating response: {str(e)}", exc_info=True)
            return f"I'm sorry, I encountered an error: {str(e)}"
    
    def clear_conversation(self, conversation_id: str) -> None:
        """
        Clear the conversation history for a given conversation ID.
        
        Args:
            conversation_id: The ID of the conversation to clear
        """
        if conversation_id in self._conversation_store:
            del self._conversation_store[conversation_id]
            log.info(f"Cleared conversation history for {conversation_id}")

================================================================================
File: __init__.py
Path: .\backend\ai\__init__.py
Size: 48
Modified: 2025-05-02T10:52:19.850685
Created: 2025-04-12T00:56:19.259683
Hash: 1ab6a15e4aab552f1244c4eb4d6bc0065fdb4818837ec3925298c750d99f7e9b
Lines: 3
================================================================================
"""
AI module for language model services.
"""

================================================================================
File: __init__.py
Path: .\backend\database\__init__.py
Size: 34
Modified: 2025-05-10T13:43:06.866368
Created: 2025-05-10T13:43:03.665639
Hash: e2a48adf40c2c693cfca47d9d32764952e20d505eab7e473a3480ca555b61558
Lines: 1
================================================================================
# Database package initialization 

================================================================================
File: connection_manager.py
Path: .\backend\db\connection_manager.py
Size: 3848
Modified: 2025-05-04T21:01:16.756000
Created: 2025-05-04T19:48:58.368625
Hash: 2c5049bdcae9ad932fcad1f32c1e26f591424f4bddff0d763e3e4a6ae9dd83e9
Lines: 113
================================================================================
"""
Connection manager for handling database connections with retry logic.

This module provides a robust way to manage database connections,
including automatic retries and proper error handling.
"""

import logging
import time
from typing import Optional, Callable, Any
import psycopg2
from psycopg2.extensions import connection
from contextlib import contextmanager

log = logging.getLogger(__name__)

class ConnectionManager:
    """Manages database connections with retry logic and error handling."""
    
    def __init__(self, db_pool, max_retries: int = 3, retry_delay: float = 0.5):
        """
        Initialize the connection manager.
        
        Args:
            db_pool: Database connection pool
            max_retries: Maximum number of retry attempts
            retry_delay: Delay between retries in seconds
        """
        self.db_pool = db_pool
        self.max_retries = max_retries
        self.retry_delay = retry_delay
    
    @contextmanager
    def get_connection(self) -> connection:
        """
        Get a database connection with retry logic.
        
        Yields:
            A database connection
            
        Raises:
            Exception if all retry attempts fail
        """
        conn = None
        last_error = None
        
        try:
            for attempt in range(self.max_retries):
                try:
                    conn = self.db_pool.getconn()
                    if conn:
                        # Test the connection
                        with conn.cursor() as cur:
                            cur.execute("SELECT 1")
                            if cur.fetchone()[0] == 1:
                                try:
                                    yield conn
                                    return
                                finally:
                                    if conn:
                                        self.release_connection(conn)
                                        conn = None
                
                except Exception as e:
                    last_error = e
                    log.warning(f"Connection attempt {attempt + 1} failed: {str(e)}")
                    if conn:
                        self.release_connection(conn)
                        conn = None
                    
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
            
            raise Exception(f"Failed to get valid database connection after {self.max_retries} attempts. Last error: {str(last_error)}")
            
        finally:
            if conn:
                self.release_connection(conn)
    
    def execute_with_retry(self, func: Callable[[connection], Any]) -> Any:
        """
        Execute a function with a database connection, with retry logic.
        
        Args:
            func: Function to execute with the connection
            
        Returns:
            Result of the function execution
            
        Raises:
            Exception if all retry attempts fail
        """
        with self.get_connection() as conn:
            return func(conn)
    
    def release_connection(self, conn: connection) -> None:
        """
        Safely release a connection back to the pool.
        
        Args:
            conn: Connection to release
        """
        if conn:
            try:
                if conn.status != psycopg2.extensions.STATUS_READY:
                    conn.rollback()
                self.db_pool.putconn(conn)
            except Exception as e:
                log.error(f"Error releasing connection: {str(e)}")
                try:
                    conn.close()
                except:
                    pass 

================================================================================
File: connection_utils.py
Path: .\backend\db\connection_utils.py
Size: 3139
Modified: 2025-05-04T20:20:15.476469
Created: 2025-05-04T20:09:18.166508
Hash: 15d2595e58632f84e993ffbfa0c75d6a39b97852d88eee1bb2b7ae8729acd2c1
Lines: 119
================================================================================
"""
Database connection utilities.

This module provides utility functions for managing database connections,
including getting and releasing connections from the pool.
"""

import logging
import psycopg2
from psycopg2.extras import DictCursor
from backend.db_config import get_db_config

log = logging.getLogger(__name__)

# Get database configuration
DB_CONFIG = get_db_config()

# Initialize connection pool
CONNECTION_POOL = None

def initialize_connection_pool():
    """
    Initialize the database connection pool.
    
    Returns:
        The initialized connection pool
    """
    global CONNECTION_POOL
    
    if not CONNECTION_POOL:
        try:
            CONNECTION_POOL = psycopg2.pool.SimpleConnectionPool(
                minconn=1,
                maxconn=10,
                **DB_CONFIG,
                cursor_factory=DictCursor
            )
            log.info("Database connection pool created successfully")
        except Exception as e:
            log.error(f"Error creating connection pool: {e}")
            raise
    
    return CONNECTION_POOL

def get_db_connection():
    """
    Get a database connection from the pool.
    
    Returns:
        A database connection object
        
    Raises:
        Exception if no connection can be established
    """
    global CONNECTION_POOL
    
    if not CONNECTION_POOL:
        initialize_connection_pool()
    
    try:
        conn = CONNECTION_POOL.getconn()
        if conn:
            return conn
        raise Exception("Failed to get database connection from pool")
    except Exception as e:
        log.error(f"Error getting database connection: {e}")
        raise

def release_db_connection(conn):
    """
    Release a database connection back to the pool.
    
    Args:
        conn: The database connection to release
    """
    if conn and CONNECTION_POOL:
        try:
            if conn.status != psycopg2.extensions.STATUS_READY:
                conn.rollback()
            CONNECTION_POOL.putconn(conn)
        except Exception as e:
            log.error(f"Error releasing database connection: {e}")
            try:
                conn.close()
            except:
                pass

def execute_query(conn, query, params=None):
    """
    Execute a database query.
    
    Args:
        conn: Database connection
        query: SQL query to execute
        params: Optional parameters for the query
        
    Returns:
        Query results as a list of dictionaries
    """
    cursor = conn.cursor()
    try:
        cursor.execute(query, params)
        if cursor.description:
            columns = [desc[0] for desc in cursor.description]
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
        return None
    finally:
        cursor.close()

def get_db_pool():
    """
    Get the database connection pool.
    
    Returns:
        The database connection pool object
    """
    if not CONNECTION_POOL:
        initialize_connection_pool()
    return CONNECTION_POOL 

================================================================================
File: __init__.py
Path: .\backend\db\__init__.py
Size: 641
Modified: 2025-05-04T20:20:22.135544
Created: 2025-05-04T19:54:22.121160
Hash: 265b5d3e7f92bae1206033f9a2e2d57eadc0698848283da9ae343e0dad6892b6
Lines: 28
================================================================================
"""
Database package for managing database connections and operations.

This package provides functionality for:
- Connection pooling
- Connection management with retry logic
- Database operations
"""

from .connection_manager import ConnectionManager
from .connection_utils import (
    get_db_connection,
    release_db_connection,
    execute_query,
    get_db_pool,
    CONNECTION_POOL,
    initialize_connection_pool
)

__all__ = [
    'ConnectionManager',
    'get_db_connection',
    'release_db_connection',
    'execute_query',
    'get_db_pool',
    'CONNECTION_POOL',
    'initialize_connection_pool'
] 

================================================================================
File: ai_control_service.py
Path: .\backend\message_processing\ai_control_service.py
Size: 13152
Modified: 2025-05-02T10:52:19.850685
Created: 2025-05-02T00:43:08.861143
Hash: 7e0e17b0e54423a720c60beb6b2d8bc8e3ca2765402e03d076482d2a7087ca9b
Lines: 332
================================================================================
"""
Service for controlling AI response generation.

This module handles the logic for stopping and resuming AI responses
for specific conversations and users.
"""

import logging
from typing import Dict, Optional
from datetime import datetime, timedelta
import uuid
from backend.db import get_db_connection, release_db_connection
from datetime import timezone

log = logging.getLogger(__name__)

class AIControlService:
    """
    Service for controlling AI response generation.
    
    This service manages the state of AI response generation for conversations
    and users, allowing for fine-grained control over when AI responses are
    generated.
    """
    
    def __init__(self):
        # Default stop duration (24 hours)
        self._default_stop_duration = timedelta(hours=24)
    
    def _get_current_time(self):
        """Get current time in UTC timezone."""
        return datetime.now(timezone.utc)
    
    def stop_ai_responses(self, conversation_id: str, user_id: Optional[str] = None, 
                         duration: Optional[timedelta] = None) -> None:
        """
        Stop AI from generating responses for a conversation or user.
        
        Args:
            conversation_id: The ID of the conversation to stop (can be string or UUID)
            user_id: Optional user ID to stop responses for all their conversations (can be string or UUID)
            duration: Optional duration for the stop (defaults to 24 hours)
        """
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            
            # Calculate expiration time
            stop_time = self._get_current_time()
            expiration_time = stop_time + (duration or self._default_stop_duration)
            
            if user_id:
                # Convert to string if it's a UUID object
                user_id_str = str(user_id) if hasattr(user_id, 'hex') else user_id
                # Check if user setting exists
                cursor.execute(
                    """
                    SELECT id FROM ai_control_settings 
                    WHERE user_id = %s
                    """,
                    (user_id_str,)
                )
                if cursor.fetchone():
                    # Update existing setting
                    cursor.execute(
                        """
                        UPDATE ai_control_settings 
                        SET is_stopped = true,
                            stop_time = %s,
                            expiration_time = %s,
                            updated_at = NOW()
                        WHERE user_id = %s
                        """,
                        (stop_time, expiration_time, user_id_str)
                    )
                else:
                    # Create new setting
                    cursor.execute(
                        """
                        INSERT INTO ai_control_settings (
                            user_id, is_stopped, stop_time, expiration_time
                        )
                        VALUES (%s, true, %s, %s)
                        """,
                        (user_id_str, stop_time, expiration_time)
                    )
                log.info(f"AI responses stopped for user {user_id_str}")
            else:
                # Convert to string if it's a UUID object
                conv_id_str = str(conversation_id) if hasattr(conversation_id, 'hex') else conversation_id
                # Check if conversation setting exists
                cursor.execute(
                    """
                    SELECT id FROM ai_control_settings 
                    WHERE conversation_id = %s
                    """,
                    (conv_id_str,)
                )
                if cursor.fetchone():
                    # Update existing setting
                    cursor.execute(
                        """
                        UPDATE ai_control_settings 
                        SET is_stopped = true,
                            stop_time = %s,
                            expiration_time = %s,
                            updated_at = NOW()
                        WHERE conversation_id = %s
                        """,
                        (stop_time, expiration_time, conv_id_str)
                    )
                else:
                    # Create new setting
                    cursor.execute(
                        """
                        INSERT INTO ai_control_settings (
                            conversation_id, is_stopped, stop_time, expiration_time
                        )
                        VALUES (%s, true, %s, %s)
                        """,
                        (conv_id_str, stop_time, expiration_time)
                    )
                log.info(f"AI responses stopped for conversation {conv_id_str}")
            
            conn.commit()
            
        except Exception as e:
            log.error(f"Error stopping AI responses: {str(e)}")
            if conn:
                conn.rollback()
            raise
        finally:
            if conn:
                release_db_connection(conn)
    
    def resume_ai_responses(self, conversation_id: str, user_id: Optional[str] = None) -> None:
        """
        Resume AI response generation for a conversation or user.
        
        Args:
            conversation_id: The ID of the conversation to resume (can be string or UUID)
            user_id: Optional user ID to resume responses for all their conversations (can be string or UUID)
        """
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            
            if user_id:
                # Convert to string if it's a UUID object
                user_id_str = str(user_id) if hasattr(user_id, 'hex') else user_id
                cursor.execute(
                    """
                    UPDATE ai_control_settings 
                    SET is_stopped = false,
                        stop_time = NULL,
                        expiration_time = NULL,
                        updated_at = NOW()
                    WHERE user_id = %s
                    """,
                    (user_id_str,)
                )
                log.info(f"AI responses resumed for user {user_id_str}")
            else:
                # Convert to string if it's a UUID object
                conv_id_str = str(conversation_id) if hasattr(conversation_id, 'hex') else conversation_id
                cursor.execute(
                    """
                    UPDATE ai_control_settings 
                    SET is_stopped = false,
                        stop_time = NULL,
                        expiration_time = NULL,
                        updated_at = NOW()
                    WHERE conversation_id = %s
                    """,
                    (conv_id_str,)
                )
                log.info(f"AI responses resumed for conversation {conv_id_str}")
            
            conn.commit()
            
        except Exception as e:
            log.error(f"Error resuming AI responses: {str(e)}")
            if conn:
                conn.rollback()
            raise
        finally:
            if conn:
                release_db_connection(conn)
    
    def is_ai_stopped(self, conversation_id: str, user_id: Optional[str] = None) -> bool:
        """
        Check if AI responses are stopped for a conversation or user.
        
        Args:
            conversation_id: The ID of the conversation to check (can be string or UUID)
            user_id: Optional user ID to check (can be string or UUID)
            
        Returns:
            bool: True if AI responses are stopped, False otherwise
        """
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            
            # Check if user is stopped
            if user_id:
                # Convert to string if it's a UUID object
                user_id_str = str(user_id) if hasattr(user_id, 'hex') else user_id
                cursor.execute(
                    """
                    SELECT is_stopped, expiration_time 
                    FROM ai_control_settings 
                    WHERE user_id = %s
                    """,
                    (user_id_str,)
                )
                result = cursor.fetchone()
                if result:
                    is_stopped, expiration_time = result
                    if is_stopped and expiration_time and self._get_current_time() > expiration_time:
                        # Stop has expired, resume AI
                        self.resume_ai_responses(conversation_id, user_id)
                        return False
                    return is_stopped
            
            # Check if conversation is stopped
            # Convert to string if it's a UUID object
            conv_id_str = str(conversation_id) if hasattr(conversation_id, 'hex') else conversation_id
            cursor.execute(
                """
                SELECT is_stopped, expiration_time 
                FROM ai_control_settings 
                WHERE conversation_id = %s
                """,
                (conv_id_str,)
            )
            result = cursor.fetchone()
            if result:
                is_stopped, expiration_time = result
                if is_stopped and expiration_time and self._get_current_time() > expiration_time:
                    # Stop has expired, resume AI
                    self.resume_ai_responses(conversation_id)
                    return False
                return is_stopped
            
            return False
            
        except Exception as e:
            log.error(f"Error checking AI stop status: {str(e)}")
            return False
        finally:
            if conn:
                release_db_connection(conn)
    
    def get_stop_status(self, conversation_id: str, user_id: Optional[str] = None) -> Dict:
        """
        Get the current stop status for a conversation or user.
        
        Args:
            conversation_id: The ID of the conversation to check (can be string or UUID)
            user_id: Optional user ID to check (can be string or UUID)
            
        Returns:
            Dict: Status information including whether AI is stopped and expiration time
        """
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            
            is_stopped = self.is_ai_stopped(conversation_id, user_id)
            
            if user_id:
                # Convert to string if it's a UUID object
                user_id_str = str(user_id) if hasattr(user_id, 'hex') else user_id
                cursor.execute(
                    """
                    SELECT stop_time, expiration_time 
                    FROM ai_control_settings 
                    WHERE user_id = %s
                    """,
                    (user_id_str,)
                )
            else:
                # Convert to string if it's a UUID object
                conv_id_str = str(conversation_id) if hasattr(conversation_id, 'hex') else conversation_id
                cursor.execute(
                    """
                    SELECT stop_time, expiration_time 
                    FROM ai_control_settings 
                    WHERE conversation_id = %s
                    """,
                    (conv_id_str,)
                )
            
            result = cursor.fetchone()
            
            if result:
                stop_time, expiration_time = result
                time_remaining = expiration_time - self._get_current_time() if expiration_time else timedelta(0)
                
                return {
                    'is_stopped': is_stopped,
                    'stop_time': stop_time.isoformat() if stop_time else None,
                    'expiration_time': expiration_time.isoformat() if expiration_time else None,
                    'time_remaining_seconds': max(0, int(time_remaining.total_seconds()))
                }
            
            return {
                'is_stopped': is_stopped,
                'stop_time': None,
                'expiration_time': None,
                'time_remaining_seconds': 0
            }
            
        except Exception as e:
            log.error(f"Error getting stop status: {str(e)}")
            return {
                'is_stopped': False,
                'stop_time': None,
                'expiration_time': None,
                'time_remaining_seconds': 0
            }
        finally:
            if conn:
                release_db_connection(conn)

# Create a singleton instance of the service
ai_control_service = AIControlService()

================================================================================
File: context_service.py
Path: .\backend\message_processing\context_service.py
Size: 5715
Modified: 2025-05-02T10:52:19.867145
Created: 2025-04-09T02:13:02.606234
Hash: 40a2d0828a2f379536f81ccdc092eb311bd4bc68a9c118af6af6feeb73c3885d
Lines: 157
================================================================================
"""
Context service for message processing.

This module handles retrieving and preparing conversation context
for message processing.
"""

import logging
from typing import List, Dict, Any, Optional

log = logging.getLogger(__name__)

class ContextService:
    """Service for retrieving and managing conversation context."""
    
    @staticmethod
    def get_conversation_context(conn, business_id: str, user_id: str, 
                                 limit: int = 3) -> Dict[str, Any]:
        """
        Retrieve conversation history and context for the given business and user.
        
        Args:
            conn: Database connection
            business_id: UUID of the business
            user_id: UUID of the user
            limit: Maximum number of conversations to retrieve
            
        Returns:
            Dictionary with conversation context data
        """
        cursor = conn.cursor()
        context = {
            'conversation_history': [],
            'summary': "",
            'user_info': {},
            'business_info': {}
        }
        
        try:
            # Get recent conversations
            cursor.execute(
                """
                SELECT conversation_id 
                FROM conversations 
                WHERE business_id = %s AND user_id = %s 
                ORDER BY last_updated DESC 
                LIMIT %s
                """, 
                (business_id, user_id, limit)
            )
            conversation_ids = [row[0] for row in cursor.fetchall()]
            
            # Get messages from these conversations
            if conversation_ids:
                placeholders = ', '.join(['%s'] * len(conversation_ids))
                query = f"""
                    SELECT conversation_id, sender_type, message_content, timestamp
                    FROM messages 
                    WHERE conversation_id IN ({placeholders})
                    ORDER BY timestamp ASC
                """
                cursor.execute(query, conversation_ids)
                
                # Group messages by conversation
                conversations = {}
                for row in cursor.fetchall():
                    conv_id, sender, content, timestamp = row
                    
                    if conv_id not in conversations:
                        conversations[conv_id] = []
                        
                    conversations[conv_id].append({
                        'sender': sender,
                        'content': content,
                        'timestamp': timestamp.isoformat() if hasattr(timestamp, 'isoformat') else str(timestamp)
                    })
                
                # Add to context
                context['conversation_history'] = [
                    {'conversation_id': conv_id, 'messages': messages}
                    for conv_id, messages in conversations.items()
                ]
                
                # Generate simple summary (could be enhanced with OpenAI)
                message_count = sum(len(msgs) for msgs in conversations.values())
                user_messages = sum(1 for c in conversations.values() 
                                   for m in c if m['sender'] == 'user')
                
                context['summary'] = f"User has sent {user_messages} messages across {len(conversations)} conversations"
            
            # Get basic user info if available
            cursor.execute(
                """
                SELECT first_name, last_name, email
                FROM users WHERE user_id = %s
                """, 
                (user_id,)
            )
            user_row = cursor.fetchone()
            if user_row:
                context['user_info'] = {
                    'first_name': user_row[0],
                    'last_name': user_row[1],
                    'email': user_row[2]
                }
            
            # Get basic business info
            cursor.execute(
                """
                SELECT business_name, business_description
                FROM businesses WHERE business_id = %s
                """, 
                (business_id,)
            )
            business_row = cursor.fetchone()
            if business_row:
                context['business_info'] = {
                    'name': business_row[0],
                    'description': business_row[1]
                }
                
            return context
            
        except Exception as e:
            log.error(f"Error getting conversation context: {str(e)}")
            return context
    
    @staticmethod
    def is_new_user(conn, business_id: str, user_id: str) -> bool:
        """
        Check if this is a new user with no previous conversations.
        
        Args:
            conn: Database connection
            business_id: UUID of the business
            user_id: UUID of the user
            
        Returns:
            True if this is a new user, False otherwise
        """
        cursor = conn.cursor()
        
        try:
            cursor.execute(
                """
                SELECT COUNT(*) 
                FROM conversations 
                WHERE business_id = %s AND user_id = %s
                """, 
                (business_id, user_id)
            )
            count = cursor.fetchone()[0]
            return count == 0
            
        except Exception as e:
            log.error(f"Error checking if user is new: {str(e)}")
            return True  # Assume new user if error

================================================================================
File: data_extraction_service.py
Path: .\backend\message_processing\data_extraction_service.py
Size: 22887
Modified: 2025-05-02T10:52:19.875401
Created: 2025-04-16T11:36:00.739035
Hash: 0a1eab98f90df7916d25aeec729b319a315358f017f0a50acb883290f83a62e6
Lines: 505
================================================================================
"""
Data extraction service for processing and extracting structured data from messages.

This module provides functionality for extracting specific types of data
from user messages based on predefined patterns or LLM-based extraction.
"""

import logging
import json
import re
from typing import Dict, Any, List, Optional, Union
from datetime import datetime

from backend.ai.llm_service import LLMService
from backend.db import get_db_connection, release_db_connection

log = logging.getLogger(__name__)

class DataExtractionService:
    """
    Service for extracting structured data from messages.
    
    This service provides methods for extracting specific types of data
    from user messages based on predefined patterns or LLM-based extraction.
    """
    
    def __init__(self, db_pool, llm_service: Optional[LLMService] = None):
        """
        Initialize the data extraction service.
        
        Args:
            db_pool: Database connection pool
            llm_service: Optional LLM service for advanced extraction
        """
        self.db_pool = db_pool
        self.llm_service = llm_service
    
    def extract_data(self, conn, extraction_template_id: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract structured data from a message using a template.
        
        Args:
            conn: Database connection
            extraction_template_id: ID of the template to use for extraction
            context: Dictionary containing context data including:
                - message_content: The message to extract data from
                - business_id: ID of the business
                - user_id: ID of the user
                - conversation_id: ID of the conversation
            
        Returns:
            Dictionary containing extracted data
        """
        try:
            # Get the extraction template
            template = self._get_extraction_template(conn, extraction_template_id)
            if not template:
                log.error(f"Extraction template {extraction_template_id} not found")
                return {"error": "Extraction template not found"}
            
            # Process the template with variable substitution
            processed_template = self._process_template(
                conn, template, context['business_id'], context['user_id'], 
                context['conversation_id'], context['message_content']
            )
            
            # Extract data using the appropriate method
            if self.llm_service:
                extracted_data = self._extract_with_llm(
                    context['message_content'], processed_template, context['business_id']
                )
            else:
                extracted_data = self._extract_with_patterns(
                    context['message_content'], processed_template
                )
            
            # Check for errors immediately after extraction
            if isinstance(extracted_data, dict) and 'error' in extracted_data:
                log.warning(f"Data extraction resulted in error: {extracted_data['error']}")
                # Return the error dictionary directly, possibly adding template info if needed
                extracted_data['_template_info'] = {
                    'template_id': extraction_template_id,
                    'template_content': template.get('content', ''),
                    'system_prompt': template.get('system_prompt', ''),
                    'processed_content': processed_template.get('content', ''),
                    'processed_system_prompt': processed_template.get('system_prompt', '')
                }
                return extracted_data
            
            # Store the extracted data
            self._store_extracted_data(
                conn, context['conversation_id'], template.get('template_type', 'general'),
                extracted_data
            )
            
            # Update user information if basic_info is present
            if isinstance(extracted_data, dict) and 'basic_info' in extracted_data:
                # Ensure basic_info is also a dictionary
                basic_info = extracted_data['basic_info']
                if isinstance(basic_info, dict):
                    from .user_update_service import UserUpdateService
                    user_service = UserUpdateService()
                    
                    # Map the extracted basic info to user fields
                    user_update_data = {}
                    
                    # Map full name or first/last name
                    if 'full_name' in basic_info and basic_info['full_name']:
                        names = basic_info['full_name'].split(' ', 1)
                        user_update_data['first_name'] = names[0]
                        user_update_data['last_name'] = names[1] if len(names) > 1 else ''
                    else:
                        if 'first_name' in basic_info and basic_info['first_name']:
                            user_update_data['first_name'] = basic_info['first_name']
                        if 'last_name' in basic_info and basic_info['last_name']:
                            user_update_data['last_name'] = basic_info['last_name']
                    
                    # Update user record if we have data
                    if user_update_data:
                        try:
                            # --- Add specific logging before the call ---
                            log.info(f"Attempting to update user {context['user_id']} with data: {user_update_data!r}") 
                            user_service.update_user(context['user_id'], user_update_data) 
                            log.info(f"Successfully updated user {context['user_id']}") 
                            # ----------------------------------------------
                        except Exception as e:
                            # --- Add more verbose error logging ---
                            log.error(f"Exception caught while calling user_service.update_user for user {context['user_id']}.")
                            log.exception(f"Error details: {e!r}") # Use log.exception to include stack trace
                            # --- Store the actual caught error, not the potentially misleading string ---
                            extracted_data['update_error'] = f"Failed update: {str(e)}" 
                            # --------------------------------------------------------------------
                else:
                    log.warning(f"'basic_info' key found but is not a dictionary: {type(basic_info)}. Skipping user update.")
            
            # --- FINAL CHECK before returning --- 
            final_return_value = extracted_data
            problematic_error_string = "unterminated string literal (detected at line 67) (user_update_service.py, line 67)"

            if isinstance(final_return_value, dict) and \
               final_return_value.get("error") == problematic_error_string:
                log.critical(f"!!! Intercepted problematic error string before returning: {final_return_value}")
                # Replace the misleading error with a more generic one
                final_return_value["error"] = "Data extraction failed due to an internal error (see logs for details)."
                log.critical(f"!!! Returning modified error dict: {final_return_value}")

            return final_return_value
            # --- END FINAL CHECK ---
                
        except Exception as e:
            # Log basic info first
            log.error(f"--- Exception caught in main extract_data handler ---")
            log.error(f"Exception Type: {type(e)}")
            try:
                # Try logging the repr safely
                log.error(f"Exception Repr: {e!r}")
            except Exception as log_repr_err:
                log.error(f"!!! Failed to get repr of exception: {log_repr_err}")
            try:
                # Try logging the str safely
                error_message = str(e)
                log.error(f"Exception Str: {error_message}")
            except Exception as log_str_err:
                log.error(f"!!! Failed to get str of exception: {log_str_err}")
                error_message = "Error getting exception string representation"

            # Explicitly create the error dictionary to return
            return_error = {"error": f"extract_data failed: {error_message!r}"}
            log.error(f"Returning error dictionary from main handler: {return_error}")
            return return_error
    
    def _get_extraction_template(self, conn, template_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve an extraction template by ID.
        
        Args:
            conn: Database connection
            template_id: ID of the template
            
        Returns:
            Template data as a dictionary or None if not found
        """
        try:
            cursor = conn.cursor()
            cursor.execute(
                """
                SELECT template_id, template_name, template_type, content, 
                       system_prompt, business_id
                FROM templates
                WHERE template_id = %s
                """,
                (template_id,)
            )
            
            row = cursor.fetchone()
            if row:
                return {
                    'template_id': row[0],
                    'template_name': row[1],
                    'template_type': row[2],
                    'content': row[3],
                    'system_prompt': row[4],
                    'business_id': row[5]
                }
            
            return None
            
        except Exception as e:
            log.error(f"Error retrieving template {template_id}: {str(e)}")
            return None
    
    def _process_template(self, conn, template: Dict[str, Any], business_id: str, 
                         user_id: str, conversation_id: str, message_content: str) -> Dict[str, Any]:
        """
        Process a template with variable substitution.
        
        Args:
            conn: Database connection
            template: Template data
            business_id: ID of the business
            user_id: ID of the user
            conversation_id: ID of the conversation
            message_content: Content of the message
            
        Returns:
            Processed template with variables substituted
        """
        from .template_variables import TemplateVariableProvider
        from .template_service import TemplateService
        
        # Build context using TemplateService
        context = TemplateService.build_context(
            conn=conn,
            business_id=business_id,
            user_id=user_id,
            conversation_id=conversation_id,
            message_content=message_content
        )
        
        # Apply template using TemplateService
        processed_template = TemplateService.apply_template(template, context)
        
        return processed_template
    
    def _extract_with_llm(self, message_content: str, template: Dict[str, Any], 
                         business_id: str) -> Dict[str, Any]:
        """
        Extract data using LLM-based extraction.
        
        Args:
            message_content: The message to extract from
            template: Processed template with content and system prompt
            business_id: ID of the business
            
        Returns:
            Dictionary with extracted data
        """
        response = None # Initialize response
        try:
            # Format the system prompt to include the template content
            formatted_system_prompt = f"{template['system_prompt']}\n\nExtract the following information:\n{template['content']}"
            
            # Log the extraction request for debugging
            log.info(f"Data extraction request: Message content: '{message_content[:100]}...' (truncated)")
            log.info(f"Data extraction template content: '{template['content'][:100]}...' (truncated)")
            log.info(f"Data extraction system prompt: '{template['system_prompt'][:100]}...' (truncated)")
            
            # Call the LLM - Wrap in try/except
            try:
                response = self.llm_service.generate_response(
                    input_text=message_content,
                    system_prompt=formatted_system_prompt,
                    business_id=business_id,
                    call_type="data_extraction"
                )
                log.info(f"LLM data extraction response: '{response[:100]}...' (truncated)")
            except Exception as llm_error:
                log.error(f"LLM service call failed during data extraction: {llm_error!r}")
                return {
                    "intent": "error",
                    "message_type": "error",
                    "error": f"LLM service error: {str(llm_error)}",
                    "prompt": template.get('content', 'Error: Template not available'),
                    "response": None # No response received
                }
            
            # Check if this is a greeting message
            greeting_patterns = [
                r'^hi\b', r'^hello\b', r'^hey\b', r'^greetings\b',
                r'^good\s+(morning|afternoon|evening)\b'
            ]
            is_greeting = any(re.match(pattern, message_content.lower()) for pattern in greeting_patterns)
            
            if is_greeting:
                result = {
                    "intent": "greeting",
                    "message_type": "greeting",
                    "raw_extraction": response,
                    "prompt": template['content'],
                    "response": response
                }
                return result
            
            # Parse the response as JSON
            try:
                extracted_data = json.loads(response)
                # Add prompt and response fields if parsing succeeds
                if isinstance(extracted_data, dict):
                    extracted_data["prompt"] = template.get('content', '')
                    extracted_data["response"] = response
                # Ensure it's a dict before returning
                return extracted_data if isinstance(extracted_data, dict) else {"raw_extraction": extracted_data}
                
            except json.JSONDecodeError:
                log.warning(f"Initial JSON parsing failed for LLM response: {response[:200]}...")
                # If not valid JSON, try to extract JSON from the text
                json_match = re.search(r'\{.*\}', response, re.DOTALL)
                if json_match:
                    try:
                        extracted_data = json.loads(json_match.group(0))
                        # Add prompt and response fields
                        extracted_data["prompt"] = template['content']
                        extracted_data["response"] = response
                        return extracted_data
                    except json.JSONDecodeError:
                        log.error(f"Failed to parse JSON from LLM response: {response}")
                        return {
                            "intent": "unknown",
                            "message_type": "text",
                            "error": "LLM response was not valid JSON", # Specific error
                            "raw_extraction": response,
                            "prompt": template.get('content', ''),
                            "response": response
                        }
                else:
                    log.error(f"Failed to extract JSON from LLM response: {response}")
                    return {
                        "intent": "unknown",
                        "message_type": "text",
                        "error": "LLM response did not contain valid JSON", # Specific error
                        "raw_extraction": response,
                        "prompt": template.get('content', ''),
                        "response": response
                    }
        except Exception as e:
            # General exception handler for the whole method
            log.error(f"Unexpected error during LLM data extraction: {e!r}")
            # Safely format the error message
            error_message = repr(str(e)) # Use repr for safe representation
            return {
                "intent": "error",
                "message_type": "error",
                "error": f"Data extraction failed: {error_message}",
                "prompt": template.get('content', 'Error: Template not available'),
                "response": f"Error during extraction: {error_message}"
            }
    
    def _extract_with_patterns(self, message_content: str, template: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract data using simple pattern matching rules.
        
        Args:
            message_content: The message to extract from
            template: Processed template with content
            
        Returns:
            Dictionary with extracted data
        """
        result = {}
        
        # Simple pattern: field_name: pattern
        pattern_lines = template['content'].strip().split('\n')
        for line in pattern_lines:
            if ':' in line:
                field_name, pattern = line.split(':', 1)
                field_name = field_name.strip()
                pattern = pattern.strip()
                
                # Try to find the pattern in the message
                match = re.search(pattern, message_content, re.IGNORECASE)
                if match:
                    result[field_name] = match.group(1) if match.groups() else match.group(0)
        
        return result
    
    def _store_extracted_data(self, conn, conversation_id: str, data_type: str, 
                             extracted_data: Dict[str, Any]) -> str:
        """
        Store extracted data in the database.
        
        Args:
            conn: Database connection
            conversation_id: ID of the conversation
            data_type: Type of data extracted
            extracted_data: Data to store
            
        Returns:
            ID of the stored extraction
        """
        try:
            cursor = conn.cursor()
            
            # Get the current stage ID from the conversation
            cursor.execute(
                """
                SELECT stage_id FROM conversations WHERE conversation_id = %s
                """,
                (conversation_id,)
            )
            
            result = cursor.fetchone()
            if not result or not result['stage_id']:
                log.warning(f"No current stage found for conversation {conversation_id}")
                return None
            
            stage_id = result['stage_id']
            
            # Insert the extracted data
            cursor.execute(
                """
                INSERT INTO extracted_data 
                (conversation_id, stage_id, data_type, extracted_data, created_at)
                VALUES (%s, %s, %s, %s, %s)
                RETURNING extraction_id
                """,
                (conversation_id, stage_id, data_type, json.dumps(extracted_data), datetime.now())
            )
            
            extraction_id = cursor.fetchone()['extraction_id']
            conn.commit()
            
            return extraction_id
            
        except Exception as e:
            # --- Add detailed logging ---
            log.error(f"--- Exception caught in _store_extracted_data ---")
            log.error(f"Args: conversation_id={conversation_id!r}, data_type={data_type!r}")
            try:
                 # Try logging data safely (truncate if too long)
                 data_str = json.dumps(extracted_data)
                 log.error(f"Data attempted to store: {data_str[:200]}{'...' if len(data_str) > 200 else ''}")
            except Exception as log_data_err:
                 log.error(f"!!! Failed to serialize or log extracted_data: {log_data_err}")
            log.exception(f"Error details: {e!r}") # Log full stack trace
            # -----------------------------
            conn.rollback()
            # Still return None as before, but log details first
            return None
    
    def get_extracted_data(self, conversation_id: str, data_type: Optional[str] = None, 
                          limit: int = 10) -> List[Dict[str, Any]]:
        """
        Retrieve extracted data for a conversation.
        
        Args:
            conversation_id: ID of the conversation
            data_type: Optional filter by data type
            limit: Maximum number of records to return
            
        Returns:
            List of extracted data records
        """
        conn = self.db_pool.getconn()
        try:
            cursor = conn.cursor()
            
            query = """
                SELECT ed.extraction_id, ed.stage_id, ed.data_type, 
                       ed.extracted_data, ed.created_at, s.stage_name
                FROM extracted_data ed
                JOIN stages s ON ed.stage_id = s.stage_id
                WHERE ed.conversation_id = %s
            """
            
            params = [conversation_id]
            
            if data_type:
                query += " AND ed.data_type = %s"
                params.append(data_type)
                
            query += " ORDER BY ed.created_at DESC LIMIT %s"
            params.append(limit)
            
            cursor.execute(query, params)
            results = cursor.fetchall()
            
            # Format the results
            extracted_data = []
            for row in results:
                extracted_data.append({
                    'extraction_id': row['extraction_id'],
                    'stage_id': row['stage_id'],
                    'stage_name': row['stage_name'],
                    'data_type': row['data_type'],
                    'data': row['extracted_data'],
                    'created_at': row['created_at'].isoformat()
                })
            
            return extracted_data
            
        except Exception as e:
            log.error(f"Error retrieving extracted data: {str(e)}")
            return []
        finally:
            self.db_pool.putconn(conn)

================================================================================
File: enhanced_data_extraction.py
Path: .\backend\message_processing\enhanced_data_extraction.py
Size: 13642
Modified: 2025-05-03T23:08:54.398798
Created: 2025-05-03T19:42:43.549954
Hash: 7ba4b68d863371999076b8a274ece7c19164b392e520a66a8dada4ab069c8eb1
Lines: 334
================================================================================
"""
Enhanced Data Extraction Service with Multi-Layer Extraction Strategy

This module provides a robust and versatile data extraction system that combines
multiple extraction methods and learns from past extractions.
"""

import logging
import json
import re
from typing import Dict, Any, List, Optional, Union, Tuple
from datetime import datetime
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

from backend.ai.llm_service import LLMService
from backend.db import get_db_connection, release_db_connection

log = logging.getLogger(__name__)

class EnhancedDataExtraction:
    """
    Advanced data extraction service with multiple extraction strategies
    and learning capabilities.
    """
    
    def __init__(self, db_pool, llm_service: Optional[LLMService] = None):
        self.db_pool = db_pool
        self.llm_service = llm_service
        self.extraction_patterns = {}
        self.success_rates = {}
        self.vectorizer = TfidfVectorizer()
        self.pattern_database = {}
        
    def extract_data(self, conn, extraction_template_id: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Enhanced data extraction with multiple strategies and confidence scoring.
        """
        try:
            # Get template and process it
            template = self._get_extraction_template(conn, extraction_template_id)
            if not template:
                return {"error": "Template not found"}
            
            processed_template = self._process_template(conn, template, context)
            
            # Get message content
            message_content = context.get('message_content', '')
            
            # Try multiple extraction methods
            results = []
            
            # 1. Pattern-based extraction - Commented out
            # pattern_result = self._extract_with_patterns(message_content, processed_template)
            # results.append(('pattern', pattern_result))
            
            # 2. LLM-based extraction - Only this one is active
            if self.llm_service:
                llm_result = self._extract_with_llm(message_content, processed_template, context)
                results.append(('llm', llm_result))
            
            # 3. Rule-based extraction - Commented out
            # rule_result = self._extract_with_rules(message_content, processed_template)
            # results.append(('rule', rule_result))
            
            # 4. Statistical extraction - Commented out
            # stat_result = self._extract_with_statistics(message_content, processed_template)
            # results.append(('statistical', stat_result))
            
            # Score and combine results
            final_result = self._combine_results(results, message_content)
            
            # Store successful patterns
            if not isinstance(final_result, dict) or 'error' not in final_result:
                self._store_successful_pattern(message_content, processed_template, final_result)
            
            return final_result
            
        except Exception as e:
            log.error(f"Error in enhanced extraction: {str(e)}")
            return {"error": f"Extraction failed: {str(e)}"}
    
    def _extract_with_patterns(self, message: str, template: Dict[str, Any]) -> Dict[str, Any]:
        """Pattern-based extraction with learned patterns."""
        result = {}
        
        # Check pattern database for similar messages
        similar_patterns = self._find_similar_patterns(message)
        if similar_patterns:
            # Use successful patterns from similar messages
            for pattern in similar_patterns:
                if pattern['pattern'] in message:
                    result.update(pattern['extracted_data'])
        
        # Use template-defined patterns
        if 'patterns' in template:
            for field, pattern in template['patterns'].items():
                matches = re.findall(pattern, message)
                if matches:
                    result[field] = matches[0]
        
        return result
    
    def _extract_with_llm(self, message: str, template: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """LLM-based extraction with context awareness."""
        if not self.llm_service:
            return {}
            
        # Add context to the prompt
        prompt = self._build_context_aware_prompt(message, template, context)
        
        try:
            response = self.llm_service.generate(prompt)
            return self._parse_llm_response(response)
        except Exception as e:
            log.error(f"LLM extraction failed: {str(e)}")
            return {}
    
    def _extract_with_rules(self, message: str, template: Dict[str, Any]) -> Dict[str, Any]:
        """Rule-based extraction using predefined rules."""
        result = {}
        
        # Apply business-specific rules
        if 'business_rules' in template:
            for rule in template['business_rules']:
                if self._evaluate_rule(message, rule):
                    result.update(rule['extract'])
        
        # Apply general rules
        for field, rules in template.get('rules', {}).items():
            for rule in rules:
                if self._evaluate_rule(message, rule):
                    result[field] = rule['value']
                    break
        
        return result
    
    def _extract_with_statistics(self, message: str, template: Dict[str, Any]) -> Dict[str, Any]:
        """Statistical extraction for numerical and categorical data."""
        result = {}
        
        # Extract numerical values
        numbers = re.findall(r'\d+\.?\d*', message)
        if numbers:
            result['numerical_values'] = [float(n) for n in numbers]
        
        # Extract categorical data using frequency analysis
        words = message.lower().split()
        word_freq = {}
        for word in words:
            word_freq[word] = word_freq.get(word, 0) + 1
        
        # Find most frequent words that match template categories
        for category in template.get('categories', []):
            matches = [word for word, freq in word_freq.items() 
                      if word in category['keywords']]
            if matches:
                result[category['name']] = max(matches, key=lambda x: word_freq[x])
        
        return result
    
    def _combine_results(self, results: List[Tuple[str, Dict[str, Any]]], message: str) -> Dict[str, Any]:
        """Combine results from different extraction methods with confidence scoring."""
        combined = {}
        confidence_scores = {}
        
        for method, result in results:
            if not result or isinstance(result, dict) and 'error' in result:
                continue
                
            # Calculate confidence score
            confidence = self._calculate_confidence(method, result, message)
            
            # Update combined result with highest confidence values
            for key, value in result.items():
                if key not in combined or confidence > confidence_scores.get(key, 0):
                    combined[key] = value
                    confidence_scores[key] = confidence
        
        # Add confidence scores to result
        combined['_confidence_scores'] = confidence_scores
        
        return combined
    
    def _calculate_confidence(self, method: str, result: Dict[str, Any], message: str) -> float:
        """Calculate confidence score for an extraction result."""
        # Base confidence by method
        method_weights = {
            'llm': 0.8,
            'pattern': 0.7,
            'rule': 0.6,
            'statistical': 0.5
        }
        
        # Adjust based on result quality
        quality_score = 1.0
        if isinstance(result, dict):
            # More fields = higher confidence
            field_count = len(result)
            quality_score *= min(1.0, field_count / 5)
            
            # Check for empty or invalid values
            for value in result.values():
                if not value or str(value).strip() == '':
                    quality_score *= 0.8
        
        return method_weights.get(method, 0.5) * quality_score
    
    def _store_successful_pattern(self, message: str, template: Dict[str, Any], result: Dict[str, Any]):
        """Store successful extraction patterns for future use."""
        try:
            # Create pattern signature
            pattern = self._create_pattern_signature(message, template)
            
            # Store in pattern database
            self.pattern_database[pattern] = {
                'message': message,
                'template': template,
                'extracted_data': result,
                'timestamp': datetime.now(),
                'success_count': 1
            }
            
            # Update success rates
            template_id = template.get('template_id', 'unknown')
            self.success_rates[template_id] = self.success_rates.get(template_id, 0) + 1
            
        except Exception as e:
            log.error(f"Error storing pattern: {str(e)}")
    
    def _find_similar_patterns(self, message: str) -> List[Dict[str, Any]]:
        """Find similar patterns from the pattern database."""
        if not self.pattern_database:
            return []
        
        # Vectorize messages
        messages = [data['message'] for data in self.pattern_database.values()]
        messages.append(message)
        
        try:
            vectors = self.vectorizer.fit_transform(messages)
            similarities = cosine_similarity(vectors[-1:], vectors[:-1])[0]
            
            # Get top similar patterns
            similar_indices = np.argsort(similarities)[-3:]  # Top 3 matches
            return [list(self.pattern_database.values())[i] for i in similar_indices 
                   if similarities[i] > 0.7]  # Similarity threshold
            
        except Exception as e:
            log.error(f"Error finding similar patterns: {str(e)}")
            return []
    
    def _create_pattern_signature(self, message: str, template: Dict[str, Any]) -> str:
        """Create a unique signature for a message pattern."""
        # Extract key features
        words = message.lower().split()
        key_features = [word for word in words if len(word) > 3]  # Ignore short words
        
        # Add template features
        template_features = [str(v) for v in template.values() if isinstance(v, (str, int, float))]
        
        # Combine and hash
        signature = ' '.join(sorted(key_features + template_features))
        return hash(signature)
    
    def _build_context_aware_prompt(self, message: str, template: Dict[str, Any], context: Dict[str, Any]) -> str:
        """Build a context-aware prompt for LLM extraction."""
        # Include conversation history
        history = context.get('conversation_history', '')
        
        # Include user preferences
        preferences = context.get('user_preferences', {})
        
        # Build prompt
        prompt = f"""
        Extract information from the following message with context:
        
        Conversation History:
        {history}
        
        User Preferences:
        {json.dumps(preferences, indent=2)}
        
        Template Requirements:
        {json.dumps(template, indent=2)}
        
        Message to Extract From:
        {message}
        
        Please extract the requested information in JSON format.
        """
        
        return prompt
    
    def _parse_llm_response(self, response: str) -> Dict[str, Any]:
        """Parse LLM response into structured data."""
        try:
            # Try to find JSON in response
            json_str = re.search(r'\{.*\}', response, re.DOTALL)
            if json_str:
                return json.loads(json_str.group())
            return {}
        except Exception as e:
            log.error(f"Error parsing LLM response: {str(e)}")
            return {}
    
    def _evaluate_rule(self, message: str, rule: Dict[str, Any]) -> bool:
        """Evaluate if a rule applies to a message."""
        try:
            # Check conditions
            for condition in rule.get('conditions', []):
                if not self._check_condition(message, condition):
                    return False
            return True
        except Exception as e:
            log.error(f"Error evaluating rule: {str(e)}")
            return False
    
    def _check_condition(self, message: str, condition: Dict[str, Any]) -> bool:
        """Check if a condition is met in the message."""
        condition_type = condition.get('type', 'contains')
        value = condition.get('value', '')
        
        if condition_type == 'contains':
            return value.lower() in message.lower()
        elif condition_type == 'starts_with':
            return message.lower().startswith(value.lower())
        elif condition_type == 'ends_with':
            return message.lower().endswith(value.lower())
        elif condition_type == 'regex':
            return bool(re.search(value, message))
        
        return False 

================================================================================
File: message_handler.py
Path: .\backend\message_processing\message_handler.py
Size: 27529
Modified: 2025-05-05T00:50:17.654291
Created: 2025-04-09T02:14:15.942951
Hash: 76717401b6e6841cb569b175bc13026e5748c532c169738e3f07d216a0edccd2
Lines: 643
================================================================================
"""
Message handler for processing incoming messages.

This module handles the orchestration of message processing,
utilizing the StageService and TemplateService to determine the
appropriate processing flow and apply templates.
"""

import logging
import uuid
import re
import json
from typing import Dict, Any, Optional, Tuple, List
from datetime import datetime

from backend.ai.llm_service import LLMService
from backend.db import get_db_connection, release_db_connection, execute_query
from backend.message_processing.template_variables import TemplateVariableProvider
from backend.message_processing.stage_service import StageService
from backend.message_processing.template_service import TemplateService
from backend.message_processing.data_extraction_service import DataExtractionService
from backend.message_processing.ai_control_service import ai_control_service
from backend.db.connection_manager import ConnectionManager

log = logging.getLogger(__name__)

class MessageHandler:
    """
    Handler for processing incoming messages.
    
    Coordinates the message processing flow by working with various services
    to determine the current stage, apply appropriate templates, and generate responses.
    """
    
    # In-memory storage for process logs
    _process_logs = {}
    
    # In-memory storage for stop flags per conversation
    _stop_flags = {}
    
    def __init__(self, db_pool, llm_service: LLMService = None):
        """
        Initialize the message handler.
        
        Args:
            db_pool: Database connection pool
            llm_service: Optional LLM service instance for generating responses
        """
        self.db_pool = db_pool
        self.connection_manager = ConnectionManager(db_pool)
        self.llm_service = llm_service or LLMService(db_pool=db_pool)
        self.stage_service = StageService(db_pool)
        self.template_service = TemplateService()
        self.data_extraction_service = DataExtractionService(db_pool, self.llm_service)
    
    def stop_ai_responses(self, conversation_id: str) -> None:
        """
        Stop AI from generating responses for a specific conversation.
        
        Args:
            conversation_id: The ID of the conversation to stop
        """
        self._stop_flags[conversation_id] = True
        log.info(f"AI responses stopped for conversation {conversation_id}")
    
    def resume_ai_responses(self, conversation_id: str) -> None:
        """
        Resume AI response generation for a specific conversation.
        
        Args:
            conversation_id: The ID of the conversation to resume
        """
        self._stop_flags[conversation_id] = False
        log.info(f"AI responses resumed for conversation {conversation_id}")
    
    def is_ai_stopped(self, conversation_id: str) -> bool:
        """
        Check if AI responses are stopped for a conversation.
        
        Args:
            conversation_id: The ID of the conversation to check
            
        Returns:
            bool: True if AI responses are stopped, False otherwise
        """
        return self._stop_flags.get(conversation_id, False)
    
    def process_message(self, message_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process an incoming message.
        
        Args:
            message_data: Dictionary containing message data
            
        Returns:
            Dictionary containing the response
        """
        log_id = str(uuid.uuid4())
        self._store_process_log(log_id, {
            'status': 'started',
            'timestamp': datetime.now().isoformat(),
            'message_data': message_data
        })
        
        try:
            # Extract required fields
            business_id = message_data.get('business_id')
            user_id = message_data.get('user_id')
            content = message_data.get('content')
            initial_conversation_id = message_data.get('conversation_id')
            api_key = message_data.get('api_key')
            owner_id = message_data.get('owner_id')
            
            # Validate required fields
            if not all([business_id, user_id, content]):
                self._store_process_log(log_id, {
                    'status': 'error',
                    'error': "Missing required fields: business_id, user_id, content",
                    'timestamp': datetime.now().isoformat()
                })
                return {
                    'success': False,
                    'error': "Missing required fields: business_id, user_id, content"
                }
            
            # Check if AI responses are stopped for this user
            if ai_control_service.is_ai_stopped(None, user_id):
                log.info(f"AI responses are stopped for user {user_id}")
                return {
                    'success': True,
                    'response': None,
                    'conversation_id': None,
                    'message_id': None,
                    'response_id': None,
                    'process_log_id': log_id,
                    'ai_stopped': True
                }
            
            # Process the message using the connection manager
            def process_with_connection(conn):
                # Get or create conversation
                current_conversation_id = self._get_or_create_conversation(conn, business_id, user_id, initial_conversation_id)
                
                # Process the message
                result = self._process_message_with_connection(
                    conn, current_conversation_id, business_id, user_id, content
                )
                
                return result
            
            result = self.connection_manager.execute_with_retry(process_with_connection)
            
            self._store_process_log(log_id, {
                'status': 'completed',
                'timestamp': datetime.now().isoformat(),
                'result': result
            })
            
            return result
            
        except Exception as e:
            log.error(f"Error processing message: {str(e)}", exc_info=True)
            self._store_process_log(log_id, {
                'status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            })
            return {
                'success': False,
                'error': str(e),
                'process_log_id': log_id
            }
    
    def _process_message_with_connection(self, conn, conversation_id: str, business_id: str, 
                                       user_id: str, content: str) -> Dict[str, Any]:
        """Process a message with an existing connection."""
        try:
            # Save the user message
            message_id = self._save_message(conn, conversation_id, content, 'user', user_id)
            
            # Get current stage and process
            stage_info = self.stage_service.get_current_stage(conversation_id)
            if not stage_info:
                return {
                    'success': False,
                    'error': "Could not determine conversation stage",
                    'conversation_id': conversation_id,
                    'message_id': message_id
                }
            
            # Process the message based on stage
            response = self._process_stage_message(
                conn, conversation_id, business_id, user_id, content, stage_info
            )
            
            # Update conversation timestamp
            self._update_conversation_timestamp(conn, conversation_id)
            
            return {
                'success': True,
                'conversation_id': conversation_id,
                'message_id': message_id,
                'response_id': response.get('response_id'),
                'response': response.get('content'),
                'stage_id': stage_info.get('stage_id')
            }
            
        except Exception as e:
            log.error(f"Error in _process_message_with_connection: {str(e)}", exc_info=True)
            raise
    
    def _process_stage_message(self, conn, conversation_id, business_id, user_id, content, stage_info):
        """
        Process a message based on the current stage.
        
        Args:
            conn: Database connection
            conversation_id: ID of the conversation
            business_id: ID of the business
            user_id: ID of the user
            content: Message content
            stage_info: Dictionary containing stage information
            
        Returns:
            Dictionary containing response information
        """
        try:
            # Get the template IDs for this stage
            stage_id = stage_info.get('stage_id')
            stage_selection_template_id = stage_info.get('stage_selection_template_id')
            data_extraction_template_id = stage_info.get('data_extraction_template_id')
            response_generation_template_id = stage_info.get('response_generation_template_id')
            
            # Build context for template substitution
            context = {
                'business_id': business_id,
                'user_id': user_id,
                'conversation_id': conversation_id,
                'message_content': content,
                'stage_id': stage_id,
                'stage_name': stage_info.get('stage_name'),
                'stage_description': stage_info.get('stage_description')
            }
            
            # Generate values for template variables
            variable_values = TemplateVariableProvider.generate_variable_values(
                conn=conn,
                business_id=business_id,
                user_id=user_id,
                conversation_id=conversation_id,
                message_content=content
            )
            context.update(variable_values)
            
            # Step 1: Data Extraction if template exists
            extracted_data = None
            if data_extraction_template_id:
                extraction_template = self.template_service.get_template(conn, data_extraction_template_id)
                if extraction_template:
                    applied_template = self.template_service.apply_template(extraction_template, context)
                    extraction_input = applied_template['content']
                    extraction_system_prompt = applied_template.get('system_prompt', '')
                    
                    # Generate extraction response using LLM
                    extracted_data = self.llm_service.generate_response(
                        input_text=extraction_input,
                        system_prompt=extraction_system_prompt,
                        conversation_id=conversation_id,
                        business_id=business_id,
                        call_type="extraction"
                    )
                    context['extracted_data'] = extracted_data
            
            # Step 2: Generate Response
            response_content = None
            if response_generation_template_id:
                response_template = self.template_service.get_template(conn, response_generation_template_id)
                if response_template:
                    applied_template = self.template_service.apply_template(response_template, context)
                    response_input = applied_template['content']
                    response_system_prompt = applied_template.get('system_prompt', '')
                    
                    # Generate response using LLM
                    response_content = self.llm_service.generate_response(
                        input_text=response_input,
                        system_prompt=response_system_prompt,
                        conversation_id=conversation_id,
                        business_id=business_id,
                        call_type="response"
                    )
            
            # If no response generated, use a default message
            if not response_content:
                response_content = "I'm processing your message. Please wait a moment."
            
            # Save the response message
            response_id = self._save_message(conn, conversation_id, response_content, 'assistant', user_id)
            
            return {
                'response_id': response_id,
                'content': response_content,
                'extracted_data': extracted_data
            }
            
        except Exception as e:
            log.error(f"Error in _process_stage_message: {str(e)}", exc_info=True)
            # Return a fallback response
            response_id = self._save_message(conn, conversation_id, "I encountered an error processing your message. Please try again.", 'assistant', user_id)
            return {
                'response_id': response_id,
                'content': "I encountered an error processing your message. Please try again.",
                'extracted_data': None
            }
    
    def _get_or_create_conversation(self, conn, business_id: str, user_id: str, 
                                  conversation_id: Optional[str] = None) -> str:
        """Get existing conversation or create a new one."""
        def get_or_create_with_connection(conn):
            cursor = conn.cursor()
            
            try:
                # First, check if the user exists
                cursor.execute(
                    """
                    SELECT user_id FROM users WHERE user_id = %s
                    """,
                    (user_id,)
                )
                if not cursor.fetchone():
                    # User doesn't exist, create them
                    cursor.execute(
                        """
                        INSERT INTO users (
                            user_id, first_name, last_name, email, created_at
                        )
                        VALUES (%s, %s, %s, %s, NOW())
                        """,
                        (user_id, 'NEW', 'User', f'auto-{user_id}@example.com')
                    )
                    conn.commit()  # Commit the user creation
                    log.info(f"Created new user: {user_id}")
                
                # If conversation_id is provided, verify it exists
                if conversation_id:
                    cursor.execute(
                        """
                        SELECT conversation_id, status 
                        FROM conversations 
                        WHERE conversation_id = %s AND business_id = %s AND user_id = %s
                        """,
                        (conversation_id, business_id, user_id)
                    )
                    result = cursor.fetchone()
                    
                    if result:
                        return result[0]
                    else:
                        log.warning(f"Conversation {conversation_id} not found, creating new one")
                
                # Create new conversation
                return self._create_conversation(conn, business_id, user_id)
                
            finally:
                cursor.close()
        
        return self.connection_manager.execute_with_retry(get_or_create_with_connection)

    def _save_message(self, conn, conversation_id: str, content: str, 
                     sender_type: str, user_id: str = None) -> str:
        """Save a message to the database."""
        def save_with_connection(conn):
            cursor = conn.cursor()
            try:
                message_id = str(uuid.uuid4())
                cursor.execute(
                    """
                    INSERT INTO messages (
                        message_id, conversation_id, content, sender_type, user_id, created_at
                    )
                    VALUES (%s, %s, %s, %s, %s, NOW())
                    """,
                    (message_id, conversation_id, content, sender_type, user_id)
                )
                return message_id
            finally:
                cursor.close()
        
        return self.connection_manager.execute_with_retry(save_with_connection)

    def _update_conversation_timestamp(self, conn, conversation_id: str) -> None:
        """Update the conversation's last activity timestamp."""
        def update_with_connection(conn):
            cursor = conn.cursor()
            try:
                cursor.execute(
                    """
                    UPDATE conversations 
                    SET last_updated = NOW() 
                    WHERE conversation_id = %s
                    """,
                    (conversation_id,)
                )
            finally:
                cursor.close()
        
        self.connection_manager.execute_with_retry(update_with_connection)

    def _create_conversation(self, conn, business_id: str, user_id: str) -> str:
        """Create a new conversation."""
        def create_with_connection(conn):
            cursor = conn.cursor()
            try:
                conversation_id = str(uuid.uuid4())
                cursor.execute(
                    """
                    INSERT INTO conversations (
                        conversation_id, business_id, user_id, status, start_time, last_updated
                    )
                    VALUES (%s, %s, %s, 'active', NOW(), NOW())
                    """,
                    (conversation_id, business_id, user_id)
                )
                conn.commit()  # Commit the conversation creation
                return conversation_id
            finally:
                cursor.close()
        
        return self.connection_manager.execute_with_retry(create_with_connection)

    def _get_stage_name(self, conn, stage_id):
        """Get the name of a stage by its ID."""
        def get_with_connection(conn):
            cursor = conn.cursor()
            try:
                cursor.execute(
                    """
                    SELECT name FROM stages WHERE stage_id = %s
                    """,
                    (stage_id,)
                )
                result = cursor.fetchone()
                return result[0] if result else None
            finally:
                cursor.close()
        
        return self.connection_manager.execute_with_retry(get_with_connection)

    def _get_available_stages(self, conn, business_id: str) -> List[str]:
        """Get all available stages for a business."""
        def get_with_connection(conn):
            cursor = conn.cursor()
            try:
                cursor.execute(
                    """
                    SELECT stage_id, name FROM stages 
                    WHERE business_id = %s 
                    ORDER BY name
                    """,
                    (business_id,)
                )
                return [{'stage_id': row[0], 'name': row[1]} for row in cursor.fetchall()]
            finally:
                cursor.close()
        
        return self.connection_manager.execute_with_retry(get_with_connection)

    def validate_stage_selection_response(self, response: str) -> str:
        """Validate and clean the stage selection response."""
        if not response:
            log.warning("Empty stage selection response, defaulting to 'not_sure'")
            return "not_sure"
        
        # Clean the response
        cleaned_response = response.strip().lower()
        log.debug(f"Cleaned stage selection response: '{cleaned_response}'")
        
        # List of valid stages with aliases
        valid_stages = {
            "default": ["default", "default conversation", "default stage", "initial"],
            "introduction": ["intro", "introduction", "greeting", "welcome"],
            "products": ["product", "products", "catalog", "offering"],
            "not_sure": ["not sure", "unclear", "unknown", "unsure"],
            "test": ["test", "testing", "debug"]
        }
        
        # Try to match the response against stage names and their aliases
        for stage, aliases in valid_stages.items():
            for alias in aliases:
                if alias in cleaned_response:
                    log.info(f"Matched stage '{stage}' via alias '{alias}' in response: '{cleaned_response}'")
                    return stage
        
        # If no match found, try to extract any stage-like words
        words = cleaned_response.split()
        for word in words:
            for stage, aliases in valid_stages.items():
                if any(alias.startswith(word) for alias in aliases):
                    log.info(f"Partial match found for stage '{stage}' from word '{word}'")
                    return stage
        
        # If still no match, check if response contains any stage-related keywords
        stage_keywords = {
            "default": ["conversation", "general", "basic"],
            "introduction": ["hello", "hi", "hey", "greet"],
            "products": ["buy", "purchase", "price", "cost"],
            "not_sure": ["help", "confused", "what", "how"],
            "test": ["check", "verify", "testing"]
        }
        
        for stage, keywords in stage_keywords.items():
            if any(keyword in cleaned_response for keyword in keywords):
                log.info(f"Matched stage '{stage}' via keyword in response: '{cleaned_response}'")
                return stage
        
        # If no valid stage found, log extensively and return default
        log.warning(f"No valid stage match found in response: '{response}'")
        log.warning("Original response content length: %d", len(response))
        log.warning("Cleaned response content length: %d", len(cleaned_response))
        log.warning("Words in cleaned response: %s", words)
        
        return "not_sure"

    def _generate_conversation_summary(self, messages: List[Dict], business_id: str) -> str:
        """Generate a summary of the conversation using the LLM service."""
        try:
            # Format messages for summary generation
            formatted_messages = []
            for msg in messages:
                role = "assistant" if msg["is_from_agent"] else "user"
                formatted_messages.append({
                    "role": role,
                    "content": msg["content"]
                })
            
            # Generate summary using LLM service
            summary_prompt = """Please analyze this conversation and provide a structured summary with the following sections:
1. Overview: A brief summary of the main topic and purpose
2. Key Points: Important information discussed
3. Decisions: Any decisions made or agreements reached
4. Pending Items: Topics that need follow-up
5. Next Steps: Recommended actions
6. Sentiment: Overall tone of the conversation
7. Confidence Score: How confident you are in this summary (0-1)

Format the response as a JSON object with these exact keys."""

            summary = self.llm_service.generate_response(
                business_id=business_id,
                input_text=json.dumps(formatted_messages),
                system_prompt=summary_prompt,
                call_type="summary"
            )
            
            # Validate that the summary is valid JSON
            try:
                json.loads(summary)  # This will raise an error if the JSON is invalid
                return summary  # Return the JSON string if valid
            except json.JSONDecodeError:
                # If the summary is not valid JSON, create a basic structure
                basic_summary = {
                    "overview": "Unable to generate structured summary",
                    "key_points": [],
                    "decisions": [],
                    "pending_items": [],
                    "next_steps": [],
                    "sentiment": "neutral",
                    "confidence_score": 0.0
                }
                return json.dumps(basic_summary)
            
        except Exception as e:
            log.error(f"Error generating conversation summary: {str(e)}")
            return None

    def _update_conversation(self, conversation_id: str, business_id: str, user_id: str, 
                            content: str, is_from_agent: bool, stage_id: Optional[str] = None,
                            llm_call_id: Optional[str] = None) -> None:
        """Update conversation with new message and optional stage change."""
        def update_with_connection(conn):
            cursor = conn.cursor()
            try:
                # Update conversation timestamp
                cursor.execute(
                    """
                    UPDATE conversations 
                    SET updated_at = NOW() 
                    WHERE conversation_id = %s
                    """,
                    (conversation_id,)
                )
                
                # Save the message
                message_id = str(uuid.uuid4())
                cursor.execute(
                    """
                    INSERT INTO messages (
                        message_id, conversation_id, content, sender_type, user_id, 
                        created_at, llm_call_id
                    )
                    VALUES (%s, %s, %s, %s, %s, NOW(), %s)
                    """,
                    (message_id, conversation_id, content, 
                     'agent' if is_from_agent else 'user', 
                     user_id, llm_call_id)
                )
                
                # Update stage if provided
                if stage_id:
                    cursor.execute(
                        """
                        UPDATE conversations 
                        SET stage_id = %s 
                        WHERE conversation_id = %s
                        """,
                        (stage_id, conversation_id)
                    )
            finally:
                cursor.close()
        
        self.connection_manager.execute_with_retry(update_with_connection)

    @classmethod
    def _store_process_log(cls, log_id: str, log_data: Dict[str, Any]) -> None:
        """Store a process log in the in-memory storage."""
        cls._process_logs[log_id] = log_data

    @classmethod
    def get_process_log(cls, log_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve a process log by ID."""
        return cls._process_logs.get(log_id)

    @classmethod
    def get_recent_process_logs(cls, business_id: str, limit: int = 10) -> List[Dict[str, Any]]:
        """Retrieve recent process logs for a business."""
        business_logs = [
            log for log in cls._process_logs.values()
            if log.get('business_id') == business_id
        ]
        return sorted(
            business_logs,
            key=lambda x: x.get('start_time', ''),
            reverse=True
        )[:limit]

================================================================================
File: message_simulator.py
Path: .\backend\message_processing\message_simulator.py
Size: 5204
Modified: 2025-05-10T17:36:05.080328
Created: 2025-05-10T17:36:01.857075
Hash: 1f22d8ba6715caa2b77ffcd9a53fd9f22059bc3b0cad48d7fa7591642bab5227
Lines: 148
================================================================================
"""
Message Simulator Interface

This module provides an interface for simulating message processing and testing
the template system without requiring actual user interactions.
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime

from .message_handler import MessageHandler
from .template_service import TemplateService
from ..db import get_db_pool

log = logging.getLogger(__name__)

class MessageSimulator:
    """
    Interface for simulating message processing and testing the template system.
    
    This class provides methods to:
    - Send test messages
    - View conversation history
    - Test template applications
    - Monitor message processing flow
    """
    
    def __init__(self):
        """Initialize the message simulator with required services."""
        self.db_pool = get_db_pool()
        self.message_handler = MessageHandler(self.db_pool)
        self.template_service = TemplateService()
    
    def simulate_message(self, user_id: str, message_content: str, 
                        business_id: str, conversation_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Simulate sending a message and process it through the system.
        
        Args:
            user_id: ID of the user sending the message
            message_content: Content of the message
            business_id: ID of the business context
            conversation_id: Optional ID of existing conversation
            
        Returns:
            Dictionary containing processing results
        """
        try:
            # Prepare message data
            message_data = {
                'business_id': business_id,
                'user_id': user_id,
                'content': message_content,
                'conversation_id': conversation_id
            }
            
            # Process the message
            result = self.message_handler.process_message(message_data)
            
            # Add simulation metadata
            result['simulation_timestamp'] = datetime.now().isoformat()
            result['simulation_type'] = 'test_message'
            
            return result
            
        except Exception as e:
            log.error(f"Error in message simulation: {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'simulation_timestamp': datetime.now().isoformat()
            }
    
    def get_conversation_history(self, conversation_id: str) -> List[Dict[str, Any]]:
        """
        Retrieve the history of a conversation.
        
        Args:
            conversation_id: ID of the conversation
            
        Returns:
            List of messages in the conversation
        """
        try:
            with self.db_pool.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(
                    """
                    SELECT message_id, message_content, sender_type, created_at
                    FROM messages
                    WHERE conversation_id = %s
                    ORDER BY created_at ASC
                    """,
                    (conversation_id,)
                )
                
                messages = []
                for row in cursor.fetchall():
                    messages.append({
                        'message_id': row['message_id'],
                        'content': row['message_content'],
                        'sender': row['sender_type'],
                        'timestamp': row['created_at'].isoformat()
                    })
                
                return messages
                
        except Exception as e:
            log.error(f"Error retrieving conversation history: {str(e)}")
            return []
    
    def get_user_conversations(self, user_id: str) -> List[Dict[str, Any]]:
        """
        Get all conversations for a user.
        
        Args:
            user_id: ID of the user
            
        Returns:
            List of conversations
        """
        try:
            with self.db_pool.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(
                    """
                    SELECT conversation_id, created_at, updated_at
                    FROM conversations
                    WHERE user_id = %s
                    ORDER BY updated_at DESC
                    """,
                    (user_id,)
                )
                
                conversations = []
                for row in cursor.fetchall():
                    conversations.append({
                        'conversation_id': row['conversation_id'],
                        'created_at': row['created_at'].isoformat(),
                        'updated_at': row['updated_at'].isoformat()
                    })
                
                return conversations
                
        except Exception as e:
            log.error(f"Error retrieving user conversations: {str(e)}")
            return [] 

================================================================================
File: pattern_learning.py
Path: .\backend\message_processing\pattern_learning.py
Size: 15520
Modified: 2025-05-04T01:00:34.031311
Created: 2025-05-03T19:43:17.468668
Hash: e1b458cba54c094c80e47a92748a21c4802a23f51353ef8f8626d44ba2d09264
Lines: 386
================================================================================
"""
Pattern Learning Service for Data Extraction

This module provides functionality to learn and improve extraction patterns
over time based on successful extractions and user feedback.
"""

import logging
import json
from typing import Dict, Any, List, Optional, Set
from datetime import datetime, timedelta
import numpy as np
from sklearn.cluster import DBSCAN
from sklearn.feature_extraction.text import TfidfVectorizer
from collections import defaultdict

log = logging.getLogger(__name__)

class PatternLearningService:
    """
    Service for learning and improving extraction patterns over time.
    """
    
    def __init__(self, db_pool):
        self.db_pool = db_pool
        self.vectorizer = TfidfVectorizer()
        self.pattern_clusters = {}
        self.feedback_history = defaultdict(list)
        self.learning_rate = 0.1  # Rate at which patterns are updated
        
    def learn_from_extraction(self, message: str, template: Dict[str, Any], 
                            extracted_data: Dict[str, Any], success: bool = True):
        """
        Learn from a successful or failed extraction.
        
        Args:
            message: The message that was processed
            template: The template used for extraction
            extracted_data: The data that was extracted
            success: Whether the extraction was successful
        """
        try:
            # Get or create pattern cluster
            cluster_id = self._get_cluster_id(message, template)
            
            # Update pattern statistics
            self._update_pattern_stats(cluster_id, message, template, extracted_data, success)
            
            # Update pattern weights
            self._update_pattern_weights(cluster_id, success)
            
            # Store in database
            self._store_learning_data(cluster_id, message, template, extracted_data, success)
            
        except Exception as e:
            log.error(f"Error in pattern learning: {str(e)}")
    
    def get_improved_patterns(self, template_id: str) -> Dict[str, Any]:
        """
        Get improved patterns for a template based on learning.
        
        Args:
            template_id: ID of the template
            
        Returns:
            Dictionary of improved patterns
        """
        try:
            # Get successful patterns for this template
            successful_patterns = self._get_successful_patterns(template_id)
            
            # Generate improved patterns
            improved_patterns = self._generate_improved_patterns(successful_patterns)
            
            return improved_patterns
            
        except Exception as e:
            log.error(f"Error getting improved patterns: {str(e)}")
            return {}
    
    def add_feedback(self, extraction_id: str, feedback: Dict[str, Any]):
        """
        Add user feedback about an extraction.
        
        Args:
            extraction_id: ID of the extraction
            feedback: Dictionary containing feedback data
        """
        try:
            # Store feedback
            self.feedback_history[extraction_id].append({
                'feedback': feedback,
                'timestamp': datetime.now()
            })
            
            # Update patterns based on feedback
            self._update_patterns_from_feedback(extraction_id, feedback)
            
        except Exception as e:
            log.error(f"Error adding feedback: {str(e)}")
    
    def _get_cluster_id(self, message: str, template: Dict[str, Any]) -> str:
        """Get or create a cluster ID for similar messages."""
        # Vectorize message
        message_vector = self.vectorizer.fit_transform([message])
        
        # Find similar clusters
        for cluster_id, cluster_data in self.pattern_clusters.items():
            if cluster_data['template_id'] == template.get('template_id'):
                # Calculate similarity with cluster center
                similarity = np.dot(message_vector, cluster_data['center'].T).mean()
                if similarity > 0.7:  # Similarity threshold
                    return cluster_id
        
        # Create new cluster
        new_cluster_id = f"cluster_{len(self.pattern_clusters)}"
        self.pattern_clusters[new_cluster_id] = {
            'template_id': template.get('template_id'),
            'center': message_vector,
            'messages': [message],
            'success_count': 0,
            'total_count': 0,
            'patterns': {}
        }
        
        return new_cluster_id
    
    def _update_pattern_stats(self, cluster_id: str, message: str, 
                            template: Dict[str, Any], extracted_data: Dict[str, Any], 
                            success: bool):
        """Update pattern statistics for a cluster."""
        cluster = self.pattern_clusters[cluster_id]
        cluster['total_count'] += 1
        
        if success:
            cluster['success_count'] += 1
            
            # Update patterns
            for field, value in extracted_data.items():
                if field not in cluster['patterns']:
                    cluster['patterns'][field] = {
                        'values': [],
                        'weights': {},
                        'success_rate': 0.0
                    }
                
                pattern_data = cluster['patterns'][field]
                pattern_data['values'].append(value)
                
                # Update weights based on value frequency
                if value not in pattern_data['weights']:
                    pattern_data['weights'][value] = 1
                else:
                    pattern_data['weights'][value] += 1
                
                # Update success rate
                pattern_data['success_rate'] = (
                    pattern_data.get('success_rate', 0) * 0.9 +  # Decay old rate
                    (1 if success else 0) * 0.1  # Add new result
                )
    
    def _update_pattern_weights(self, cluster_id: str, success: bool):
        """Update pattern weights based on success/failure."""
        cluster = self.pattern_clusters[cluster_id]
        
        for field, pattern_data in cluster['patterns'].items():
            # Adjust weights based on success
            weight_adjustment = self.learning_rate * (1 if success else -1)
            
            for value in pattern_data['weights']:
                pattern_data['weights'][value] *= (1 + weight_adjustment)
            
            # Normalize weights
            total_weight = sum(pattern_data['weights'].values())
            if total_weight > 0:
                pattern_data['weights'] = {
                    k: v/total_weight 
                    for k, v in pattern_data['weights'].items()
                }
    
    def _store_learning_data(self, cluster_id: str, message: str, 
                           template: Dict[str, Any], extracted_data: Dict[str, Any], 
                           success: bool):
        """Store learning data in the database."""
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Store extraction result
            cursor.execute(
                """
                INSERT INTO extraction_results 
                (cluster_id, message, template_id, extracted_data, success, timestamp)
                VALUES (%s, %s, %s, %s, %s, %s)
                """,
                (cluster_id, message, template.get('template_id'), 
                 json.dumps(extracted_data), success, datetime.now())
            )
            
            # Store pattern data
            for field, value in extracted_data.items():
                if field not in self.pattern_clusters[cluster_id]['patterns']:
                    self.pattern_clusters[cluster_id]['patterns'][field] = {
                        'values': [],
                        'weights': {},
                        'success_rate': 0.0
                    }
                
                pattern_data = self.pattern_clusters[cluster_id]['patterns'][field]
                pattern_data['values'].append(value)
                
                # Update weights based on value frequency
                if value not in pattern_data['weights']:
                    pattern_data['weights'][value] = 1
                else:
                    pattern_data['weights'][value] += 1
                
                # Update success rate
                pattern_data['success_rate'] = (
                    pattern_data.get('success_rate', 0) * 0.9 +  # Decay old rate
                    (1 if success else 0) * 0.1  # Add new result
                )
                
                # Store in database
                cursor.execute(
                    """
                    INSERT INTO pattern_data 
                    (cluster_id, field, pattern_values, weights, success_rate)
                    VALUES (%s, %s, %s, %s, %s)
                    ON CONFLICT (cluster_id, field) 
                    DO UPDATE SET 
                        pattern_values = %s,
                        weights = %s,
                        success_rate = %s
                    """,
                    (cluster_id, field, 
                     json.dumps(pattern_data['values']),
                     json.dumps(pattern_data['weights']),
                     pattern_data['success_rate'],
                     json.dumps(pattern_data['values']),
                     json.dumps(pattern_data['weights']),
                     pattern_data['success_rate'])
                )
            
            conn.commit()
            
        except Exception as e:
            log.error(f"Error storing learning data: {str(e)}")
            if conn:
                conn.rollback()
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def _get_successful_patterns(self, template_id: str) -> List[Dict[str, Any]]:
        """Get successful patterns for a template."""
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            cursor.execute(
                """
                SELECT cluster_id, field, pattern_values, weights, success_rate
                FROM pattern_data
                WHERE cluster_id IN (
                    SELECT cluster_id 
                    FROM extraction_results 
                    WHERE template_id = %s AND success = true
                )
                AND success_rate > 0.7
                """,
                (template_id,)
            )
            
            patterns = []
            for row in cursor.fetchall():
                patterns.append({
                    'cluster_id': row[0],
                    'field': row[1],
                    'values': json.loads(row[2]),
                    'weights': json.loads(row[3]),
                    'success_rate': row[4]
                })
            
            return patterns
            
        except Exception as e:
            log.error(f"Error getting successful patterns: {str(e)}")
            return []
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def _generate_improved_patterns(self, successful_patterns: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate improved patterns from successful extractions."""
        improved_patterns = {}
        
        # Group patterns by field
        field_patterns = defaultdict(list)
        for pattern in successful_patterns:
            field_patterns[pattern['field']].append(pattern)
        
        # Generate improved patterns for each field
        for field, patterns in field_patterns.items():
            # Combine patterns with high success rates
            combined_pattern = self._combine_patterns(patterns)
            if combined_pattern:
                improved_patterns[field] = combined_pattern
        
        return improved_patterns
    
    def _combine_patterns(self, patterns: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Combine multiple patterns into an improved pattern."""
        if not patterns:
            return None
        
        # Calculate weighted average of success rates
        total_weight = sum(p['success_rate'] for p in patterns)
        if total_weight == 0:
            return None
        
        # Combine values based on weights
        combined_values = defaultdict(float)
        for pattern in patterns:
            weight = pattern['success_rate'] / total_weight
            for value, value_weight in pattern['weights'].items():
                combined_values[value] += value_weight * weight
        
        # Normalize weights
        total_weight = sum(combined_values.values())
        if total_weight > 0:
            combined_values = {
                k: v/total_weight 
                for k, v in combined_values.items()
            }
        
        return {
            'values': list(combined_values.keys()),
            'weights': combined_values,
            'success_rate': sum(p['success_rate'] for p in patterns) / len(patterns)
        }
    
    def _update_patterns_from_feedback(self, extraction_id: str, feedback: Dict[str, Any]):
        """Update patterns based on user feedback."""
        try:
            # Get the extraction result
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            cursor.execute(
                """
                SELECT cluster_id, message, template_id, extracted_data
                FROM extraction_results
                WHERE extraction_id = %s
                """,
                (extraction_id,)
            )
            
            row = cursor.fetchone()
            if not row:
                return
            
            cluster_id, message, template_id, extracted_data = row
            extracted_data = json.loads(extracted_data)
            
            # Update patterns based on feedback
            for field, feedback_data in feedback.items():
                if field in extracted_data:
                    # Adjust pattern weights
                    if feedback_data.get('correct', False):
                        self._update_pattern_stats(cluster_id, message, 
                                                {'template_id': template_id},
                                                {field: extracted_data[field]},
                                                True)
                    else:
                        # If incorrect, reduce weight of the incorrect value
                        self._update_pattern_stats(cluster_id, message,
                                                {'template_id': template_id},
                                                {field: feedback_data.get('correct_value', '')},
                                                True)
            
        except Exception as e:
            log.error(f"Error updating patterns from feedback: {str(e)}")
        finally:
            if conn:
                self.db_pool.putconn(conn) 

================================================================================
File: process_log_store.py
Path: .\backend\message_processing\process_log_store.py
Size: 1747
Modified: 2025-05-02T10:52:19.908059
Created: 2025-04-16T22:56:37.586067
Hash: f363eb7335bbc76024d03d2d594b42a45ff34fc278759d58785e591cd6260521
Lines: 64
================================================================================
"""
Process log store for storing and retrieving process logs.

This module provides functionality for storing and retrieving process logs
in a shared in-memory storage that persists between requests.
"""

import logging
from typing import Dict, Any, Optional, List

log = logging.getLogger(__name__)

# Shared in-memory storage for process logs
_process_logs: Dict[str, Dict[str, Any]] = {}

def store_process_log(log_id: str, log_data: Dict[str, Any]) -> None:
    """
    Store a process log in the shared in-memory storage.
    
    Args:
        log_id: ID of the process log
        log_data: Data to store
    """
    _process_logs[log_id] = log_data
    log.debug(f"Stored process log with ID {log_id}")

def get_process_log(log_id: str) -> Optional[Dict[str, Any]]:
    """
    Retrieve a process log by ID.
    
    Args:
        log_id: ID of the process log
        
    Returns:
        Process log data or None if not found
    """
    return _process_logs.get(log_id)

def get_recent_process_logs(business_id: str, limit: int = 10) -> List[Dict[str, Any]]:
    """
    Retrieve recent process logs for a business.
    
    Args:
        business_id: ID of the business
        limit: Maximum number of logs to retrieve
        
    Returns:
        List of process logs
    """
    # Filter logs by business_id
    business_logs = [
        log for log in _process_logs.values()
        if log.get('business_id') == business_id
    ]
    
    # Sort by timestamp (newest first)
    sorted_logs = sorted(
        business_logs,
        key=lambda x: x.get('timestamp', ''),
        reverse=True
    )
    
    # Return the most recent logs
    return sorted_logs[:limit]

================================================================================
File: stage_service.py
Path: .\backend\message_processing\stage_service.py
Size: 27258
Modified: 2025-05-05T00:47:48.015165
Created: 2025-04-09T02:12:37.840587
Hash: db3e144c9ad4ff33810ccefceea4914140e71dd769aaefe57033f01d870d4480
Lines: 682
================================================================================
"""
Stage service for conversation flow management.

This module provides functionality for managing conversation stages,
determining the current stage, and handling transitions between stages.
"""

import logging
from typing import Dict, Any, Optional, List, Tuple
import psycopg2
from psycopg2.extras import RealDictCursor
from psycopg2.pool import SimpleConnectionPool
import uuid
import json

log = logging.getLogger(__name__)

class StageService:
    """
    Service for managing conversation flow stages.
    
    Provides methods for retrieving the current stage of a conversation,
    determining next stages, and managing stage transitions based on 
    conversation state and user inputs.
    """
    
    def __init__(self, db_pool: SimpleConnectionPool):
        """
        Initialize the stage service.
        
        Args:
            db_pool: Database connection pool for stage data operations
        """
        self.db_pool = db_pool
    
    def get_current_stage(self, conversation_id: str) -> Dict[str, Any]:
        """
        Get the current stage for a conversation.
        
        Args:
            conversation_id: The ID of the conversation
            
        Returns:
            Dictionary containing stage information including:
            - stage_id: Stage ID
            - stage_name: Stage name
            - stage_description: Stage description
            - stage_type: Type of stage
            - stage_selection_template_id: ID of template for stage selection
            - data_extraction_template_id: ID of template for data extraction
            - response_generation_template_id: ID of template for response generation
            - next_stages: List of possible next stages
        """
        conn = None
        try:
            conn = self.db_pool.getconn()
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                # First get the current stage ID from the conversation
                cursor.execute(
                    "SELECT stage_id FROM conversations WHERE conversation_id = %s",
                    (conversation_id,)
                )
                result = cursor.fetchone()
                
                if not result or not result['stage_id']:
                    log.warning(f"No current stage found for conversation {conversation_id}")
                    return self._get_default_stage(cursor)
                
                stage_id = result['stage_id']
                
                # Now get the full stage details
                cursor.execute(
                    """
                    SELECT 
                        s.stage_id, s.stage_name, s.stage_description, 
                        s.stage_type, s.stage_selection_template_id,
                        s.data_extraction_template_id, s.response_generation_template_id,
                        s.is_active, s.created_at, s.updated_at
                    FROM stages s
                    WHERE s.stage_id = %s
                    """,
                    (stage_id,)
                )
                stage = cursor.fetchone()
                
                if not stage:
                    log.error(f"Stage with ID {stage_id} not found")
                    return self._get_default_stage(cursor)
                
                # Get next possible stages
                cursor.execute(
                    """
                    SELECT 
                        next_stage_id, condition, priority
                    FROM stage_transitions
                    WHERE current_stage_id = %s
                    ORDER BY priority DESC
                    """,
                    (stage_id,)
                )
                transitions = cursor.fetchall()
                
                # Get detailed information about next stages
                next_stages = []
                for transition in transitions:
                    cursor.execute(
                        """
                        SELECT 
                            stage_id, stage_name, stage_description,
                            stage_type, stage_selection_template_id,
                            data_extraction_template_id, response_generation_template_id
                        FROM stages
                        WHERE stage_id = %s
                        """,
                        (transition['next_stage_id'],)
                    )
                    next_stage = cursor.fetchone()
                    if next_stage:
                        next_stage_info = dict(next_stage)
                        next_stage_info['condition'] = transition['condition']
                        next_stage_info['priority'] = transition['priority']
                        next_stages.append(next_stage_info)
                
                # Combine all information
                stage_info = dict(stage)
                stage_info['next_stages'] = next_stages
                
                return stage_info
                
        except Exception as e:
            log.error(f"Error getting current stage: {str(e)}")
            # Return a fallback stage in case of errors
            return {
                'stage_id': 'error',
                'stage_name': 'Error Stage',
                'stage_description': 'Fallback stage due to error',
                'stage_type': 'fallback',
                'stage_selection_template_id': None,
                'data_extraction_template_id': None,
                'response_generation_template_id': None,
                'is_active': True,
                'created_at': None,
                'updated_at': None,
                'next_stages': []
            }
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def _get_default_stage(self, cursor) -> Dict[str, Any]:
        """
        Get the default initial stage.
        
        Returns:
            Dictionary containing default stage information
        """
        try:
            # First try to get the default stage from the database by name
            cursor.execute(
                """
                SELECT 
                    s.stage_id, s.stage_name, s.stage_description, 
                    s.stage_type, s.stage_selection_template_id,
                    s.data_extraction_template_id, s.response_generation_template_id,
                    s.is_active, s.created_at, s.updated_at
                FROM stages s
                WHERE s.stage_name = 'Default Conversation Stage'
                LIMIT 1
                """
            )
            stage = cursor.fetchone()
            
            if stage:
                # Get next possible stages for the default stage
                try:
                    cursor.execute(
                        """
                        SELECT 
                            next_stage_id, condition, priority
                        FROM stage_transitions
                        WHERE current_stage_id = %s
                        ORDER BY priority DESC
                        """,
                        (stage['stage_id'],)
                    )
                    transitions = cursor.fetchall()
                    
                    # Get detailed information about next stages
                    next_stages = []
                    for transition in transitions:
                        cursor.execute(
                            """
                            SELECT 
                                stage_id, stage_name, stage_description,
                                stage_type, stage_selection_template_id,
                                data_extraction_template_id, response_generation_template_id
                            FROM stages
                            WHERE stage_id = %s
                            """,
                            (transition['next_stage_id'],)
                        )
                        next_stage = cursor.fetchone()
                        if next_stage:
                            next_stage_info = dict(next_stage)
                            next_stage_info['condition'] = transition['condition']
                            next_stage_info['priority'] = transition['priority']
                            next_stages.append(next_stage_info)
                except Exception as e:
                    log.warning(f"Error getting stage transitions: {str(e)}. Using empty next_stages list.")
                    next_stages = []
                
                stage_info = dict(stage)
                stage_info['next_stages'] = next_stages
                return stage_info
            
            # If no default stage found, create one
            log.warning("No default stage found, creating one...")
            default_stage_id = str(uuid.uuid4())
            cursor.execute(
                """
                INSERT INTO stages (
                    stage_id, business_id, stage_name, stage_description,
                    stage_type, stage_selection_template_id,
                    data_extraction_template_id, response_generation_template_id,
                    is_active
                )
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    default_stage_id,
                    '32a6f42a-b6cf-41e3-a970-bdb051784eff',  # Default business ID
                    'Default Conversation Stage',
                    'Default initial stage for new conversations',
                    'initial',
                    None,  # stage_selection_template_id
                    None,  # data_extraction_template_id
                    None,  # response_generation_template_id
                    True   # is_active
                )
            )
            
            return {
                'stage_id': default_stage_id,
                'stage_name': 'Default Conversation Stage',
                'stage_description': 'Default initial stage for new conversations',
                'stage_type': 'initial',
                'stage_selection_template_id': None,
                'data_extraction_template_id': None,
                'response_generation_template_id': None,
                'is_active': True,
                'created_at': None,
                'updated_at': None,
                'next_stages': []
            }
            
        except Exception as e:
            log.error(f"Error getting default stage: {str(e)}")
            # Return a hardcoded fallback stage
            return {
                'stage_id': '00000000-0000-0000-0000-000000000000',
                'stage_name': 'Fallback Stage',
                'stage_description': 'Fallback stage when database access fails',
                'stage_type': 'fallback',
                'stage_selection_template_id': None,
                'data_extraction_template_id': None,
                'response_generation_template_id': None,
                'is_active': True,
                'created_at': None,
                'updated_at': None,
                'next_stages': []
            }
    
    def determine_next_stage(self, conversation_id: str, message_text: str, context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Determine the next stage based on the message and context.
        
        Args:
            conversation_id: The ID of the conversation
            message_text: The text of the current message
            context: Additional context data for evaluating stage conditions
            
        Returns:
            Dictionary containing the next stage information or None if 
            the stage should not change
        """
        current_stage = self.get_current_stage(conversation_id)
        
        # If there are no next stages defined, keep the current stage
        if not current_stage.get('next_stages'):
            return None
        
        for next_stage in current_stage.get('next_stages', []):
            # Evaluate the condition for this transition
            if self._evaluate_stage_condition(next_stage.get('condition'), message_text, context):
                # Get the full stage details for the next stage
                return self.get_stage_by_id(next_stage['stage_id'])
        
        # If no conditions are met, keep the current stage
        return None
    
    def _evaluate_stage_condition(self, condition: str, message_text: str, context: Dict[str, Any]) -> bool:
        """
        Evaluate a stage transition condition.
        
        Args:
            condition: String representation of the condition logic
            message_text: The message text to evaluate against
            context: Additional context data for condition evaluation
            
        Returns:
            True if the condition is met, False otherwise
        """
        if not condition:
            return False
            
        try:
            # Simple keyword-based conditions
            if condition.startswith('keyword:'):
                keywords = condition[9:].split(',')
                return any(keyword.strip().lower() in message_text.lower() for keyword in keywords)
                
            # Intent-based conditions - would integrate with NLU service
            elif condition.startswith('intent:'):
                intent = condition[7:].strip()
                # This would typically call an NLU service to check intents
                # For now, implement a simple placeholder
                return intent.lower() in message_text.lower()
                
            # Entity-based conditions
            elif condition.startswith('entity:'):
                entity_check = condition[7:].strip()
                entity_type, entity_value = entity_check.split('=')
                # This would typically check entities extracted by NLU
                # For now, implement a simple placeholder
                return entity_value.lower() in message_text.lower()
                
            # Context-based conditions
            elif condition.startswith('context:'):
                context_check = condition[8:].strip()
                context_key, context_value = context_check.split('=')
                return context.get(context_key) == context_value
                
            # Python expression evaluation (limited and potentially unsafe)
            elif condition.startswith('expr:'):
                # Note: This should be used with caution as it evaluates code
                expr = condition[5:].strip()
                
                # Create a safe evaluation environment with limited variables
                eval_locals = {
                    'message': message_text,
                    'context': context,
                    'length': len,
                    'contains': lambda s, sub: sub in s,
                    'startswith': lambda s, sub: s.startswith(sub),
                    'endswith': lambda s, sub: s.endswith(sub)
                }
                
                return eval(expr, {'__builtins__': {}}, eval_locals)
                
            # Default: treat as a simple keyword check
            else:
                return condition.lower() in message_text.lower()
                
        except Exception as e:
            log.error(f"Error evaluating stage condition '{condition}': {str(e)}")
            return False
    
    def get_stage_by_id(self, stage_id: str) -> Optional[Dict[str, Any]]:
        """
        Get stage information by ID.
        
        Args:
            stage_id: The ID of the stage to retrieve
            
        Returns:
            Dictionary containing stage information or None if not found
        """
        conn = None
        try:
            conn = self.db_pool.getconn()
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute(
                    """
                    SELECT 
                        s.id, s.name, s.description, 
                        s.input_template_id, s.output_template_id,
                        s.config
                    FROM stages s
                    WHERE s.id = %s
                    """,
                    (stage_id,)
                )
                stage = cursor.fetchone()
                
                if not stage:
                    log.warning(f"Stage with ID {stage_id} not found")
                    return None
                
                # Get next possible stages
                cursor.execute(
                    """
                    SELECT 
                        next_stage_id, condition, priority
                    FROM stage_transitions
                    WHERE current_stage_id = %s
                    ORDER BY priority DESC
                    """,
                    (stage_id,)
                )
                transitions = cursor.fetchall()
                
                # Get detailed information about next stages
                next_stages = []
                for transition in transitions:
                    cursor.execute(
                        "SELECT id, name, description FROM stages WHERE id = %s",
                        (transition['next_stage_id'],)
                    )
                    next_stage = cursor.fetchone()
                    if next_stage:
                        next_stage_info = dict(next_stage)
                        next_stage_info['condition'] = transition['condition']
                        next_stage_info['priority'] = transition['priority']
                        next_stages.append(next_stage_info)
                
                # Combine all information
                stage_info = dict(stage)
                stage_info['next_stages'] = next_stages
                
                return stage_info
                
        except Exception as e:
            log.error(f"Error getting stage by ID: {str(e)}")
            return None
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def update_conversation_stage(self, conversation_id: str, new_stage_id: str) -> bool:
        """
        Update the current stage of a conversation.
        
        Args:
            conversation_id: The ID of the conversation
            new_stage_id: The ID of the new stage
            
        Returns:
            True if the update was successful, False otherwise
        """
        conn = None
        try:
            conn = self.db_pool.getconn()
            with conn.cursor() as cursor:
                cursor.execute(
                    """
                    UPDATE conversations
                    SET current_stage_id = %s, 
                        updated_at = NOW()
                    WHERE id = %s
                    """,
                    (new_stage_id, conversation_id)
                )
                conn.commit()
                
                if cursor.rowcount > 0:
                    log.info(f"Updated conversation {conversation_id} to stage {new_stage_id}")
                    return True
                else:
                    log.warning(f"Failed to update conversation {conversation_id} to stage {new_stage_id}")
                    return False
                    
        except Exception as e:
            if conn:
                conn.rollback()
            log.error(f"Error updating conversation stage: {str(e)}")
            return False
        finally:
            if conn:
                self.db_pool.putconn(conn)

    @staticmethod
    def get_stage_for_message(conn, business_id: str, user_id: str, 
                             conversation_id: str) -> Optional[Tuple[str, str, str, str, str]]:
        """
        Determine the appropriate stage for the current message.
        
        Args:
            conn: Database connection
            business_id: UUID of the business
            user_id: UUID of the user
            conversation_id: UUID of the conversation
            
        Returns:
            A tuple containing (stage_id, stage_selection_template_id, data_extraction_template_id, response_generation_template_id, agent_id)
            or None if no stage is found
        """
        try:
            cursor = conn.cursor()
            
            # First, check if there's a stage set for this conversation
            cursor.execute(
                """
                SELECT stage_id, status
                FROM conversations
                WHERE conversation_id = %s
                LIMIT 1
                """,
                (conversation_id,)
            )
            
            result = cursor.fetchone()
            if result:
                stage_id, status = result
                if stage_id and status == 'active':
                    # Get the template IDs for this stage
                    cursor.execute(
                        """
                        SELECT stage_id, 
                               stage_selection_template_id, 
                               data_extraction_template_id, 
                               response_generation_template_id,
                               agent_id
                        FROM stages
                        WHERE stage_id = %s
                        LIMIT 1
                        """,
                        (stage_id,)
                    )
                    
                    stage_data = cursor.fetchone()
                    if stage_data:
                        log.info(f"Using existing stage {stage_id} for conversation {conversation_id}")
                        return stage_data
            
            # If no stage is set or conversation is inactive, get the default stage for this business
            cursor.execute(
                """
                SELECT stage_id, 
                       stage_selection_template_id, 
                       data_extraction_template_id, 
                       response_generation_template_id,
                       agent_id
                FROM stages
                WHERE business_id = %s AND stage_name = 'Default Conversation Stage'
                LIMIT 1
                """,
                (business_id,)
            )
            
            stage_data = cursor.fetchone()
            if not stage_data:
                # If no default stage, get the first stage
                cursor.execute(
                    """
                    SELECT stage_id, 
                           stage_selection_template_id, 
                           data_extraction_template_id, 
                           response_generation_template_id,
                           agent_id
                    FROM stages
                    WHERE business_id = %s
                    ORDER BY created_at ASC
                    LIMIT 1
                    """,
                    (business_id,)
                )
                
                stage_data = cursor.fetchone()
            
            if not stage_data:
                log.warning(f"No stages found for business {business_id}")
                return None
            
            # Update the conversation with the new stage_id
            try:
                cursor.execute(
                    """
                    UPDATE conversations
                    SET stage_id = %s,
                        last_updated = NOW(),
                        status = 'active'
                    WHERE conversation_id = %s
                    """,
                    (stage_data[0], conversation_id)
                )
                conn.commit()
                log.info(f"Updated conversation {conversation_id} with stage {stage_data[0]}")
            except Exception as e:
                conn.rollback()
                log.error(f"Error updating conversation stage: {str(e)}")
                # Continue processing even if we couldn't save the stage
            
            return stage_data
            
        except Exception as e:
            log.error(f"Error determining stage: {str(e)}")
            return None
    
    @staticmethod
    def transition_to_stage(conn, conversation_id: str, new_stage_id: str) -> bool:
        """
        Transition a conversation to a new stage.
        
        Args:
            conn: Database connection
            conversation_id: UUID of the conversation
            new_stage_id: UUID of the new stage
            
        Returns:
            Boolean indicating success
        """
        try:
            cursor = conn.cursor()
            
            # Mark current active stages as inactive
            cursor.execute(
                """
                UPDATE conversation_stages
                SET is_active = FALSE
                WHERE conversation_id = %s
                AND is_active = TRUE
                """,
                (conversation_id,)
            )
            
            # Create a new active stage
            cursor.execute(
                """
                INSERT INTO conversation_stages
                (conversation_id, stage_id, is_active, created)
                VALUES (%s, %s, TRUE, NOW())
                """,
                (conversation_id, new_stage_id)
            )
            
            conn.commit()
            return True
            
        except Exception as e:
            conn.rollback()
            log.error(f"Error transitioning stage: {str(e)}")
            return False
    
    @staticmethod
    def get_available_stages(conn, business_id: str) -> List[Dict[str, Any]]:
        """
        Get all available stages for a business.
        
        Args:
            conn: Database connection
            business_id: UUID of the business
            
        Returns:
            List of stage dictionaries with keys: stage_id, name, description
        """
        try:
            cursor = conn.cursor()
            
            cursor.execute(
                """
                SELECT stage_id, name, description
                FROM stages
                WHERE business_id = %s
                ORDER BY name
                """,
                (business_id,)
            )
            
            stages = []
            for row in cursor.fetchall():
                stage_id, name, description = row
                stages.append({
                    'stage_id': stage_id,
                    'name': name,
                    'description': description
                })
            
            return stages
            
        except Exception as e:
            log.error(f"Error getting available stages: {str(e)}")
            return []

================================================================================
File: standard_variables.py
Path: .\backend\message_processing\standard_variables.py
Size: 9988
Modified: 2025-05-04T17:58:25.972094
Created: 2025-04-12T00:37:00.717972
Hash: 3f0921f9deb348e1978bd80e72b091249062e0a8fc69eca1f6838d9930f73b78
Lines: 333
================================================================================
"""
Standard template variable providers.

This module implements providers for common template variables used in the system.
These providers are automatically registered with the TemplateVariableProvider.
"""

import logging
from typing import List, Dict, Any
import json

from .template_variables import TemplateVariableProvider

log = logging.getLogger(__name__)

# ---------- Stage Variables ----------

@TemplateVariableProvider.register_provider('stage_list')
def provide_stage_list(conn, business_id: str, **kwargs) -> str:
    """
    Generate a formatted list of stage names for the business.
    
    Args:
        conn: Database connection
        business_id: UUID of the business
        
    Returns:
        Formatted string representation of stage list
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT stage_name 
            FROM stages 
            WHERE business_id = %s
            ORDER BY stage_name
            """,
            (business_id,)
        )
        
        stages = cursor.fetchall()
        # Extract stage names from tuples
        stage_list = [stage[0] for stage in stages] if stages else []
        
        # Return as a Python list string representation
        return str(stage_list)
        
    except Exception as e:
        log.error(f"Error providing stage_list: {str(e)}")
        return "[]"

@TemplateVariableProvider.register_provider('available_stages')
def provide_available_stages(conn, business_id: str, **kwargs) -> str:
    """
    Generate detailed information about available stages.
    
    Args:
        conn: Database connection
        business_id: UUID of the business
        
    Returns:
        Formatted string with stage details
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT stage_id, stage_name, stage_description, stage_type
            FROM stages 
            WHERE business_id = %s
            ORDER BY stage_name
            """,
            (business_id,)
        )
        
        stages = cursor.fetchall()
        if not stages:
            return "No stages available"
            
        stage_info = []
        for stage in stages:
            stage_info.append(f"{stage['stage_name']}: {stage['stage_description']}")
            
        return "\n".join(stage_info)
        
    except Exception as e:
        log.error(f"Error providing available_stages: {str(e)}")
        return "Error retrieving stages"

# ---------- Conversation Variables ----------

@TemplateVariableProvider.register_provider('conversation_history')
def provide_conversation_history(conn, conversation_id: str, **kwargs) -> str:
    """
    Generate a formatted conversation history.
    
    Args:
        conn: Database connection
        conversation_id: UUID of the conversation
        **kwargs: Additional arguments including:
            - max_messages: Maximum number of messages to retrieve (default: 50)
            - include_timestamps: Whether to include timestamps (default: True)
        
    Returns:
        Formatted string with conversation messages
    """
    try:
        if not conn:
            log.error("No database connection provided")
            return "Error: No database connection"
            
        max_messages = kwargs.get('max_messages', 50)
        include_timestamps = kwargs.get('include_timestamps', True)
        
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT message_content, sender_type, created_at 
            FROM messages 
            WHERE conversation_id = %s 
            ORDER BY created_at DESC
            LIMIT %s
            """,
            (conversation_id, max_messages)
        )
        
        messages = cursor.fetchall()
        if not messages:
            return "No conversation history"
            
        # Reverse to get chronological order
        messages.reverse()
        
        history = []
        for msg in messages:
            sender = "User" if msg['sender_type'] == 'user' else "Assistant"
            timestamp = f"[{msg['created_at'].strftime('%Y-%m-%d %H:%M:%S')}] " if include_timestamps and msg['created_at'] else ""
            history.append(f"{timestamp}{sender}: {msg['message_content']}")
            
        return "\n".join(history)
        
    except Exception as e:
        log.error(f"Error providing conversation_history: {str(e)}", exc_info=True)
        return "Error retrieving conversation history"

@TemplateVariableProvider.register_provider('summary_of_last_conversations')
def provide_conversation_summary(conn, conversation_id: str, **kwargs) -> str:
    """
    Generate a summary of recent messages.
    
    Args:
        conn: Database connection
        conversation_id: UUID of the conversation
        
    Returns:
        Summary of recent messages
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT message_content, sender_type, created_at 
            FROM messages 
            WHERE conversation_id = %s 
            ORDER BY created_at DESC
            LIMIT 3
            """,
            (conversation_id,)
        )
        
        messages = cursor.fetchall()
        if not messages:
            return "No previous conversations"
            
        # Simple summary approach
        summary_parts = []
        for msg in messages:
            sender = "User" if msg['sender_type'] == 'user' else "Assistant"
            content = msg['message_content']
            # Truncate long messages
            if len(content) > 30:
                content = content[:30] + "..."
            summary_parts.append(f"{sender}: {content}")
        
        # Reverse to get chronological order
        summary_parts.reverse()
        return " | ".join(summary_parts)
        
    except Exception as e:
        log.error(f"Error providing conversation_summary: {str(e)}")
        return "Error retrieving conversation summary"

@TemplateVariableProvider.register_provider('N')
def provide_message_count(conn, conversation_id: str, **kwargs) -> str:
    """
    Generate the number of messages in the conversation.
    
    Args:
        conn: Database connection
        conversation_id: UUID of the conversation
        
    Returns:
        Number of messages as a string
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT COUNT(*) as count
            FROM messages 
            WHERE conversation_id = %s
            """,
            (conversation_id,)
        )
        
        result = cursor.fetchone()
        count = result['count'] if result else 0
        
        # Ensure it's at least 1
        return str(max(1, min(count, 10)))
        
    except Exception as e:
        log.error(f"Error providing message_count: {str(e)}")
        return "3"  # Default to 3 if error

# ---------- User Variables ----------

@TemplateVariableProvider.register_provider('user_name')
def provide_user_name(conn, user_id: str, **kwargs) -> str:
    """
    Generate the user's full name.
    
    Args:
        conn: Database connection
        user_id: UUID of the user
        
    Returns:
        User's full name
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT first_name, last_name
            FROM users 
            WHERE user_id = %s
            """,
            (user_id,)
        )
        
        user = cursor.fetchone()
        if not user:
            return "Guest"
            
        return f"{user['first_name']} {user['last_name']}".strip()
        
    except Exception as e:
        log.error(f"Error providing user_name: {str(e)}")
        return "Guest"

# ---------- Business Variables ----------

@TemplateVariableProvider.register_provider('business_name')
def provide_business_name(conn, business_id: str, **kwargs) -> str:
    """
    Generate the business name.
    
    Args:
        conn: Database connection
        business_id: UUID of the business
        
    Returns:
        Business name
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT business_name
            FROM businesses 
            WHERE business_id = %s
            """,
            (business_id,)
        )
        
        business = cursor.fetchone()
        if not business:
            return "Our Business"
            
        return business['business_name']
        
    except Exception as e:
        log.error(f"Error providing business_name: {str(e)}")
        return "Our Business"

# ---------- Utility Functions ----------

@TemplateVariableProvider.register_provider('current_time')
def provide_current_time(**kwargs) -> str:
    """
    Generate the current time.
    
    Returns:
        Current time string
    """
    from datetime import datetime
    return datetime.now().strftime("%H:%M:%S")

@TemplateVariableProvider.register_provider('current_date')
def provide_current_date(**kwargs) -> str:
    """
    Generate the current date.
    
    Returns:
        Current date string
    """
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d")

@TemplateVariableProvider.register_provider('user_message')
def provide_user_message(conn, message_content: str, **kwargs) -> str:
    """
    Provide the current user message.
    
    Args:
        conn: Database connection
        message_content: The content of the current message
        
    Returns:
        The user message content
    """
    return message_content

================================================================================
File: template_service.py
Path: .\backend\message_processing\template_service.py
Size: 12826
Modified: 2025-05-10T15:46:28.112463
Created: 2025-04-09T02:15:13.465105
Hash: 67a1868167a5a9f12dfa34500170e97780a93dcbc597b42b03a5ee6174cb8735
Lines: 315
================================================================================
"""
Template service for message processing.

This module handles the retrieval and application of templates used in 
the different stages of message processing.
"""

import logging
import json
from typing import Dict, Any, List, Optional, Set

# Import the variable provider system
from .template_variables import TemplateVariableProvider

# Import standard variables to ensure they're registered
from . import standard_variables

log = logging.getLogger(__name__)

class TemplateService:
    """
    Service for managing and applying templates during message processing.
    
    Handles template retrieval, variable substitution, and context building
    for the different stages of message processing.
    """
    
    @staticmethod
    def get_template(conn, template_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve a template by ID.
        
        Args:
            conn: Database connection
            template_id: UUID of the template
            
        Returns:
            Template data as a dictionary or None if not found
        """
        try:
            cursor = conn.cursor()
            
            cursor.execute(
                """
                SELECT template_id, template_name, template_type, content, 
                       system_prompt, business_id
                FROM templates
                WHERE template_id = %s
                """,
                (template_id,)
            )
            
            row = cursor.fetchone()
            if row:
                template_id, template_name, template_type, content, system_prompt, business_id = row
                
                # Extract variables from template content
                variables = TemplateVariableProvider.extract_variables_from_template(content)
                system_variables = TemplateVariableProvider.extract_variables_from_template(system_prompt or '')
                
                # Combine all unique variables
                all_variables = variables.union(system_variables)
                
                return {
                    'template_id': template_id,
                    'template_name': template_name,
                    'template_type': template_type,
                    'content': content,
                    'system_prompt': system_prompt or '',
                    'business_id': business_id,
                    'variables': list(all_variables)
                }
            
            return None
            
        except Exception as e:
            log.error(f"Error retrieving template {template_id}: {str(e)}")
            return None
    
    @staticmethod
    def apply_template(template: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Apply template with variable substitution.
        
        Args:
            template: Template object with content and metadata
            context: Context dictionary with variable values
            
        Returns:
            Dictionary with processed template content and system prompt
        """
        try:
            content = template['content']
            system_prompt = template.get('system_prompt', '')
            
            # Get variables from template if available, otherwise extract them
            variables = set(template.get('variables', []))
            if not variables:
                content_vars = TemplateVariableProvider.extract_variables_from_template(content)
                system_vars = TemplateVariableProvider.extract_variables_from_template(system_prompt)
                variables = content_vars.union(system_vars)
            
            # Apply variable substitution
            if content and variables:
                # Log variable info for debugging
                log.debug(f"Template variables: {variables}")
                log.debug(f"Context keys: {context.keys()}")
                
                # Process each variable
                for var_name in variables:
                    # Get the variable value from context
                    var_value = context.get(var_name, f"[Missing: {var_name}]")
                    var_value_str = str(var_value)
                    
                    # Replace double curly braces first (to avoid conflicts)
                    double_placeholder = f"{{{{{var_name}}}}}"
                    if double_placeholder in content:
                        content = content.replace(double_placeholder, var_value_str)
                        
                    if system_prompt and double_placeholder in system_prompt:
                        system_prompt = system_prompt.replace(double_placeholder, var_value_str)
                    
                    # Then replace single curly braces
                    single_placeholder = f"{{{var_name}}}"
                    if single_placeholder in content:
                        content = content.replace(single_placeholder, var_value_str)
                        
                    if system_prompt and single_placeholder in system_prompt:
                        system_prompt = system_prompt.replace(single_placeholder, var_value_str)
            
            return {
                'content': content,
                'system_prompt': system_prompt
            }
            
        except Exception as e:
            log.error(f"Error applying template: {str(e)}")
            return {
                'content': template.get('content', ''),
                'system_prompt': template.get('system_prompt', '')
            }
    
    @staticmethod
    def build_context(conn, business_id: str, user_id: str, conversation_id: str, message_content: str) -> Dict[str, Any]:
        """
        Build context for template substitution.
        
        Args:
            conn: Database connection
            business_id: UUID of the business
            user_id: UUID of the user
            conversation_id: UUID of the conversation
            message_content: Content of the current message
            
        Returns:
            Dictionary containing context variables
        """
        try:
            # Get business and user info for basic context
            cursor = conn.cursor()
            
            # Get business info
            cursor.execute(
                """
                SELECT business_name, business_description 
                FROM businesses 
                WHERE business_id = %s
                """,
                (business_id,)
            )
            result = cursor.fetchone()
            business_name = result['business_name'] if result else ''
            business_description = result['business_description'] if result else ''
            
            # Get user info
            cursor.execute(
                """
                SELECT first_name, last_name, email 
                FROM users 
                WHERE user_id = %s
                """,
                (user_id,)
            )
            result = cursor.fetchone()
            user_info = {
                'first_name': result['first_name'] if result else '',
                'last_name': result['last_name'] if result else '',
                'email': result['email'] if result else ''
            }
            
            # Get conversation history
            cursor.execute(
                """
                SELECT message_content, sender_type, created_at 
                FROM messages 
                WHERE conversation_id = %s 
                ORDER BY created_at ASC
                """,
                (conversation_id,)
            )
            messages = cursor.fetchall()
            
            # Build conversation history
            conversation_history = []
            for msg in messages:
                conversation_history.append({
                    'content': msg['message_content'],
                    'sender': msg['sender_type'],
                    'timestamp': msg['created_at'].isoformat() if msg['created_at'] else '',
                    'formatted_timestamp': msg['created_at'].strftime('%Y-%m-%d %H:%M:%S') if msg['created_at'] else ''
                })
            
            # Limit the number of messages in history
            max_history_messages = 50
            if len(conversation_history) > max_history_messages:
                conversation_history = conversation_history[-max_history_messages:]
            
            # Build basic context
            context = {
                'business': {
                    'name': business_name,
                    'description': business_description
                },
                'user': user_info,
                'conversation': {
                    'id': conversation_id,
                    'history': conversation_history,
                    'message_count': len(conversation_history)
                },
                'current_message': message_content,
                'user_message': message_content
            }
            
            # Generate dynamic variable values using the provider system
            dynamic_variables = TemplateVariableProvider.generate_variable_values(
                conn=conn,
                business_id=business_id,
                user_id=user_id,
                conversation_id=conversation_id,
                message_content=message_content
            )
            
            # Merge dynamic variables with basic context
            context.update(dynamic_variables)
            
            return context
            
        except Exception as e:
            log.error(f"Error building context: {str(e)}")
            # Return minimal context on error
            basic_context = {
                'business': {'name': '', 'description': ''},
                'user': {'first_name': '', 'last_name': '', 'email': ''},
                'conversation': {'id': conversation_id, 'history': []},
                'current_message': message_content
            }
            
            # Try to get at least the critical variables even in error case
            try:
                critical_vars = {'stage_list', 'summary_of_last_conversations', 'N'}
                error_vars = TemplateVariableProvider.generate_variable_values(
                    conn=conn,
                    business_id=business_id,
                    user_id=user_id,
                    conversation_id=conversation_id,
                    message_content=message_content,
                    template_vars=critical_vars
                )
                basic_context.update(error_vars)
            except Exception as inner_e:
                log.error(f"Error generating critical variables: {str(inner_e)}")
                # Set fallback values
                basic_context.update({
                    'stage_list': '[]',
                    'summary_of_last_conversations': 'Error retrieving conversation history',
                    'N': '0'
                })
                
            return basic_context
    
    @staticmethod
    def get_templates(conn, business_id: str):
        """
        Retrieve all templates for a given business.
        """
        try:
            cursor = conn.cursor()
            cursor.execute(
                """
                SELECT template_id, template_name, template_type, content, system_prompt, business_id
                FROM templates
                WHERE business_id = %s
                """,
                (business_id,)
            )
            rows = cursor.fetchall()
            templates = []
            for row in rows:
                template_id, template_name, template_type, content, system_prompt, business_id = row
                variables = TemplateVariableProvider.extract_variables_from_template(content)
                system_variables = TemplateVariableProvider.extract_variables_from_template(system_prompt or '')
                all_variables = variables.union(system_variables)
                templates.append({
                    'template_id': template_id,
                    'template_name': template_name,
                    'template_type': template_type,
                    'content': content,
                    'system_prompt': system_prompt or '',
                    'business_id': business_id,
                    'variables': list(all_variables)
                })
            return templates
        except Exception as e:
            log.error(f"Error retrieving templates for business {business_id}: {str(e)}")
            return []

================================================================================
File: template_variables.py
Path: .\backend\message_processing\template_variables.py
Size: 8954
Modified: 2025-05-09T23:22:10.182573
Created: 2025-04-12T00:36:27.170662
Hash: 9b7cba6a96e9105ce5fd9fcfb8ae279976bad3fb9dfeab98c3c62f8c528d1a71
Lines: 238
================================================================================
"""
Template variable management system.

This module provides a centralized system for registering, retrieving, and 
generating values for template variables used in the messaging system.
"""

import logging
import inspect
from typing import Dict, Any, Callable, List, Optional, Set, Tuple
import re

log = logging.getLogger(__name__)

class TemplateVariableProvider:
    """
    Manages template variables and their providers.
    
    This class serves as a registry for template variables and methods that 
    can generate their values at runtime based on context.
    """
    
    # Registry of variable providers and their metadata
    _providers: Dict[str, Dict[str, Any]] = {}
    
    # Cache of variable names extracted from templates
    _variable_cache: Dict[str, Set[str]] = {}
    
    @classmethod
    def register_provider(cls, variable_name: str, description: str = None, auth_requirement: str = 'internal_key'):
        """
        Decorator to register a method as a provider for a specific variable.
        
        Args:
            variable_name: The name of the template variable
            description: Optional description of what the variable provides
            auth_requirement: Authentication requirement ('none', 'business_key', or 'internal_key')
            
        Returns:
            Decorator function
        """
        def decorator(func):
            cls._providers[variable_name] = {
                'provider': func,
                'description': description,
                'is_class_method': inspect.ismethod(func) and hasattr(func, '__self__'),
                'auth_requirement': auth_requirement
            }
            log.debug(f"Registered provider for variable: {variable_name}")
            return func
        return decorator
    
    @classmethod
    def get_provider(cls, variable_name: str) -> Optional[Dict[str, Any]]:
        """
        Get the provider function and metadata for a variable.
        
        Args:
            variable_name: The name of the template variable
            
        Returns:
            Dictionary containing provider function and metadata, or None if not found
        """
        return cls._providers.get(variable_name)
    
    @classmethod
    def is_variable_registered(cls, variable_name: str) -> bool:
        """
        Check if a variable has a registered provider.
        
        Args:
            variable_name: The name of the template variable
            
        Returns:
            True if the variable has a provider, False otherwise
        """
        return variable_name in cls._providers
    
    @classmethod
    def get_all_variable_names(cls) -> List[str]:
        """
        Get all registered variable names.
        
        Returns:
            List of registered variable names
        """
        return list(cls._providers.keys())
    
    @classmethod
    def extract_variables_from_template(cls, template_content: str) -> Set[str]:
        """
        Extract all variable names from a template.
        
        Args:
            template_content: The template text with variables in {variable_name} or {{variable_name}} format
            
        Returns:
            Set of variable names found in the template
        """
        if not template_content:
            return set()
            
        # Cache check
        if template_content in cls._variable_cache:
            return cls._variable_cache[template_content]
            
        # Extract variables using regex - handle both single and double curly braces
        single_brace_pattern = r'{([^{}]+)}'
        double_brace_pattern = r'{{([^{}]+)}}'
        
        # Get matches for both patterns
        single_vars = set(re.findall(single_brace_pattern, template_content))
        double_vars = set(re.findall(double_brace_pattern, template_content))
        
        # Filter out single brace matches that are part of double braces
        filtered_single_vars = set()
        for var in single_vars:
            if not any(f"{{{{{var}}}}}" in template_content for var in [var]):
                filtered_single_vars.add(var)
        
        # Combine all variables
        variables = filtered_single_vars.union(double_vars)
        
        # Cache the result
        cls._variable_cache[template_content] = variables
        
        return variables
    
    @classmethod
    def validate_template_variables(cls, template_content: str) -> Dict[str, bool]:
        """
        Validate if all variables in a template have registered providers.
        
        Args:
            template_content: The template text with variables
            
        Returns:
            Dictionary mapping variable names to validation status
        """
        variables = cls.extract_variables_from_template(template_content)
        return {var: cls.is_variable_registered(var) for var in variables}
    
    @classmethod
    def generate_variable_values(
        cls, 
        conn, 
        business_id: str, 
        user_id: str, 
        conversation_id: str, 
        message_content: str,
        template_vars: Optional[Set[str]] = None
    ) -> Dict[str, Any]:
        """
        Generate values for all requested variables.
        
        Args:
            conn: Database connection
            business_id: UUID of the business
            user_id: UUID of the user
            conversation_id: UUID of the conversation
            message_content: Content of the current message
            template_vars: Optional set of specific variable names to generate
            
        Returns:
            Dictionary mapping variable names to their values
        """
        variable_values = {}
        
        # Default context object that gets passed to all providers
        base_context = {
            'conn': conn,  # Pass the connection to providers
            'business_id': business_id,
            'user_id': user_id,
            'conversation_id': conversation_id,
            'message_content': message_content
        }
        
        # Get the current stage and agent_id
        cursor = None
        try:
            cursor = conn.cursor()
            cursor.execute(
                """
                SELECT s.agent_id
                FROM conversations c
                JOIN stages s ON c.stage_id = s.stage_id
                WHERE c.conversation_id = %s
                """,
                (conversation_id,)
            )
            agent_result = cursor.fetchone()
            if agent_result and agent_result[0]:
                base_context['agent_id'] = agent_result[0]
        except Exception as e:
            log.error(f"Error getting agent_id: {str(e)}")
        finally:
            if cursor:
                try:
                    cursor.close()
                except Exception as e:
                    log.error(f"Error closing cursor: {str(e)}")
        
        # If specific variables requested, only process those
        variables_to_process = template_vars or cls.get_all_variable_names()
        
        # Generate values for each requested variable
        for var_name in variables_to_process:
            provider_info = cls.get_provider(var_name)
            if provider_info:
                try:
                    provider = provider_info['provider']
                    # Get the parameters the provider expects
                    sig = inspect.signature(provider)
                    params = {}
                    
                    # Only pass parameters that the provider function expects
                    for param_name in sig.parameters:
                        if param_name in base_context:
                            params[param_name] = base_context[param_name]
                    
                    # Call the provider with appropriate parameters
                    if provider_info['is_class_method']:
                        # For class methods, pass the class as first argument
                        value = provider(provider.__self__.__class__, **params)
                    else:
                        # For regular functions
                        value = provider(**params)
                        
                    variable_values[var_name] = value
                except Exception as e:
                    log.error(f"Error generating value for variable '{var_name}': {str(e)}")
                    variable_values[var_name] = f"[Error: {str(e)}]"
            else:
                # No provider found
                log.warning(f"No provider found for variable: {var_name}")
                variable_values[var_name] = f"[Undefined variable: {var_name}]"
        
        return variable_values

================================================================================
File: template_variable_provider.py
Path: .\backend\message_processing\template_variable_provider.py
Size: 4865
Modified: 2025-05-10T15:51:44.343795
Created: 2025-05-10T13:41:18.120148
Hash: dc381da0e5bc02f7171a4ad596ede5cd6907db18712e1fd2afcab9a9814bdf50
Lines: 110
================================================================================
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class TemplateVariableProvider:
    def __init__(self, conn):
        self.conn = conn

    def get_test_context(self, business_id, agent_id):
        """
        Generate a test context with sample data for template variable substitution.
        This provides realistic test data for template testing.
        """
        try:
            # Get business and agent info
            with self.conn.cursor() as cur:
                # Get business info
                cur.execute("""
                    SELECT name, description 
                    FROM businesses 
                    WHERE business_id = %s
                """, (business_id,))
                business = cur.fetchone()

                # Get agent info
                cur.execute("""
                    SELECT name, description 
                    FROM agents 
                    WHERE agent_id = %s AND business_id = %s
                """, (agent_id, business_id))
                agent = cur.fetchone()

                # Get a sample user
                cur.execute("""
                    SELECT user_id, name, email, phone
                    FROM users 
                    WHERE business_id = %s 
                    LIMIT 1
                """, (business_id,))
                user = cur.fetchone()

            # Create test context with sample data
            context = {
                # Business context
                'business': {
                    'id': business_id,
                    'name': business['name'] if business else 'Test Business',
                    'description': business['description'] if business else 'Test Business Description'
                },
                # Agent context
                'agent': {
                    'id': agent_id,
                    'name': agent['name'] if agent else 'Test Agent',
                    'description': agent['description'] if agent else 'Test Agent Description'
                },
                # User context
                'user': {
                    'id': user['user_id'] if user else 'test_user_123',
                    'name': user['name'] if user else 'Test User',
                    'email': user['email'] if user else 'test@example.com',
                    'phone': user['phone'] if user else '+1234567890'
                },
                # System context
                'system': {
                    'timestamp': datetime.now().isoformat(),
                    'version': '1.0.0'
                },
                # Sample conversation context
                'conversation': {
                    'id': 'test_conversation_123',
                    'start_time': datetime.now().isoformat(),
                    'last_message': 'Hello, how can I help you today?',
                    'stage': 'greeting'
                },
                # Sample data extraction context
                'extracted_data': {
                    'name': 'John Doe',
                    'email': 'john@example.com',
                    'phone': '+1234567890',
                    'preferences': ['email', 'sms'],
                    'last_interaction': '2024-03-20T10:00:00Z'
                },
                # Additional realistic test values for common template variables
                'message_content': "How do I update my account information?",
                'available_stages': ["Account Update", "Billing", "Support", "Technical Help"],
                'field_name': "account_number",
                'fields_to_extract': ["account_number", "email", "phone"],
                'response': "Your account information has been updated successfully.",
                'stage': "Account Update",
                'stage_list': ["Account Update", "Billing", "Support"],
                'conversation_history': [
                    {"sender": "user", "content": "Hi, I need help with my account."},
                    {"sender": "assistant", "content": "Sure, what do you need to update?"}
                ],
            }

            return context

        except Exception as e:
            logger.error(f"Error generating test context: {str(e)}")
            # Return a basic context if database operations fail
            return {
                'business': {'id': business_id, 'name': 'Test Business'},
                'agent': {'id': agent_id, 'name': 'Test Agent'},
                'user': {'id': 'test_user_123', 'name': 'Test User'},
                'system': {'timestamp': datetime.now().isoformat()},
                'conversation': {'id': 'test_conversation_123', 'stage': 'greeting'},
                'extracted_data': {'name': 'John Doe', 'email': 'john@example.com'}
            } 

================================================================================
File: user_update_service.py
Path: .\backend\message_processing\user_update_service.py
Size: 4844
Modified: 2025-05-02T10:52:19.965407
Created: 2025-04-17T14:02:34.412297
Hash: d108683da89ad50a2b035ed73850e829372bae7a328943a2cc224275dbd120a4
Lines: 120
================================================================================
# -*- coding: utf-8 -*-"""
from typing import Dict, Any, Optional
import logging
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv

log = logging.getLogger(__name__)

class UserUpdateService:
    """Service for updating user information from extracted data."""
    
    def __init__(self):
        load_dotenv()
        self.db_config = {
            "dbname": os.getenv("DB_NAME", "icmp_db"),
            "user": os.getenv("DB_USER", "icmp_user"),
            "password": os.getenv("DB_PASSWORD"),
            "host": os.getenv("DB_HOST", "localhost"),
            "port": os.getenv("DB_PORT", "5432")
        }
    
    def _get_db_connection(self):
        """Create and return a database connection."""
        return psycopg2.connect(**self.db_config)
    
    def create_user(self, user_id: str, user_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Create a new user in the database.
        
        Args:
            user_id: UUID of the user to create
            user_data: Dictionary containing user data
            
        Returns:
            Created user data or None if creation fails
        """
        try:
            with self._get_db_connection() as conn:
                with conn.cursor(cursor_factory=DictCursor) as cursor:
                    # Set default values for required fields if not provided
                    first_name = user_data.get('first_name', 'Guest')
                    last_name = user_data.get('last_name', 'User')
                    email = user_data.get('email', f"{user_id}@placeholder.com")
                    
                    # Insert the new user
                    cursor.execute(
                        """
                        INSERT INTO users (user_id, first_name, last_name, email)
                        VALUES (%s, %s, %s, %s)
                        RETURNING *
                        """,
                        (user_id, first_name, last_name, email)
                    )
                    
                    conn.commit()
                    new_user = cursor.fetchone()
                    return dict(new_user) if new_user else None
                    
        except Exception as e:
            log.error(f"Error creating user {user_id}: {str(e)}")
            return None
    
    def update_user(self, user_id: str, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update user information in the database. Creates user if does not exist.
        
        Args:
            user_id: UUID of the user to update
            update_data: Dictionary containing fields to update
            
        Returns:
            Updated user data or None if update fails
        """
        if not update_data:
            log.warning("No data provided for update")
            return None
        
        allowed_fields = ["first_name", "last_name", "email", "phone", "address"]
        filtered_data = {k: v for k, v in update_data.items() if k in allowed_fields}
        
        if not filtered_data:
            log.warning("No valid fields to update")
            return None
            
        try:
            with self._get_db_connection() as conn:
                with conn.cursor(cursor_factory=DictCursor) as cursor:
                    # Check if user exists
                    cursor.execute(
                        "SELECT * FROM users WHERE user_id = %s",
                        (user_id,)
                    )
                    user_exists = cursor.fetchone() is not None
                    
                    if not user_exists:
                        log.info(f"User {user_id} not found, creating new user")
                        return self.create_user(user_id, filtered_data)
                    
                    # Build update query
                    set_clause = ", ".join([f"{k} = %s" for k in filtered_data.keys()])
                    values = list(filtered_data.values())
                    values.append(user_id)
                    
                    # Execute update
                    cursor.execute(
                        f"UPDATE users SET {set_clause} WHERE user_id = %s RETURNING *",
                        values
                    )
                    
                    conn.commit()
                    updated_user = cursor.fetchone()
                    return dict(updated_user) if updated_user else None
                    
        except Exception as e:
            # Log the error safely before re-raising
            log.error(f"Error during update_user for {user_id}: {e!r}") 
            # Re-raise the original exception to be caught by the caller
            raise e

================================================================================
File: __init__.py
Path: .\backend\message_processing\__init__.py
Size: 655
Modified: 2025-05-02T10:52:19.981719
Created: 2025-04-09T02:12:14.455094
Hash: 5cab0a87ae709b36615e2cca3a41660753698d8b4701306c5bf54ce144fd34e1
Lines: 23
================================================================================
"""
Message processing package for ICMP.

This package contains the classes and functions for handling messages in the
Intelligent Conversation Management Platform (ICMP).
"""

from .message_handler import MessageHandler
from .stage_service import StageService
from .context_service import ContextService
from .template_variables import TemplateVariableProvider
from .template_service import TemplateService

# Import variables package to ensure all providers are registered
from . import variables

__all__ = [
    'MessageHandler', 
    'StageService', 
    'ContextService',
    'TemplateVariableProvider',
    'TemplateService'
]

================================================================================
File: agent_stages.py
Path: .\backend\message_processing\variables\agent_stages.py
Size: 2129
Modified: 2025-05-09T23:41:04.521813
Created: 2025-05-04T11:04:30.788213
Hash: 4fadf54c7be6935d85ea4607d8ac86b7fd85ef86d4c742bf747e5eda551b4821
Lines: 67
================================================================================
"""
Variable provider for fetching stages associated with a specific agent.
"""

import logging
from typing import Dict, List, Optional
from backend.db import get_db_connection, release_db_connection
from backend.message_processing.template_variables import TemplateVariableProvider

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider(
    'agent_stages',
    description="Returns a list of stages associated with a specific agent",
    auth_requirement='business_key'
)
def provide_agent_stages(conn, agent_id: str = None, **kwargs) -> Optional[List[Dict]]:
    """
    Fetch stages associated with a specific agent.
    
    Args:
        conn: Database connection
        agent_id: Optional. The ID of the agent to fetch stages for. If not provided, uses the current agent ID from context.
        **kwargs: Additional context parameters
        
    Returns:
        List of dictionaries containing stage information, or None if error occurs
    """
    if not agent_id:
        log.error("No agent_id provided")
        return None
        
    try:
        cursor = conn.cursor()
        
        # Query to get stages associated with the agent
        cursor.execute("""
            SELECT 
                s.stage_id,
                s.stage_name,
                s.stage_description,
                s.stage_type,
                s.created_at
            FROM stages s
            WHERE s.agent_id = %s
            ORDER BY s.created_at DESC
        """, (agent_id,))
        
        stages = []
        for row in cursor.fetchall():
            stages.append({
                "stage_id": row[0],
                "stage_name": row[1],
                "stage_description": row[2],
                "stage_type": row[3],
                "created_at": row[4].isoformat() if row[4] else None
            })
        
        return stages
        
    except Exception as e:
        log.error(f"Error fetching agent stages: {str(e)}")
        return None
    
    finally:
        if conn:
            release_db_connection(conn) 

================================================================================
File: Al_conversation_history.py
Path: .\backend\message_processing\variables\Al_conversation_history.py
Size: 2101
Modified: 2025-05-03T12:37:04.482587
Created: 2025-05-03T12:37:02.624053
Hash: 478e9fff62d957fdbc8a0c376b3d39b18dff1b0b21a194363038175aaca86814
Lines: 50
================================================================================
from backend.message_processing.template_variables import TemplateVariableProvider
import logging

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider('all_conversation_history')
def provide_all_conversation_history(conn, **kwargs) -> str:
    """
    Generate a formatted history of all messages across all conversations.
    Args:
        conn: Database connection
        **kwargs: Additional arguments including:
            - max_messages: Maximum number of messages to retrieve (default: 100)
            - include_timestamps: Whether to include timestamps (default: False)
    Returns:
        Formatted string with all messages
    """
    try:
        if not conn:
            log.error("No database connection provided")
            return "Error: No database connection"
        max_messages = kwargs.get('max_messages', 100)
        include_timestamps = kwargs.get('include_timestamps', False)
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT message_content, sender_type, created_at, conversation_id 
            FROM messages 
            ORDER BY created_at DESC
            LIMIT %s
            """,
            (max_messages,)
        )
        messages = cursor.fetchall()
        if not messages:
            return "No messages found"
        history = []
        for msg in messages:
            sender_type = str(msg['sender_type']).lower()
            if sender_type in ['assistant', 'bot', 'system']:
                sender = "Assistant"
            else:
                sender = "User"
            timestamp = f"[{msg['created_at'].isoformat()}] " if include_timestamps and msg['created_at'] else ""
            conversation_id = f"[Conversation: {msg['conversation_id']}] "
            history.append(f"{conversation_id}{timestamp}{sender}: {msg['message_content']}")
        return "\n".join(history)
    except Exception as e:
        log.error(f"Error providing all_conversation_history: {str(e)}")
        return "Error retrieving conversation history" 

================================================================================
File: available_stages.py
Path: .\backend\message_processing\variables\available_stages.py
Size: 1973
Modified: 2025-05-09T23:43:01.120324
Created: 2025-04-14T17:35:15.466984
Hash: 4370d7163b7c935e212ddcd6eb18db09e923042e9e12ef1911a9c156c273ef0d
Lines: 61
================================================================================
"""
Variable provider for available conversation stages.

This module provides functionality to retrieve and format available conversation stages
for a business from the database.
"""

from typing import Dict, Any, List
from .base_provider import BaseVariableProvider
from .database_utils import DatabaseUtils
from backend.message_processing.template_variables import TemplateVariableProvider
import logging

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider(
    'available_stages',
    description='Returns a list of available conversation stages for a business',
    auth_requirement='business_key'
)
def provide_available_stages(conn, business_id: str, **kwargs) -> str:
    """
    Generate a formatted list of available stages for a business.
    
    Args:
        conn: Database connection
        business_id: ID of the business
        
    Returns:
        Formatted string with available stages
    """
    try:
        if not conn:
            log.error("No database connection provided")
            return "Error: No database connection"
            
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT stage_name, stage_description
            FROM stages 
            WHERE business_id = %s
            ORDER BY stage_name
            """,
            (business_id,)
        )
        
        stages = cursor.fetchall()
        if not stages:
            return "No stages available"
            
        result = []
        for stage in stages:
            name = stage['stage_name'] or "Unnamed Stage"
            desc = stage['stage_description'] or "No description available"
            result.append(f"{name}: {desc}")
            
        return "\n".join(result)
    except Exception as e:
        log.error(f"Error providing available_stages: {str(e)}", exc_info=True)
        return "Error retrieving available stages"

================================================================================
File: base_provider.py
Path: .\backend\message_processing\variables\base_provider.py
Size: 3557
Modified: 2025-05-04T17:07:00.093093
Created: 2025-05-04T16:52:38.575601
Hash: 2efc6595f52ee32f0a94240174c515c2bb9c027d5c2395bf6456cd50cba841b1
Lines: 98
================================================================================
"""
Base class for variable providers.

Provides common functionality for all variable providers including error handling,
parameter validation, and database access utilities.
"""

import logging
from typing import Any, List, Dict, Optional, Callable
from ..template_variables import TemplateVariableProvider

log = logging.getLogger(__name__)

class BaseVariableProvider:
    """Base class for all variable providers."""
    
    @staticmethod
    def handle_error(error: Exception, fallback_value: Any, variable_name: str) -> Any:
        """
        Standard error handling for variable providers.
        
        Args:
            error: The exception that occurred
            fallback_value: Value to return on error
            variable_name: Name of the variable being processed
            
        Returns:
            The fallback value
        """
        log.error(f"Error in {variable_name} provider: {str(error)}")
        return fallback_value
    
    @staticmethod
    def validate_parameters(required_params: List[str], **kwargs) -> None:
        """
        Validate that all required parameters are present.
        
        Args:
            required_params: List of required parameter names
            **kwargs: Parameters to validate
            
        Raises:
            ValueError if any required parameters are missing
        """
        missing = [p for p in required_params if p not in kwargs]
        if missing:
            raise ValueError(f"Missing required parameters: {missing}")
    
    @staticmethod
    def execute_query(conn, query: str, params: tuple) -> List[Dict]:
        """
        Execute a database query with error handling.
        
        Args:
            conn: Database connection
            query: SQL query to execute
            params: Query parameters
            
        Returns:
            List of result rows as dictionaries
        """
        try:
            cursor = conn.cursor()
            cursor.execute(query, params)
            return cursor.fetchall()
        except Exception as e:
            log.error(f"Database query failed: {str(e)}")
            return []
    
    @classmethod
    def register_provider(cls, variable_name: str, description: str = None) -> Callable:
        """
        Decorator to register a variable provider with standardized error handling.
        
        Args:
            variable_name: Name of the variable to register
            description: Optional description of what the variable provides
            
        Returns:
            Decorator function
        """
        def decorator(func: Callable) -> Callable:
            def wrapper(*args, **kwargs) -> Any:
                try:
                    # For class methods, the first argument is the class itself
                    if args and isinstance(args[0], type):
                        return func(*args, **kwargs)
                    # For instance methods, add cls as first argument
                    return func(cls, *args, **kwargs)
                except Exception as e:
                    return cls.handle_error(e, f"[Error: {variable_name}]", variable_name)
            
            # Register the wrapper with the template variable system
            TemplateVariableProvider.register_provider(variable_name, description)(wrapper)
            
            # Return the original function to preserve the class method
            return func
        return decorator 

================================================================================
File: business_info.py
Path: .\backend\message_processing\variables\business_info.py
Size: 5264
Modified: 2025-05-09T23:35:52.180233
Created: 2025-05-03T14:37:40.400513
Hash: 70e580dc5beb88c8859391b1227e91d183f128ee64ba46932960a3aa045fa1f3
Lines: 135
================================================================================
"""
Business Information Variable Provider

Provides detailed information about a business including:
- Basic info (name, description)
- Contact details (phone, website)
- Address
- Metadata (creation date, owner, etc.)
"""
import logging
from backend.message_processing.template_variables import TemplateVariableProvider
from backend.db import get_db_connection

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider(
    'business_info',
    description='Provides detailed information about a business including name, description, contact details, and address',
    auth_requirement='business_key'
)
def provide_business_info(business_id, **kwargs):
    """
    Generate business information based on the business ID.
    
    Args:
        business_id: UUID of the business
        **kwargs: Additional arguments (e.g., format='text' or 'json')
        
    Returns:
        Formatted business information
    """
    log.info(f"Starting business_info provider for business_id: {business_id}")
    log.info(f"Additional arguments: {kwargs}")
    
    # Default configuration
    config = {
        'include_address': True,
        'include_contact': True,
        'format': kwargs.get('format', 'text')
    }
    log.info(f"Configuration: {config}")
    
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            # Query business details
            cursor.execute("""
                SELECT
                    business_id,
                    api_key,
                    internal_api_key,
                    owner_id,
                    business_name,
                    business_description,
                    address,
                    phone_number,
                    website,
                    first_stage_id,
                    facebook_page_id,
                    created_at,
                    updated_at,
                    business_information
                FROM businesses
                WHERE business_id = %s
            """, (business_id,))
            
            business_data = cursor.fetchone()
            if not business_data:
                return "Business not found"
                
            log.info(f"Retrieved business data: {business_data}")
            
            # Prepare structured data
            prepared_data = {
                'id': business_data['business_id'],
                'name': business_data['business_name'],
                'description': business_data['business_description'],
                'additional_info': business_data['business_information'],
                'metadata': {
                    'created_at': business_data['created_at'].isoformat(),
                    'updated_at': business_data['updated_at'].isoformat(),
                    'owner_id': business_data['owner_id'],
                    'first_stage_id': business_data['first_stage_id'],
                    'facebook_page_id': business_data['facebook_page_id'],
                    'api_key': business_data['api_key'],
                    'internal_api_key': business_data['internal_api_key']
                }
            }
            
            # Add contact info if requested
            if config['include_contact']:
                prepared_data['contact'] = {
                    'phone': business_data['phone_number'],
                    'website': business_data['website']
                }
            
            # Add address if requested
            if config['include_address']:
                prepared_data['address'] = business_data['address']
            
            log.info(f"Prepared business data: {prepared_data}")
            
            # Format output based on requested format
            if config['format'] == 'json':
                return prepared_data
            else:
                # Default to text format
                text_output = f"""=== Business Information ===
Name: {prepared_data['name']}
Description: {prepared_data['description']}
Additional Information: {prepared_data['additional_info']}"""
                
                if 'address' in prepared_data:
                    text_output += f"\nAddress: {prepared_data['address']}"
                    
                if 'contact' in prepared_data:
                    if prepared_data['contact']['phone']:
                        text_output += f"\nPhone: {prepared_data['contact']['phone']}"
                    if prepared_data['contact']['website']:
                        text_output += f"\nWebsite: {prepared_data['contact']['website']}"
                
                text_output += f"""
Created: {prepared_data['metadata']['created_at']}
Last Updated: {prepared_data['metadata']['updated_at']}
==========================="""
                
                log.info("Final text output:\n" + text_output)
                return text_output
                
    except Exception as e:
        log.error(f"Error in business_info provider: {str(e)}", exc_info=True)
        return f"Error retrieving business information: {str(e)}"
    finally:
        if 'conn' in locals():
            conn.close() 

================================================================================
File: conversation_history.py
Path: .\backend\message_processing\variables\conversation_history.py
Size: 2210
Modified: 2025-05-09T23:35:59.478834
Created: 2025-05-03T00:03:32.891529
Hash: 4392dba52469a4f94d2420ae10578f65f6eb0a6a0af340a3c3a4e9e00d3173f6
Lines: 55
================================================================================
from backend.message_processing.template_variables import TemplateVariableProvider
import logging

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider(
    'conversation_history',
    description='Provides the history of messages in a conversation',
    auth_requirement='business_key'
)
def provide_conversation_history(conn, conversation_id: str, **kwargs) -> str:
    """
    Generate a formatted conversation history.
    Args:
        conn: Database connection
        conversation_id: UUID of the conversation
        **kwargs: Additional arguments including:
            - max_messages: Maximum number of messages to retrieve (default: 10)
            - include_timestamps: Whether to include timestamps (default: False)
    Returns:
        Formatted string with conversation messages
    """
    try:
        if not conn:
            log.error("No database connection provided")
            return "Error: No database connection"
        max_messages = kwargs.get('max_messages', 10)
        include_timestamps = kwargs.get('include_timestamps', False)
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT message_content, sender_type, created_at 
            FROM messages 
            WHERE conversation_id = %s 
            ORDER BY created_at ASC
            LIMIT %s
            """,
            (conversation_id, max_messages)
        )
        messages = cursor.fetchall()
        if not messages:
            return "No conversation history"
        history = []
        for msg in messages:
            sender_type = str(msg['sender_type']).lower()
            if sender_type in ['assistant', 'bot', 'system']:
                sender = "Assistant"
            else:
                sender = "User"
            timestamp = f"[{msg['created_at'].isoformat()}] " if include_timestamps and msg['created_at'] else ""
            history.append(f"{timestamp}{sender}: {msg['message_content']}")
        return "\n".join(history)
    except Exception as e:
        log.error(f"Error providing conversation_history: {str(e)}")
        return "Error retrieving conversation history" 

================================================================================
File: database_utils.py
Path: .\backend\message_processing\variables\database_utils.py
Size: 3248
Modified: 2025-05-04T17:12:39.961700
Created: 2025-05-04T16:52:50.583872
Hash: 4cca51283028888fabc071c5d2988a8b12e9f3c80207298aba8f05e3706cd67c
Lines: 106
================================================================================
"""
Database utilities for variable providers.

Provides common database operations with proper error handling and connection management.
"""

import logging
import psycopg2
from typing import Dict, Any, List, Optional
from psycopg2.extras import RealDictCursor

log = logging.getLogger(__name__)

class DatabaseUtils:
    """Utility class for database operations."""
    
    @staticmethod
    def get_connection():
        """
        Get a database connection.
        
        Returns:
            Database connection object
            
        Raises:
            Exception if connection fails
        """
        try:
            conn = psycopg2.connect(
                dbname="icmp_db",
                user="icmp_user",
                password="your_password",  # Replace with actual password
                host="localhost",
                port="5432",
                cursor_factory=RealDictCursor
            )
            return conn
        except Exception as e:
            log.error(f"Failed to connect to database: {str(e)}")
            raise
    
    @staticmethod
    def execute_query(conn, query: str, params: tuple = None) -> List[Dict[str, Any]]:
        """
        Execute a query and return results as dictionaries.
        
        Args:
            conn: Database connection
            query: SQL query to execute
            params: Query parameters
            
        Returns:
            List of result rows as dictionaries
        """
        try:
            with conn.cursor() as cursor:
                cursor.execute(query, params)
                return cursor.fetchall()
        except Exception as e:
            log.error(f"Query execution failed: {str(e)}")
            return []
    
    @staticmethod
    def execute_scalar(conn, query: str, params: tuple = None) -> Optional[Any]:
        """
        Execute a query that returns a single value.
        
        Args:
            conn: Database connection
            query: SQL query to execute
            params: Query parameters
            
        Returns:
            Single value result or None
        """
        try:
            with conn.cursor() as cursor:
                cursor.execute(query, params)
                result = cursor.fetchone()
                return result[0] if result else None
        except Exception as e:
            log.error(f"Scalar query execution failed: {str(e)}")
            return None
    
    @staticmethod
    def execute_update(conn, query: str, params: tuple = None) -> int:
        """
        Execute an update query and return number of affected rows.
        
        Args:
            conn: Database connection
            query: SQL query to execute
            params: Query parameters
            
        Returns:
            Number of affected rows
        """
        try:
            with conn.cursor() as cursor:
                cursor.execute(query, params)
                conn.commit()
                return cursor.rowcount
        except Exception as e:
            log.error(f"Update query execution failed: {str(e)}")
            conn.rollback()
            return 0 

================================================================================
File: last_10_messages.py
Path: .\backend\message_processing\variables\last_10_messages.py
Size: 2510
Modified: 2025-05-09T23:40:58.203930
Created: 2025-04-14T17:33:41.906931
Hash: f6eb48ea034a8f6e9b2b61f7de944028f077892a5be548b371a2521ea2a0177c
Lines: 67
================================================================================
"""
Last 10 messages variable provider.
"""
import logging
import json
import re
from ..template_variables import TemplateVariableProvider

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider(
    'last_10_messages',
    description='Provides the last 10 messages in a conversation',
    auth_requirement='business_key'
)
def provide_last_10_messages(conn, conversation_id: str, **kwargs) -> str:
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT message_content, sender_type, created_at 
            FROM messages 
            WHERE conversation_id = %s 
            ORDER BY created_at DESC
            LIMIT 10
            """,
            (conversation_id,)
        )
        
        messages = cursor.fetchall()
        if not messages:
            return "[]"
            
        # Format messages
        message_list = []
        for msg in messages:
            content = msg['message_content']
            
            # Clean up assistant messages that contain recursive context
            if msg['sender_type'] == 'assistant':
                # The message content follows the format:
                # "user message:<user-message>\n,\nconversation sumary:[Missing: conversation_summary]\n,\nlast mesages [...]"
                # Extract just the user message part
                content_match = re.search(r'^user message:(.*?)(?:\n,\nconversation sumary:|$)', content, re.DOTALL)
                if content_match:
                    content = content_match.group(1).strip()
                else:
                    # Fallback pattern - try to clean up any assistant message
                    # that might have a different format
                    content = re.sub(r'user message:|\n,\nconversation sumary:.*|\n,\nlast mesages \[.*', '', content, flags=re.DOTALL)
                    content = content.strip()
            
            message_list.append({
                'content': content,
                'sender': 'user' if msg['sender_type'] == 'user' else 'assistant',
                'timestamp': msg['created_at'].isoformat()
            })
        
        # Reverse to get chronological order
        message_list.reverse()
        
        # Return as JSON string
        return json.dumps(message_list, indent=2)
        
    except Exception as e:
        log.error(f"Error providing last_10_messages: {str(e)}")
        return "[]"

================================================================================
File: test_agent_stages.py
Path: .\backend\message_processing\variables\test_agent_stages.py
Size: 6711
Modified: 2025-05-04T14:17:10.169652
Created: 2025-05-04T11:04:44.988229
Hash: 91e91d1c49ec5dda47bf43adfb7deb42c85e4686eee0695a8adebeada7b0207a
Lines: 152
================================================================================
"""
Tests for the agent stages variable provider.
"""

import unittest
from unittest.mock import patch, MagicMock
import uuid
from datetime import datetime
from backend.message_processing.variables.agent_stages import AgentStagesVariable

class TestAgentStagesVariable(unittest.TestCase):
    """Test cases for AgentStagesVariable."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.test_agent_id = str(uuid.uuid4())  # Generate a valid UUID
        self.mock_stages = [
            {
                "stage_id": str(uuid.uuid4()),
                "stage_name": "Test Stage 1",
                "stage_description": "First test stage",
                "stage_type": "conversation",
                "created_at": datetime(2023, 1, 1)
            },
            {
                "stage_id": str(uuid.uuid4()),
                "stage_name": "Test Stage 2",
                "stage_description": "Second test stage",
                "stage_type": "data_extraction",
                "created_at": datetime(2023, 1, 2)
            }
        ]
    
    def test_get_variable_name(self):
        """Test getting the variable name."""
        self.assertEqual(AgentStagesVariable.get_variable_name(), "agent_stages")
    
    def test_get_variable_description(self):
        """Test getting the variable description."""
        self.assertEqual(
            AgentStagesVariable.get_variable_description(),
            "Returns a list of stages associated with a specific agent"
        )
    
    def test_get_variable_parameters(self):
        """Test getting the variable parameters."""
        params = AgentStagesVariable.get_variable_parameters()
        self.assertIn("agent_id", params)
        self.assertTrue("Optional" in params["agent_id"])
    
    @patch('backend.message_processing.variables.agent_stages.get_db_connection')
    @patch('backend.message_processing.variables.agent_stages.release_db_connection')
    def test_provide_variable_with_agent_id_param(self, mock_release_conn, mock_get_conn):
        """Test providing stages with agent_id in parameters."""
        # Mock the database connection and cursor
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_get_conn.return_value = mock_conn
        mock_conn.cursor.return_value = mock_cursor
        
        # Create mock rows with proper datetime objects
        mock_rows = [
            (str(uuid.uuid4()), "Test Stage 1", "First test stage", "conversation", datetime(2023, 1, 1)),
            (str(uuid.uuid4()), "Test Stage 2", "Second test stage", "data_extraction", datetime(2023, 1, 2))
        ]
        mock_cursor.fetchall.return_value = mock_rows
        
        # Test the variable provider with agent_id in params
        result = AgentStagesVariable.provide_variable(
            {"agent_id": self.test_agent_id},
            context={"agent_id": str(uuid.uuid4())}  # Different UUID for context
        )
        
        # Verify the results
        self.assertIsNotNone(result)
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]["stage_name"], "Test Stage 1")
        self.assertEqual(result[1]["stage_name"], "Test Stage 2")
        
        # Verify the database query used the parameter agent_id
        mock_cursor.execute.assert_called_once()
        query, params = mock_cursor.execute.call_args[0]
        self.assertIn("WHERE s.agent_id = %s", query)
        self.assertEqual(params[0], self.test_agent_id)
        
        # Verify connection was released
        mock_release_conn.assert_called_once_with(mock_conn)
    
    @patch('backend.message_processing.variables.agent_stages.get_db_connection')
    @patch('backend.message_processing.variables.agent_stages.release_db_connection')
    def test_provide_variable_with_context_agent_id(self, mock_release_conn, mock_get_conn):
        """Test providing stages with agent_id from context."""
        # Mock the database connection and cursor
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_get_conn.return_value = mock_conn
        mock_conn.cursor.return_value = mock_cursor
        
        # Create mock row with proper datetime object
        mock_row = (str(uuid.uuid4()), "Test Stage 1", "First test stage", "conversation", datetime(2023, 1, 1))
        mock_cursor.fetchall.return_value = [mock_row]
        
        # Test the variable provider with agent_id from context
        result = AgentStagesVariable.provide_variable(
            {},  # No agent_id in params
            context={"agent_id": self.test_agent_id}
        )
        
        # Verify the results
        self.assertIsNotNone(result)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]["stage_name"], "Test Stage 1")
        
        # Verify the database query used the context agent_id
        mock_cursor.execute.assert_called_once()
        query, params = mock_cursor.execute.call_args[0]
        self.assertIn("WHERE s.agent_id = %s", query)
        self.assertEqual(params[0], self.test_agent_id)
        
        # Verify connection was released
        mock_release_conn.assert_called_once_with(mock_conn)
    
    def test_provide_variable_missing_agent_id(self):
        """Test providing stages without agent_id in parameters or context."""
        result = AgentStagesVariable.provide_variable({}, context={})
        self.assertIsNone(result)
    
    @patch('backend.message_processing.variables.agent_stages.get_db_connection')
    @patch('backend.message_processing.variables.agent_stages.release_db_connection')
    def test_provide_variable_database_error(self, mock_release_conn, mock_get_conn):
        """Test handling database errors."""
        mock_get_conn.side_effect = Exception("Database error")
        
        result = AgentStagesVariable.provide_variable(
            {"agent_id": self.test_agent_id},
            context={"agent_id": str(uuid.uuid4())}
        )
        self.assertIsNone(result)
        
        # Verify connection was not released since it was never created
        mock_release_conn.assert_not_called()

    def test_provide_variable_real_db(self):
        """Integration test: fetch real stages for a real agent_id."""
        agent_id = "792c6318-79e2-49d9-8f7b-9b32aa78a272"
        result = AgentStagesVariable.provide_variable({"agent_id": agent_id}, context={})
        print("Result from real DB:", result)
        self.assertIsNotNone(result)
        self.assertTrue(len(result) > 0)

if __name__ == '__main__':
    unittest.main() 

================================================================================
File: test_agent_stages_simple.py
Path: .\backend\message_processing\variables\test_agent_stages_simple.py
Size: 1610
Modified: 2025-05-04T17:28:55.384888
Created: 2025-05-04T17:28:53.028089
Hash: 4810d2a76397972e9b80b75973c48ae35a622a4dacad8445311438b1e94bc20e
Lines: 51
================================================================================
#!/usr/bin/env python
import os
import sys
import argparse
import logging

# Add the project root directory to Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../'))
sys.path.insert(0, project_root)

# Import after adding to path
from backend.message_processing.variables.agent_stages import AgentStagesVariable

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

def test_agent_stages(agent_id):
    try:
        log.info(f"Testing with agent_id: {agent_id}")
        
        # Test with agent_id in parameters
        result = AgentStagesVariable.provide_variable(
            {"agent_id": agent_id},
            context={}
        )
        
        if result is None:
            log.error("Failed to get agent stages")
            return
            
        print("\nAgent Stages:")
        print("------------")
        for stage in result:
            print(f"Stage: {stage['stage_name']}")
            print(f"Description: {stage['stage_description']}")
            print(f"Type: {stage['stage_type']}")
            print("------------")
            
    except Exception as e:
        log.error(f"Error testing agent_stages: {str(e)}", exc_info=True)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test the agent_stages variable provider.")
    parser.add_argument('--agent_id', type=str, help='Agent ID')
    args = parser.parse_args()

    agent_id = args.agent_id or input('Enter Agent ID: ')

    test_agent_stages(
        agent_id=agent_id
    ) 

================================================================================
File: test_available_stages.py
Path: .\backend\message_processing\variables\test_available_stages.py
Size: 2791
Modified: 2025-05-04T17:17:15.271450
Created: 2025-05-04T17:11:03.413647
Hash: 02190fb4f5fd920769203eb098abaf28c0645bf43d69be1c09cf6a00fe562bb8
Lines: 87
================================================================================
#!/usr/bin/env python
import os
import sys
import argparse
import logging

# Add the project root directory to Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../'))
sys.path.insert(0, project_root)

# Import after adding to path
from backend.db import get_db_connection, release_db_connection
from backend.message_processing.variables.available_stages import provide_available_stages

# Set up logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log = logging.getLogger(__name__)

def check_database_state(conn, business_id):
    """Check the state of relevant tables in the database"""
    cursor = conn.cursor()
    
    # Check businesses table
    cursor.execute("SELECT * FROM businesses WHERE business_id = %s", (business_id,))
    business = cursor.fetchone()
    log.info(f"Business found: {business is not None}")
    
    # Check stages table
    cursor.execute("""
        SELECT COUNT(*) as count 
        FROM stages 
        WHERE business_id = %s
    """, (business_id,))
    stages_count = cursor.fetchone()['count']
    log.info(f"Stages found: {stages_count}")
    
    # Show some sample stages if they exist
    if stages_count > 0:
        cursor.execute("""
            SELECT stage_name, stage_description 
            FROM stages 
            WHERE business_id = %s
            LIMIT 5
        """, (business_id,))
        sample_stages = cursor.fetchall()
        log.info("Sample stages:")
        for stage in sample_stages:
            log.info(f"Stage: {stage}")

def test_available_stages(business_id):
    conn = None
    try:
        log.info(f"Testing with business_id: {business_id}")
        conn = get_db_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
        
        # Check database state first
        check_database_state(conn, business_id)
        
        value = provide_available_stages(
            conn=conn,
            business_id=business_id
        )
        print(f"\nAvailable Stages:")
        print("------------")
        print(value)
    except Exception as e:
        log.error(f"Error testing available_stages: {str(e)}", exc_info=True)
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test the available_stages variable provider.")
    parser.add_argument('--business_id', type=str, help='Business ID')
    args = parser.parse_args()

    business_id = args.business_id or input('Enter Business ID: ')

    test_available_stages(
        business_id=business_id
    ) 

================================================================================
File: test_available_stages_direct.py
Path: .\backend\message_processing\variables\test_available_stages_direct.py
Size: 3331
Modified: 2025-05-04T17:18:23.382624
Created: 2025-05-04T17:18:20.809875
Hash: 21ee8ba214b5029eacbe437767f93edd5bc66db1cfb27c0e87e03d78d84965ae
Lines: 106
================================================================================
#!/usr/bin/env python
import os
import sys
import argparse
import logging
import psycopg2
from psycopg2.extras import RealDictCursor

# Add the project root directory to Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../'))
sys.path.insert(0, project_root)

# Import after adding to path
from backend.message_processing.variables.available_stages import provide_available_stages
from backend.db_config import get_db_config

# Set up logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log = logging.getLogger(__name__)

def get_connection():
    """Get a direct database connection."""
    try:
        config = get_db_config()
        conn = psycopg2.connect(
            dbname=config['dbname'],
            user=config['user'],
            password=config['password'],
            host=config['host'],
            port=config['port'],
            cursor_factory=RealDictCursor
        )
        return conn
    except Exception as e:
        log.error(f"Failed to connect to database: {str(e)}")
        return None

def check_database_state(conn, business_id):
    """Check the state of relevant tables in the database"""
    cursor = conn.cursor()
    
    # Check businesses table
    cursor.execute("SELECT * FROM businesses WHERE business_id = %s", (business_id,))
    business = cursor.fetchone()
    log.info(f"Business found: {business is not None}")
    
    # Check stages table
    cursor.execute("""
        SELECT COUNT(*) as count 
        FROM stages 
        WHERE business_id = %s
    """, (business_id,))
    stages_count = cursor.fetchone()['count']
    log.info(f"Stages found: {stages_count}")
    
    # Show some sample stages if they exist
    if stages_count > 0:
        cursor.execute("""
            SELECT stage_name, stage_description 
            FROM stages 
            WHERE business_id = %s
            LIMIT 5
        """, (business_id,))
        sample_stages = cursor.fetchall()
        log.info("Sample stages:")
        for stage in sample_stages:
            log.info(f"Stage: {stage}")

def test_available_stages(business_id):
    conn = None
    try:
        log.info(f"Testing with business_id: {business_id}")
        conn = get_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
        
        # Check database state first
        check_database_state(conn, business_id)
        
        value = provide_available_stages(
            conn=conn,
            business_id=business_id
        )
        print(f"\nAvailable Stages:")
        print("------------")
        print(value)
    except Exception as e:
        log.error(f"Error testing available_stages: {str(e)}", exc_info=True)
    finally:
        if conn:
            conn.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test the available_stages variable provider.")
    parser.add_argument('--business_id', type=str, help='Business ID')
    args = parser.parse_args()

    business_id = args.business_id or input('Enter Business ID: ')

    test_available_stages(
        business_id=business_id
    ) 

================================================================================
File: test_available_stages_simple.py
Path: .\backend\message_processing\variables\test_available_stages_simple.py
Size: 1556
Modified: 2025-05-04T17:23:50.822912
Created: 2025-05-04T17:19:22.246634
Hash: 3f64102fe0ceb22183485c228693006fa54dbbfadda0ed0829aadc53bfd2dac6
Lines: 49
================================================================================
#!/usr/bin/env python
import os
import sys
import argparse
import logging

# Add the project root directory to Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../'))
sys.path.insert(0, project_root)

# Import after adding to path
from backend.db import get_db_connection, release_db_connection
from backend.message_processing.variables.available_stages import provide_available_stages

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

def test_available_stages(business_id):
    conn = None
    try:
        log.info(f"Testing with business_id: {business_id}")
        conn = get_db_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
        
        value = provide_available_stages(
            conn=conn,
            business_id=business_id
        )
        print(f"\nAvailable Stages:")
        print("------------")
        print(value)
    except Exception as e:
        log.error(f"Error testing available_stages: {str(e)}", exc_info=True)
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test the available_stages variable provider.")
    parser.add_argument('--business_id', type=str, help='Business ID')
    args = parser.parse_args()

    business_id = args.business_id or input('Enter Business ID: ')

    test_available_stages(
        business_id=business_id
    ) 

================================================================================
File: test_business_info.py
Path: .\backend\message_processing\variables\test_business_info.py
Size: 7766
Modified: 2025-05-03T14:52:47.769760
Created: 2025-05-03T14:38:33.735924
Hash: a68ad07b87c33ab5adbd5a4014a09186e06386c35cf932fa83b4f898a3cabbb1
Lines: 184
================================================================================
#!/usr/bin/env python
import sys
import os
import logging
import unittest
import argparse
from unittest.mock import MagicMock, patch

# Add the project root directory to Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../'))
sys.path.insert(0, project_root)

from backend.message_processing.template_variables import TemplateVariableProvider
from backend.message_processing.variables.business_info import provide_business_info
from backend.db import get_db_connection, release_db_connection

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

class TestBusinessInfo(unittest.TestCase):
    def setUp(self):
        """Set up test fixtures."""
        self.conn = MagicMock()
        self.business_id = "test-business-id"
        self.mock_business = {
            'business_id': 'test-business-id',
            'business_name': 'Test Business',
            'business_description': 'A test business',
            'address': '123 Test St',
            'phone_number': '555-1234',
            'website': 'https://test.example.com',
            'owner_id': 'test-owner-id',
            'first_stage_id': 'test-stage-id',
            'facebook_page_id': 'test-facebook-id',
            'created_at': '2023-01-01T00:00:00',
            'updated_at': '2023-01-02T00:00:00'
        }

    def test_business_info_full(self):
        """Test business_info with all fields."""
        cursor = MagicMock()
        cursor.fetchone.return_value = self.mock_business
        self.conn.cursor.return_value = cursor

        result = provide_business_info(self.conn, self.business_id, format='json')
        
        # Verify database query
        cursor.execute.assert_called_once()
        self.assertIn("SELECT", cursor.execute.call_args[0][0])
        self.assertIn("business_name", cursor.execute.call_args[0][0])
        self.assertIn("business_description", cursor.execute.call_args[0][0])
        self.assertIn("address", cursor.execute.call_args[0][0])
        self.assertIn("phone_number", cursor.execute.call_args[0][0])
        self.assertIn("website", cursor.execute.call_args[0][0])
        
        # Verify result structure
        self.assertIsInstance(result, dict)
        self.assertEqual(result['id'], self.mock_business['business_id'])
        self.assertEqual(result['name'], self.mock_business['business_name'])
        self.assertEqual(result['description'], self.mock_business['business_description'])
        self.assertEqual(result['address'], self.mock_business['address'])
        self.assertEqual(result['contact']['phone'], self.mock_business['phone_number'])
        self.assertEqual(result['contact']['website'], self.mock_business['website'])
        self.assertEqual(result['metadata']['owner_id'], self.mock_business['owner_id'])
        self.assertEqual(result['metadata']['first_stage_id'], self.mock_business['first_stage_id'])
        self.assertEqual(result['metadata']['facebook_page_id'], self.mock_business['facebook_page_id'])

    def test_business_info_no_address(self):
        """Test business_info with address excluded."""
        cursor = MagicMock()
        cursor.fetchone.return_value = self.mock_business
        self.conn.cursor.return_value = cursor

        result = provide_business_info(self.conn, self.business_id, include_address=False, format='json')
        
        # Verify address is not included
        self.assertNotIn('address', result)

    def test_business_info_no_contact(self):
        """Test business_info with contact info excluded."""
        cursor = MagicMock()
        cursor.fetchone.return_value = self.mock_business
        self.conn.cursor.return_value = cursor

        result = provide_business_info(self.conn, self.business_id, include_contact=False, format='json')
        
        # Verify contact info is not included
        self.assertNotIn('contact', result)

    def test_business_info_not_found(self):
        """Test business_info when business is not found."""
        cursor = MagicMock()
        cursor.fetchone.return_value = None
        self.conn.cursor.return_value = cursor

        result = provide_business_info(self.conn, self.business_id, format='json')
        
        self.assertIn('error', result)
        self.assertEqual(result['error'], "Business not found")

    def test_business_info_no_connection(self):
        """Test business_info with no database connection."""
        result = provide_business_info(None, self.business_id, format='json')
        
        self.assertIn('error', result)
        self.assertEqual(result['error'], "No database connection")

    def test_business_info_partial_data(self):
        """Test business_info with partial data."""
        cursor = MagicMock()
        partial_business = {
            'business_id': 'test-business-id',
            'business_name': 'Test Business',
            'business_description': None,
            'address': None,
            'phone_number': None,
            'website': None,
            'owner_id': None,
            'first_stage_id': None,
            'facebook_page_id': None,
            'created_at': None,
            'updated_at': None
        }
        cursor.fetchone.return_value = partial_business
        self.conn.cursor.return_value = cursor

        result = provide_business_info(self.conn, self.business_id, format='json')
        
        # Verify only name is included
        self.assertEqual(result['name'], 'Test Business')
        self.assertIsNone(result['description'])
        self.assertIsNone(result.get('address'))
        self.assertIsNone(result.get('contact', {}).get('phone'))
        self.assertIsNone(result.get('contact', {}).get('website'))

def test_business_info_command():
    """Command-line function to test business_info variable."""
    parser = argparse.ArgumentParser(description="Test business_info template variable")
    parser.add_argument('--test-db', action='store_true', help='Run database test')
    parser.add_argument('--business_id', type=str, required=True, help='Business ID to test')
    parser.add_argument('--include_address', action='store_true', help='Include address in output')
    parser.add_argument('--include_contact', action='store_true', help='Include contact info in output')
    parser.add_argument('--format', type=str, default='text', choices=['text', 'json'], help='Output format')
    args = parser.parse_args()
    
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
            
        kwargs = {
            'format': args.format
        }
        if args.include_address:
            kwargs['include_address'] = True
        if args.include_contact:
            kwargs['include_contact'] = True
            
        result = provide_business_info(conn, args.business_id, **kwargs)
        
        if args.format == 'json':
            import json
            print("\nBusiness Information (JSON):")
            print(json.dumps(result, indent=2))
        else:
            print("\nBusiness Information:")
            print(result)
        
    except Exception as e:
        log.error(f"Error testing business_info: {str(e)}")
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    if '--test-db' in sys.argv:
        # Remove --test-db from sys.argv before parsing
        sys.argv.remove('--test-db')
        test_business_info_command()
    else:
        # Run unit tests
        unittest.main() 

================================================================================
File: test_conversation_history.py
Path: .\backend\message_processing\variables\test_conversation_history.py
Size: 2059
Modified: 2025-05-03T00:15:44.720232
Created: 2025-05-03T00:06:19.909447
Hash: 7eb79fa71c891ee7bb0f2a9a5392f37d0b5488ade9f3792c01ed3d29115019e5
Lines: 49
================================================================================
#!/usr/bin/env python
import argparse
import logging
from backend.db import get_db_connection, release_db_connection
from backend.message_processing.variables.conversation_history import provide_conversation_history

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

def test_conversation_history(business_id, user_id, conversation_id, max_messages=10, include_timestamps=False):
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
        value = provide_conversation_history(
            conn=conn,
            conversation_id=conversation_id,
            max_messages=max_messages,
            include_timestamps=include_timestamps
        )
        print(f"Conversation history:\n{value}")
    except Exception as e:
        log.error(f"Error testing conversation_history: {str(e)}", exc_info=True)
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test the conversation_history variable provider.")
    parser.add_argument('--business_id', type=str, help='Business ID')
    parser.add_argument('--user_id', type=str, help='User ID')
    parser.add_argument('--conversation_id', type=str, help='Conversation ID')
    parser.add_argument('--max_messages', type=int, default=10, help='Max messages (optional)')
    parser.add_argument('--include_timestamps', action='store_true', help='Include timestamps (optional)')
    args = parser.parse_args()

    business_id = args.business_id or input('Enter Business ID: ')
    user_id = args.user_id or input('Enter User ID: ')
    conversation_id = args.conversation_id or input('Enter Conversation ID: ')

    test_conversation_history(
        business_id=business_id,
        user_id=user_id,
        conversation_id=conversation_id,
        max_messages=args.max_messages,
        include_timestamps=args.include_timestamps
    ) 

================================================================================
File: test_user_messages.py
Path: .\backend\message_processing\variables\test_user_messages.py
Size: 4291
Modified: 2025-05-03T12:21:49.573654
Created: 2025-05-03T12:16:01.317895
Hash: 79502d0e23b649fdb9cae50f208d5edb4236290be663d327c844e0bcfd59b532
Lines: 116
================================================================================
#!/usr/bin/env python
import os
import sys
import argparse
import logging

# Add the project root directory to Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../'))
sys.path.insert(0, project_root)

from backend.db import get_db_connection, release_db_connection
from backend.message_processing.variables.user_messages import provide_user_messages

# Set up logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log = logging.getLogger(__name__)

def check_database_state(conn, business_id, user_id):
    """Check the state of relevant tables in the database"""
    cursor = conn.cursor()
    
    # Check users table
    cursor.execute("SELECT * FROM users WHERE user_id = %s", (user_id,))
    user = cursor.fetchone()
    log.info(f"User found: {user is not None}")
    
    # Check businesses table
    cursor.execute("SELECT * FROM businesses WHERE business_id = %s", (business_id,))
    business = cursor.fetchone()
    log.info(f"Business found: {business is not None}")
    
    # Check conversations table
    cursor.execute("""
        SELECT COUNT(*) as count 
        FROM conversations 
        WHERE user_id = %s AND business_id = %s
    """, (user_id, business_id))
    conv_count = cursor.fetchone()['count']
    log.info(f"Conversations found: {conv_count}")
    
    # Check messages table
    cursor.execute("""
        SELECT COUNT(*) as count 
        FROM messages 
        WHERE user_id = %s
    """, (user_id,))
    msg_count = cursor.fetchone()['count']
    log.info(f"Total messages found: {msg_count}")
    
    # Show some sample messages if they exist
    if msg_count > 0:
        cursor.execute("""
            SELECT m.*, c.conversation_id 
            FROM messages m
            LEFT JOIN conversations c ON m.user_id = c.user_id
            WHERE m.user_id = %s
            LIMIT 5
        """, (user_id,))
        sample_messages = cursor.fetchall()
        log.info("Sample messages:")
        for msg in sample_messages:
            log.info(f"Message: {msg}")

def test_user_messages(business_id, user_id, max_messages=50, include_timestamps=False, include_conversation_id=False):
    conn = None
    try:
        log.info(f"Testing with business_id: {business_id}, user_id: {user_id}")
        conn = get_db_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
        
        # Check database state first
        check_database_state(conn, business_id, user_id)
        
        value = provide_user_messages(
            conn=conn,
            user_id=user_id,
            business_id=business_id,
            max_messages=max_messages,
            include_timestamps=include_timestamps,
            include_conversation_id=include_conversation_id
        )
        print(f"\nUser Messages:")
        print("------------")
        print(value)
    except Exception as e:
        log.error(f"Error testing user_messages: {str(e)}", exc_info=True)
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test the user_messages variable provider.")
    parser.add_argument('--business_id', type=str, help='Business ID')
    parser.add_argument('--user_id', type=str, help='User ID')
    parser.add_argument('--max_messages', type=int, default=50, help='Max messages to retrieve (optional)')
    parser.add_argument('--include_timestamps', action='store_true', help='Include timestamps (optional)')
    parser.add_argument('--include_conversation_id', action='store_true', help='Include conversation IDs (optional)')
    
    args = parser.parse_args()

    # Get required parameters from command line or prompt
    business_id = args.business_id or input('Enter Business ID: ')
    user_id = args.user_id or input('Enter User ID: ')

    test_user_messages(
        business_id=business_id,
        user_id=user_id,
        max_messages=args.max_messages,
        include_timestamps=args.include_timestamps,
        include_conversation_id=args.include_conversation_id
    ) 

================================================================================
File: test_variables.py
Path: .\backend\message_processing\variables\test_variables.py
Size: 3050
Modified: 2025-05-03T00:05:51.248067
Created: 2025-05-03T00:05:48.933878
Hash: 612c2c0dfc225b874e577bc97ad71f3320f8437a0b6543fb7c0bc7cc7b769d43
Lines: 64
================================================================================
#!/usr/bin/env python
import sys
import os
import logging
import argparse
from backend.db import get_db_connection, release_db_connection
from backend.message_processing.template_variables import TemplateVariableProvider

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

def test_variable(variable_name, business_id, user_id, conversation_id, message_content=None, max_messages=10, include_timestamps=False):
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            log.error("Failed to get database connection")
            return
        provider = TemplateVariableProvider.get_provider(variable_name)
        if not provider:
            log.error(f"No provider found for variable: {variable_name}")
            return
        # Build kwargs for provider
        kwargs = {}
        if 'max_messages' in provider.__code__.co_varnames:
            kwargs['max_messages'] = max_messages
        if 'include_timestamps' in provider.__code__.co_varnames:
            kwargs['include_timestamps'] = include_timestamps
        if 'message_content' in provider.__code__.co_varnames and message_content is not None:
            kwargs['message_content'] = message_content
        # Call provider
        value = provider(
            conn=conn,
            business_id=business_id if 'business_id' in provider.__code__.co_varnames else None,
            user_id=user_id if 'user_id' in provider.__code__.co_varnames else None,
            conversation_id=conversation_id if 'conversation_id' in provider.__code__.co_varnames else None,
            **kwargs
        )
        print(f"Value for variable '{variable_name}':\n{value}")
    except Exception as e:
        log.error(f"Error testing variable: {str(e)}", exc_info=True)
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test a template variable provider.")
    parser.add_argument('--variable', type=str, required=True, help='Variable name to test (e.g. conversation_history)')
    parser.add_argument('--business_id', type=str, required=True, help='Business ID')
    parser.add_argument('--user_id', type=str, required=True, help='User ID')
    parser.add_argument('--conversation_id', type=str, required=True, help='Conversation ID')
    parser.add_argument('--message_content', type=str, help='Message content (optional)')
    parser.add_argument('--max_messages', type=int, default=10, help='Max messages (optional)')
    parser.add_argument('--include_timestamps', action='store_true', help='Include timestamps (optional)')
    args = parser.parse_args()
    test_variable(
        variable_name=args.variable,
        business_id=args.business_id,
        user_id=args.user_id,
        conversation_id=args.conversation_id,
        message_content=args.message_content,
        max_messages=args.max_messages,
        include_timestamps=args.include_timestamps
    ) 

================================================================================
File: user_messages.py
Path: .\backend\message_processing\variables\user_messages.py
Size: 3726
Modified: 2025-05-09T23:40:49.343456
Created: 2025-05-03T11:58:37.260820
Hash: bf5bfbe969b0e3baa55ea002a1b14ce97549c2b15274e50fae721b56142beb76
Lines: 94
================================================================================
from backend.message_processing.template_variables import TemplateVariableProvider
import logging

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider(
    'user_messages',
    description='Generates a formatted history of all messages sent by a specific user',
    auth_requirement='business_key'
)
def provide_user_messages(conn, user_id: str, business_id: str, **kwargs) -> str:
    """
    Generate a formatted history of all messages sent by a specific user.
    Args:
        conn: Database connection
        user_id: ID of the user
        business_id: ID of the business
        **kwargs: Additional arguments including:
            - max_messages: Maximum number of messages to retrieve (default: 50)
            - include_timestamps: Whether to include timestamps (default: False)
            - include_conversation_id: Whether to include conversation ID (default: False)
    Returns:
        Formatted string with user messages
    """
    try:
        if not conn:
            log.error("No database connection provided")
            return "Error: No database connection"
            
        max_messages = kwargs.get('max_messages', 50)
        include_timestamps = kwargs.get('include_timestamps', False)
        include_conversation_id = kwargs.get('include_conversation_id', False)
        
        cursor = conn.cursor()
        # First, let's check if the user and business exist
        cursor.execute(
            """
            SELECT COUNT(*) FROM users WHERE user_id = %s;
            """,
            (user_id,)
        )
        user_exists = cursor.fetchone()['count'] > 0
        
        cursor.execute(
            """
            SELECT COUNT(*) FROM businesses WHERE business_id = %s;
            """,
            (business_id,)
        )
        business_exists = cursor.fetchone()['count'] > 0
        
        if not user_exists or not business_exists:
            return f"Error: {'User' if not user_exists else 'Business'} not found"
        
        # Now get the messages (fix join to prevent repetition)
        cursor.execute(
            """
            SELECT 
                m.message_content,
                m.created_at,
                c.conversation_id,
                m.message_id,
                m.sender_type
            FROM messages m
            JOIN conversations c ON m.conversation_id = c.conversation_id
            WHERE m.user_id = %s 
            AND c.business_id = %s
            AND m.message_content IS NOT NULL
            ORDER BY m.created_at DESC
            LIMIT %s
            """,
            (user_id, business_id, max_messages)
        )
        messages = cursor.fetchall()
        
        if not messages:
            return "No messages found for this user"
            
        log.debug(f"Found {len(messages)} messages for user {user_id}")
        for msg in messages:
            log.debug(f"Message: {msg}")
            
        history = []
        for msg in messages:
            timestamp = f"[{msg['created_at'].isoformat()}] " if include_timestamps and msg['created_at'] else ""
            conversation_id = f"(Conversation: {msg['conversation_id']}) " if include_conversation_id else ""
            sender = f"{msg['sender_type']}: " if msg['sender_type'] else "User: "
            content = msg['message_content'] or "No content"
            history.append(f"{timestamp}{conversation_id}{sender}{content}")
            
        return "\n".join(history)
    except Exception as e:
        log.error(f"Error providing user_messages: {str(e)}", exc_info=True)
        return "Error retrieving user messages" 

================================================================================
File: user_name.py
Path: .\backend\message_processing\variables\user_name.py
Size: 1560
Modified: 2025-05-09T23:40:42.881725
Created: 2025-04-14T17:33:29.309008
Hash: 6f2d8cfc3b41af84940b0fe0261f0d945c88558dc8d069d1c1c5857bfbe2754c
Lines: 56
================================================================================
"""
User name variable provider.

Provides the full name of a user based on their user_id.
"""

import logging
from ..template_variables import TemplateVariableProvider
from .database_utils import DatabaseUtils

log = logging.getLogger(__name__)

@TemplateVariableProvider.register_provider(
    'user_name',
    description='Provides the full name of a user based on their user_id',
    auth_requirement='business_key'
)
def provide_user_name(conn, user_id: str, **kwargs) -> str:
    """
    Get the full name of a user.
    
    Args:
        conn: Database connection
        user_id: UUID of the user
        **kwargs: Additional context parameters (ignored)
        
    Returns:
        User's full name or 'Guest' if not found
    """
    try:
        # Execute query
        results = DatabaseUtils.execute_query(
            conn,
            """
            SELECT first_name, last_name
            FROM users 
            WHERE user_id = %s
            """,
            (user_id,)
        )
        
        # Process results
        if not results:
            return "Guest"
            
        user = results[0]
        first_name = user.get('first_name', '').strip()
        last_name = user.get('last_name', '').strip()
        
        if not first_name and not last_name:
            return "Guest"
            
        return f"{first_name} {last_name}".strip()
    except Exception as e:
        log.error(f"Error providing user_name: {str(e)}", exc_info=True)
        return "Guest"

================================================================================
File: __init__.py
Path: .\backend\message_processing\variables\__init__.py
Size: 2762
Modified: 2025-05-09T23:40:35.989838
Created: 2025-04-14T17:33:50.421858
Hash: 50a648a68f8d5dba8ed6d11e1b42644cb38163ed9f97892a6a90f1df09d91c89
Lines: 66
================================================================================
"""
Variable providers package initialization.

This module automatically imports and registers all variable providers
in the current directory.
"""

import os
import logging
import importlib
from typing import List

log = logging.getLogger(__name__)

def register_all_variables() -> List[str]:
    """
    Register all variable providers in the directory.
    
    Returns:
        List of registered variable names
    """
    registered_vars = []
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Import and register all Python files in the directory
    for filename in os.listdir(current_dir):
        # Skip test files and files starting with underscore
        if (filename.endswith('.py') and 
            not filename.startswith('_') and 
            not filename.startswith('test_')):
            module_name = filename[:-3]  # Remove .py extension
            
            # Skip base classes
            if module_name in ['base_provider', 'database_utils']:
                continue
                
            try:
                # Import the module
                module = importlib.import_module(f'.{module_name}', package='backend.message_processing.variables')
                
                # Log successful import
                log.info(f"Successfully imported variable module: {module_name}")
                
                # First, check for standalone functions
                for name, obj in module.__dict__.items():
                    if callable(obj) and hasattr(obj, '__wrapped__') and hasattr(obj, '__name__'):
                        registered_vars.append(obj.__name__)
                        log.info(f"Registered standalone function: {obj.__name__}")
                
                # Then check for class methods
                for name, obj in module.__dict__.items():
                    if isinstance(obj, type) and hasattr(obj, '__module__') and obj.__module__ == module.__name__:
                        # Get all class methods that are registered as providers
                        for attr_name, attr_value in obj.__dict__.items():
                            if hasattr(attr_value, '__wrapped__') and hasattr(attr_value, '__name__'):
                                registered_vars.append(attr_value.__name__)
                                log.info(f"Registered class method: {attr_value.__name__}")
                                
            except Exception as e:
                log.error(f"Failed to import variable module {module_name}: {str(e)}")
    
    log.info(f"Total registered variables: {len(registered_vars)}")
    return registered_vars

# Register all variables on import
register_all_variables()

================================================================================
File: run_migration.py
Path: .\backend\migrations\run_migration.py
Size: 1026
Modified: 2025-05-02T10:52:19.998163
Created: 2025-04-26T11:11:54.555047
Hash: 6268e920aa79ccc6a0eb146712584a6a6cbc72e363f1d55868c4ac6c4b08b66d
Lines: 39
================================================================================
import os
import sys
from pathlib import Path

# Add the parent directory to the Python path
current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent
sys.path.append(str(parent_dir))

from backend.db import get_db_connection, release_db_connection

def run_migration():
    """Run the conversations table migration."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Read the SQL file
        migration_file = current_dir / 'create_conversations_table.sql'
        with open(migration_file, 'r') as f:
            sql = f.read()

        # Execute the SQL
        cursor.execute(sql)
        conn.commit()
        print("Migration completed successfully!")

    except Exception as e:
        print(f"Error running migration: {str(e)}")
        if conn:
            conn.rollback()
        raise
    finally:
        if conn:
            release_db_connection(conn)

if __name__ == '__main__':
    run_migration()

================================================================================
File: enhanced_monitoring.py
Path: .\backend\monitoring\enhanced_monitoring.py
Size: 23031
Modified: 2025-05-04T01:41:41.377804
Created: 2025-05-03T20:06:42.183707
Hash: 0073344929519506f2f7f9a87a41e7100276a4a41695f14caf61a435d31f7dd6
Lines: 641
================================================================================
"""
Enhanced Monitoring System

This module provides advanced monitoring capabilities for the data extraction system,
building upon the existing ExtractionDashboard functionality.
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import json
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import numpy as np
from backend.db import get_db_connection, release_db_connection
from backend.monitoring.extraction_dashboard import ExtractionDashboard
import plotly.express as px

log = logging.getLogger(__name__)

class EnhancedMonitoring(ExtractionDashboard):
    """
    Enhanced monitoring system that extends the basic ExtractionDashboard with
    additional features for better debugging and analysis.
    """
    
    def __init__(self, db_pool):
        super().__init__(db_pool)
        self.performance_metrics = {}
        self.error_patterns = {}
        self.template_analysis = {}
        self.logger = logging.getLogger(__name__)
    
    def get_processing_pipeline_metrics(self) -> Dict[str, Any]:
        """
        Get detailed metrics about the processing pipeline.
        
        Returns:
            Dictionary containing pipeline metrics
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get stage-wise performance
            cursor.execute("""
                SELECT stage,
                       COUNT(*) as total,
                       COUNT(CASE WHEN success THEN 1 END) as successful,
                       AVG(processing_time) as avg_time,
                       MAX(processing_time) as max_time,
                       MIN(processing_time) as min_time
                FROM processing_stages
                GROUP BY stage
                ORDER BY total DESC
            """)
            
            rows = cursor.fetchall()
            
            # Create pipeline visualization
            fig = make_subplots(rows=2, cols=1, subplot_titles=("Stage Performance", "Processing Time"))
            
            # Add stage performance bars
            fig.add_trace(
                go.Bar(
                    x=[row[0] for row in rows],
                    y=[row[2]/row[1] if row[1] > 0 else 0 for row in rows],
                    name="Success Rate"
                ),
                row=1, col=1
            )
            
            # Add processing time scatter
            fig.add_trace(
                go.Scatter(
                    x=[row[0] for row in rows],
                    y=[row[3] for row in rows],
                    name="Average Time",
                    mode='lines+markers'
                ),
                row=2, col=1
            )
            
            fig.update_layout(
                title="Processing Pipeline Metrics",
                height=800
            )
            
            return {
                'stage_metrics': [
                    {
                        'stage': row[0],
                        'total': row[1],
                        'successful': row[2],
                        'success_rate': row[2]/row[1] if row[1] > 0 else 0,
                        'avg_time': float(row[3]) if row[3] else 0,
                        'max_time': float(row[4]) if row[4] else 0,
                        'min_time': float(row[5]) if row[5] else 0
                    }
                    for row in rows
                ],
                'pipeline_plot': fig.to_json()
            }
            
        except Exception as e:
            log.error(f"Error getting pipeline metrics: {str(e)}")
            return {}
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_ai_performance_metrics(self) -> Dict[str, Any]:
        """
        Get performance metrics specific to AI components.
        
        Returns:
            Dictionary containing AI performance metrics
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get AI model performance
            cursor.execute("""
                SELECT call_type as model_name,
                       COUNT(*) as total_calls,
                       AVG(completion_time) as avg_response_time,
                       AVG(tokens_used) as avg_tokens,
                       COUNT(*) as successful_calls
                FROM llm_calls
                GROUP BY call_type
                ORDER BY total_calls DESC
            """)
            
            rows = cursor.fetchall()
            
            if not rows:
                return {
                    'model_metrics': [],
                    'ai_plot': '{}'
                }
            
            # Create AI performance visualization
            fig = make_subplots(rows=2, cols=1, subplot_titles=("Model Usage", "Performance Metrics"))
            
            # Add model usage bars
            fig.add_trace(
                go.Bar(
                    x=[row[0] for row in rows],
                    y=[row[1] for row in rows],
                    name="Total Calls"
                ),
                row=1, col=1
            )
            
            # Add performance metrics
            fig.add_trace(
                go.Scatter(
                    x=[row[0] for row in rows],
                    y=[row[2] for row in rows],
                    name="Avg Response Time",
                    mode='lines+markers'
                ),
                row=2, col=1
            )
            
            fig.update_layout(
                title="AI Performance Metrics",
                height=800
            )
            
            return {
                'model_metrics': [
                    {
                        'model_name': row[0],
                        'total_calls': row[1],
                        'avg_response_time': float(row[2]) if row[2] else 0,
                        'avg_tokens': float(row[3]) if row[3] else 0,
                        'success_rate': row[4]/row[1] if row[1] > 0 else 0
                    }
                    for row in rows
                ],
                'ai_plot': fig.to_json()
            }
            
        except Exception as e:
            log.error(f"Error getting AI performance metrics: {str(e)}")
            return {
                'model_metrics': [],
                'ai_plot': '{}'
            }
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_error_pattern_analysis(self) -> Dict[str, Any]:
        """
        Get detailed analysis of error patterns.
        
        Returns:
            Dictionary containing error pattern analysis
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get detailed error patterns
            cursor.execute("""
                SELECT error_type,
                       stage,
                       COUNT(*) as error_count,
                       AVG(processing_time) as avg_time,
                       MAX(processing_time) as max_time
                FROM error_logs
                GROUP BY error_type, stage
                ORDER BY error_count DESC
                LIMIT 20
            """)
            
            rows = cursor.fetchall()
            
            # Create error pattern visualization
            fig = go.Figure()
            
            # Add error type bars
            fig.add_trace(go.Bar(
                x=[f"{row[0]} ({row[1]})" for row in rows],
                y=[row[2] for row in rows],
                name="Error Count"
            ))
            
            # Add processing time scatter
            fig.add_trace(go.Scatter(
                x=[f"{row[0]} ({row[1]})" for row in rows],
                y=[row[3] for row in rows],
                name="Average Time",
                mode='lines+markers'
            ))
            
            fig.update_layout(
                title="Error Pattern Analysis",
                xaxis_title="Error Type (Stage)",
                yaxis_title="Count/Time"
            )
            
            return {
                'error_patterns': [
                    {
                        'error_type': row[0],
                        'stage': row[1],
                        'error_count': row[2],
                        'avg_time': float(row[3]) if row[3] else 0,
                        'max_time': float(row[4]) if row[4] else 0
                    }
                    for row in rows
                ],
                'error_pattern_plot': fig.to_json()
            }
            
        except Exception as e:
            log.error(f"Error getting error pattern analysis: {str(e)}")
            return {}
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_enhanced_dashboard_data(self) -> Dict[str, Any]:
        """
        Get all enhanced dashboard data.
        
        Returns:
            Dictionary containing all enhanced dashboard data
        """
        return {
            'overview': self.get_overview_stats(),
            'performance_trends': self.get_performance_trends(),
            'pattern_analysis': self.get_pattern_analysis(),
            'error_analysis': self.get_error_analysis(),
            'template_performance': self.get_template_performance(),
            'pipeline_metrics': self.get_processing_pipeline_metrics(),
            'ai_performance': self.get_ai_performance_metrics(),
            'error_patterns': self.get_error_pattern_analysis()
        }

    def get_trend_plot(self, days=7):
        """Generate a plot showing performance trends over time."""
        try:
            data = self.get_performance_trends(days)
            if not data or not data.get('trend_data'):
                # Create empty plot with message
                fig = go.Figure()
                fig.add_annotation(
                    text="No data available",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5,
                    showarrow=False,
                    font=dict(size=20)
                )
                fig.update_layout(
                    title='Performance Trends',
                    xaxis_title='Date',
                    yaxis_title='Success Rate (%)',
                    template='plotly_white'
                )
                return fig.to_json()
            
            df = pd.DataFrame(data['trend_data'])
            
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=df['date'],
                y=df['success_rate'] * 100,  # Convert to percentage
                mode='lines+markers',
                name='Success Rate',
                line=dict(color='#28a745')
            ))
            
            fig.update_layout(
                title='Performance Trends',
                xaxis_title='Date',
                yaxis_title='Success Rate (%)',
                template='plotly_white'
            )
            
            return fig.to_json()
        except Exception as e:
            self.logger.error(f"Error generating trend plot: {str(e)}")
            return None

    def get_pipeline_plot(self):
        """Generate a plot showing processing pipeline metrics."""
        try:
            data = self.get_processing_pipeline_metrics()
            if not data or not data.get('stage_metrics'):
                # Create empty plot with message
                fig = go.Figure()
                fig.add_annotation(
                    text="No data available",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5,
                    showarrow=False,
                    font=dict(size=20)
                )
                fig.update_layout(
                    title='Processing Pipeline Performance',
                    xaxis_title='Stage',
                    yaxis_title='Value',
                    barmode='group',
                    template='plotly_white'
                )
                return fig.to_json()
            
            df = pd.DataFrame(data['stage_metrics'])
            
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=df['stage'],
                y=df['success_rate'] * 100,  # Convert to percentage
                name='Success Rate',
                marker_color='#28a745'
            ))
            
            fig.update_layout(
                title='Processing Pipeline Performance',
                xaxis_title='Stage',
                yaxis_title='Success Rate (%)',
                barmode='group',
                template='plotly_white'
            )
            
            return fig.to_json()
        except Exception as e:
            self.logger.error(f"Error generating pipeline plot: {str(e)}")
            return None

    def get_ai_performance_plot(self):
        """Generate a plot showing AI performance metrics."""
        try:
            data = self.get_ai_performance_metrics()
            if not data or not data.get('model_metrics'):
                # Create empty plot with message
                fig = go.Figure()
                fig.add_annotation(
                    text="No data available",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5,
                    showarrow=False,
                    font=dict(size=20)
                )
                fig.update_layout(
                    title='AI Performance Metrics',
                    xaxis_title='Model',
                    yaxis_title='Success Rate (%)',
                    template='plotly_white'
                )
                return fig.to_json()
            
            df = pd.DataFrame(data['model_metrics'])
            
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=df['model_name'],
                y=df['success_rate'] * 100,  # Convert to percentage
                mode='lines+markers',
                name='Success Rate',
                line=dict(color='#28a745')
            ))
            
            fig.update_layout(
                title='AI Performance Metrics',
                xaxis_title='Model',
                yaxis_title='Success Rate (%)',
                template='plotly_white'
            )
            
            return fig.to_json()
        except Exception as e:
            self.logger.error(f"Error generating AI performance plot: {str(e)}")
            # Return a valid empty plot JSON instead of None
            fig = go.Figure()
            fig.add_annotation(
                text="Error loading data",
                xref="paper", yref="paper",
                x=0.5, y=0.5,
                showarrow=False,
                font=dict(size=20)
            )
            fig.update_layout(
                title='AI Performance Metrics',
                xaxis_title='Model',
                yaxis_title='Success Rate (%)',
                template='plotly_white'
            )
            return fig.to_json()

    def get_pattern_plot(self):
        """Generate a plot showing pattern analysis."""
        try:
            data = self.get_pattern_analysis()
            if not data or not data.get('pattern_stats'):
                # Create empty plot with message
                fig = go.Figure()
                fig.add_annotation(
                    text="No data available",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5,
                    showarrow=False,
                    font=dict(size=20)
                )
                fig.update_layout(
                    title='Pattern Analysis',
                    xaxis_title='Pattern Type',
                    yaxis_title='Value',
                    barmode='group',
                    template='plotly_white'
                )
                return fig.to_json()
            
            df = pd.DataFrame(data['pattern_stats'])
            
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=df['field'],
                y=df['success_rate'],
                name='Success Rate',
                marker_color='#28a745'
            ))
            fig.add_trace(go.Bar(
                x=df['field'],
                y=df['usage_count'],
                name='Usage Count',
                marker_color='#007bff'
            ))
            
            fig.update_layout(
                title='Pattern Analysis',
                xaxis_title='Field',
                yaxis_title='Value',
                barmode='group',
                template='plotly_white'
            )
            
            return fig.to_json()
        except Exception as e:
            self.logger.error(f"Error generating pattern plot: {str(e)}")
            return None

    def get_error_plot(self):
        """Generate a plot showing error analysis."""
        try:
            data = self.get_error_analysis()
            if not data or not data.get('error_stats'):
                # Create empty plot with message
                fig = go.Figure()
                fig.add_annotation(
                    text="No data available",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5,
                    showarrow=False,
                    font=dict(size=20)
                )
                fig.update_layout(
                    title='Error Analysis',
                    xaxis_title='Error Type',
                    yaxis_title='Count',
                    template='plotly_white'
                )
                return fig.to_json()
            
            df = pd.DataFrame(data['error_stats'])
            
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=df['error_type'],
                y=df['count'],
                name='Error Count',
                marker_color='#dc3545'
            ))
            
            fig.update_layout(
                title='Error Analysis',
                xaxis_title='Error Type',
                yaxis_title='Count',
                template='plotly_white'
            )
            
            return fig.to_json()
        except Exception as e:
            self.logger.error(f"Error generating error plot: {str(e)}")
            return None

    def get_error_pattern_plot(self):
        """Generate a plot showing error patterns."""
        try:
            data = self.get_error_pattern_analysis()
            if not data or not data.get('error_patterns'):
                # Create empty plot with message
                fig = go.Figure()
                fig.add_annotation(
                    text="No data available",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5,
                    showarrow=False,
                    font=dict(size=20)
                )
                fig.update_layout(
                    title='Error Patterns',
                    xaxis_title='Error Pattern',
                    yaxis_title='Occurrence Count',
                    template='plotly_white'
                )
                return fig.to_json()
            
            df = pd.DataFrame(data['error_patterns'])
            
            # Ensure required columns exist
            if 'error_pattern' not in df.columns:
                df['error_pattern'] = 'Unknown Error'
            if 'occurrence_count' not in df.columns:
                df['occurrence_count'] = 0
            
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=df['error_pattern'],
                y=df['occurrence_count'],
                name='Occurrence Count',
                marker_color='#dc3545'
            ))
            
            fig.update_layout(
                title='Error Patterns',
                xaxis_title='Error Pattern',
                yaxis_title='Occurrence Count',
                template='plotly_white'
            )
            
            return fig.to_json()
        except Exception as e:
            self.logger.error(f"Error generating error pattern plot: {str(e)}")
            return None

    def get_template_plot(self):
        """Generate a plot showing template performance."""
        try:
            data = self.get_template_performance()
            if not data or not data.get('template_stats'):
                # Create empty plot with message
                fig = go.Figure()
                fig.add_annotation(
                    text="No data available",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5,
                    showarrow=False,
                    font=dict(size=20)
                )
                fig.update_layout(
                    title='Template Performance',
                    xaxis_title='Template',
                    yaxis_title='Value',
                    barmode='group',
                    template='plotly_white'
                )
                return fig.to_json()
            
            df = pd.DataFrame(data['template_stats'])
            
            # Ensure required columns exist
            if 'template_name' not in df.columns:
                df['template_name'] = 'Unknown Template'
            if 'success_rate' not in df.columns:
                df['success_rate'] = 0
            if 'usage_count' not in df.columns:
                df['usage_count'] = 0
            
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=df['template_name'],
                y=df['success_rate'],
                name='Success Rate',
                marker_color='#28a745'
            ))
            fig.add_trace(go.Bar(
                x=df['template_name'],
                y=df['usage_count'],
                name='Usage Count',
                marker_color='#007bff'
            ))
            
            fig.update_layout(
                title='Template Performance',
                xaxis_title='Template',
                yaxis_title='Value',
                barmode='group',
                template='plotly_white'
            )
            
            return fig.to_json()
        except Exception as e:
            self.logger.error(f"Error generating template plot: {str(e)}")
            return None 

================================================================================
File: extraction_dashboard.py
Path: .\backend\monitoring\extraction_dashboard.py
Size: 12664
Modified: 2025-05-03T19:46:43.428676
Created: 2025-05-03T19:46:41.175857
Hash: dd02ccb9d0e8432434d46c6bb1fbdc0a0115b542c629a16d5ba935ae2b43bd82
Lines: 357
================================================================================
"""
Monitoring Dashboard for Enhanced Data Extraction

This module provides a dashboard for monitoring and analyzing the performance
of the enhanced data extraction system.
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import json
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import numpy as np
from backend.db import get_db_connection, release_db_connection

log = logging.getLogger(__name__)

class ExtractionDashboard:
    """
    Dashboard for monitoring and analyzing data extraction performance.
    """
    
    def __init__(self, db_pool):
        self.db_pool = db_pool
    
    def get_overview_stats(self) -> Dict[str, Any]:
        """
        Get overview statistics for the extraction system.
        
        Returns:
            Dictionary containing overview statistics
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get total extractions
            cursor.execute("""
                SELECT COUNT(*) as total_extractions,
                       COUNT(CASE WHEN success THEN 1 END) as successful_extractions,
                       COUNT(CASE WHEN NOT success THEN 1 END) as failed_extractions
                FROM extraction_results
            """)
            row = cursor.fetchone()
            
            # Get pattern statistics
            cursor.execute("""
                SELECT COUNT(*) as total_patterns,
                       AVG(success_rate) as avg_success_rate,
                       COUNT(CASE WHEN success_rate > 0.7 THEN 1 END) as high_confidence_patterns
                FROM pattern_data
            """)
            pattern_stats = cursor.fetchone()
            
            # Get recent performance
            cursor.execute("""
                SELECT COUNT(*) as recent_extractions,
                       COUNT(CASE WHEN success THEN 1 END) as recent_successes,
                       COUNT(CASE WHEN NOT success THEN 1 END) as recent_failures
                FROM extraction_results
                WHERE timestamp > NOW() - INTERVAL '24 hours'
            """)
            recent_stats = cursor.fetchone()
            
            return {
                'total_extractions': row[0],
                'successful_extractions': row[1],
                'failed_extractions': row[2],
                'success_rate': row[1] / row[0] if row[0] > 0 else 0,
                'total_patterns': pattern_stats[0],
                'avg_success_rate': float(pattern_stats[1]) if pattern_stats[1] else 0,
                'high_confidence_patterns': pattern_stats[2],
                'recent_extractions': recent_stats[0],
                'recent_success_rate': recent_stats[1] / recent_stats[0] if recent_stats[0] > 0 else 0
            }
            
        except Exception as e:
            log.error(f"Error getting overview stats: {str(e)}")
            return {}
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_performance_trends(self, days: int = 7) -> Dict[str, Any]:
        """
        Get performance trends over time.
        
        Args:
            days: Number of days to analyze
            
        Returns:
            Dictionary containing performance trends
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get daily performance
            cursor.execute("""
                SELECT DATE_TRUNC('day', timestamp) as date,
                       COUNT(*) as total,
                       COUNT(CASE WHEN success THEN 1 END) as successful,
                       COUNT(CASE WHEN NOT success THEN 1 END) as failed
                FROM extraction_results
                WHERE timestamp > NOW() - INTERVAL '%s days'
                GROUP BY date
                ORDER BY date
            """, (days,))
            
            rows = cursor.fetchall()
            
            # Convert to DataFrame for easier processing
            df = pd.DataFrame(rows, columns=['date', 'total', 'successful', 'failed'])
            df['success_rate'] = df['successful'] / df['total']
            
            # Create trend visualization
            fig = make_subplots(specs=[[{"secondary_y": True}]])
            
            fig.add_trace(
                go.Scatter(x=df['date'], y=df['total'], name="Total Extractions"),
                secondary_y=False
            )
            
            fig.add_trace(
                go.Scatter(x=df['date'], y=df['success_rate'], name="Success Rate"),
                secondary_y=True
            )
            
            fig.update_layout(
                title="Extraction Performance Trends",
                xaxis_title="Date",
                yaxis_title="Number of Extractions",
                yaxis2_title="Success Rate"
            )
            
            return {
                'trend_data': df.to_dict('records'),
                'trend_plot': fig.to_json()
            }
            
        except Exception as e:
            log.error(f"Error getting performance trends: {str(e)}")
            return {}
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_pattern_analysis(self) -> Dict[str, Any]:
        """
        Get analysis of extraction patterns.
        
        Returns:
            Dictionary containing pattern analysis
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get pattern statistics
            cursor.execute("""
                SELECT field, 
                       COUNT(*) as usage_count,
                       AVG(success_rate) as avg_success,
                       MAX(success_rate) as max_success,
                       MIN(success_rate) as min_success
                FROM pattern_data
                GROUP BY field
                ORDER BY usage_count DESC
            """)
            
            rows = cursor.fetchall()
            
            # Create pattern analysis visualization
            fig = go.Figure()
            
            fig.add_trace(go.Bar(
                x=[row[0] for row in rows],
                y=[row[1] for row in rows],
                name="Usage Count"
            ))
            
            fig.add_trace(go.Scatter(
                x=[row[0] for row in rows],
                y=[row[2] for row in rows],
                name="Average Success",
                mode='lines+markers'
            ))
            
            fig.update_layout(
                title="Pattern Analysis",
                xaxis_title="Field",
                yaxis_title="Count/Success Rate"
            )
            
            return {
                'pattern_stats': [
                    {
                        'field': row[0],
                        'usage_count': row[1],
                        'avg_success': float(row[2]) if row[2] else 0,
                        'max_success': float(row[3]) if row[3] else 0,
                        'min_success': float(row[4]) if row[4] else 0
                    }
                    for row in rows
                ],
                'pattern_plot': fig.to_json()
            }
            
        except Exception as e:
            log.error(f"Error getting pattern analysis: {str(e)}")
            return {}
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_error_analysis(self) -> Dict[str, Any]:
        """
        Get analysis of extraction errors.
        
        Returns:
            Dictionary containing error analysis
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get error patterns
            cursor.execute("""
                SELECT extracted_data->>'error' as error_type,
                       COUNT(*) as error_count
                FROM extraction_results
                WHERE NOT success
                GROUP BY error_type
                ORDER BY error_count DESC
                LIMIT 10
            """)
            
            rows = cursor.fetchall()
            
            # Create error analysis visualization
            fig = go.Figure(data=[
                go.Pie(
                    labels=[row[0] for row in rows],
                    values=[row[1] for row in rows],
                    hole=.3
                )
            ])
            
            fig.update_layout(
                title="Error Distribution"
            )
            
            return {
                'error_stats': [
                    {
                        'error_type': row[0],
                        'count': row[1]
                    }
                    for row in rows
                ],
                'error_plot': fig.to_json()
            }
            
        except Exception as e:
            log.error(f"Error getting error analysis: {str(e)}")
            return {}
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_template_performance(self) -> Dict[str, Any]:
        """
        Get performance analysis by template.
        
        Returns:
            Dictionary containing template performance analysis
        """
        try:
            conn = self.db_pool.getconn()
            cursor = conn.cursor()
            
            # Get template performance
            cursor.execute("""
                SELECT t.template_id,
                       t.template_name,
                       COUNT(er.extraction_id) as total_extractions,
                       COUNT(CASE WHEN er.success THEN 1 END) as successful_extractions,
                       AVG(pd.success_rate) as avg_pattern_success
                FROM templates t
                LEFT JOIN extraction_results er ON t.template_id = er.template_id
                LEFT JOIN pattern_data pd ON er.cluster_id = pd.cluster_id
                GROUP BY t.template_id, t.template_name
                ORDER BY total_extractions DESC
            """)
            
            rows = cursor.fetchall()
            
            # Create template performance visualization
            fig = go.Figure()
            
            fig.add_trace(go.Bar(
                x=[row[1] for row in rows],
                y=[row[2] for row in rows],
                name="Total Extractions"
            ))
            
            fig.add_trace(go.Bar(
                x=[row[1] for row in rows],
                y=[row[3] for row in rows],
                name="Successful Extractions"
            ))
            
            fig.update_layout(
                title="Template Performance",
                xaxis_title="Template",
                yaxis_title="Number of Extractions",
                barmode='group'
            )
            
            return {
                'template_stats': [
                    {
                        'template_id': row[0],
                        'template_name': row[1],
                        'total_extractions': row[2],
                        'successful_extractions': row[3],
                        'success_rate': row[3] / row[2] if row[2] > 0 else 0,
                        'avg_pattern_success': float(row[4]) if row[4] else 0
                    }
                    for row in rows
                ],
                'template_plot': fig.to_json()
            }
            
        except Exception as e:
            log.error(f"Error getting template performance: {str(e)}")
            return {}
        finally:
            if conn:
                self.db_pool.putconn(conn)
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """
        Get all dashboard data in one call.
        
        Returns:
            Dictionary containing all dashboard data
        """
        return {
            'overview': self.get_overview_stats(),
            'performance_trends': self.get_performance_trends(),
            'pattern_analysis': self.get_pattern_analysis(),
            'error_analysis': self.get_error_analysis(),
            'template_performance': self.get_template_performance()
        } 

================================================================================
File: populate_test_data.py
Path: .\backend\monitoring\populate_test_data.py
Size: 8624
Modified: 2025-05-04T01:32:31.404962
Created: 2025-05-04T00:42:30.616907
Hash: 3a948c1f9c9ce4aef53218fcdf1315493515aa97c9fa79a036f73c2f16f3bce6
Lines: 236
================================================================================
"""
Script to populate monitoring tables with test data.
"""

import psycopg2
from psycopg2.extras import DictCursor
from datetime import datetime, timedelta
import json
import uuid
import random
from typing import Dict, Any

# Database configuration
DB_CONFIG = {
    'dbname': 'icmp_db',
    'user': 'icmp_user',
    'password': 'your_password',  # Replace with actual password
    'host': 'localhost',
    'port': '5432'
}

def get_db_connection():
    """Get database connection."""
    return psycopg2.connect(**DB_CONFIG)

def populate_templates(conn):
    """Populate templates table with test data."""
    cursor = conn.cursor()
    
    # Use the existing business_id
    business_id = 'bc7e1824-49b4-4056-aabe-b045a1f79e3b'
    
    # Sample templates
    templates = [
        {
            'template_id': str(uuid.uuid4()),
            'business_id': business_id,
            'template_name': 'Contact Information',
            'template_type': 'data_extraction',
            'content': 'Extract name, email, and phone from the message',
            'system_prompt': 'Extract contact information from the message'
        },
        {
            'template_id': str(uuid.uuid4()),
            'business_id': business_id,
            'template_name': 'Order Details',
            'template_type': 'data_extraction',
            'content': 'Extract order number, product, and quantity',
            'system_prompt': 'Extract order details from the message'
        }
    ]
    
    for template in templates:
        cursor.execute("""
            INSERT INTO templates 
            (template_id, business_id, template_name, template_type, content, system_prompt)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (
            template['template_id'],
            template['business_id'],
            template['template_name'],
            template['template_type'],
            template['content'],
            template['system_prompt']
        ))
    
    conn.commit()
    return templates

def populate_extraction_results(conn, templates):
    """Populate extraction_results table with test data."""
    cursor = conn.cursor()
    
    # Use the existing business_id
    business_id = 'bc7e1824-49b4-4056-aabe-b045a1f79e3b'
    
    # Generate test data for the last 7 days
    for i in range(7):
        date = datetime.now() - timedelta(days=i)
        for template in templates:
            for _ in range(random.randint(5, 15)):  # 5-15 extractions per day per template
                success = random.random() > 0.2  # 80% success rate
                cursor.execute("""
                    INSERT INTO extraction_results 
                    (template_id, business_id, timestamp, success, extracted_data)
                    VALUES (%s, %s, %s, %s, %s)
                """, (
                    template['template_id'],
                    business_id,
                    date,
                    success,
                    json.dumps({
                        'field1': 'value1',
                        'field2': 'value2'
                    })
                ))
    
    conn.commit()

def populate_processing_stages(conn, templates):
    """Populate processing_stages table with test data."""
    cursor = conn.cursor()
    
    # Use the existing business_id
    business_id = 'bc7e1824-49b4-4056-aabe-b045a1f79e3b'
    
    stages = ['preprocessing', 'extraction', 'validation', 'postprocessing']
    
    # First get some extraction_ids to reference
    cursor.execute("SELECT extraction_id FROM extraction_results LIMIT 10")
    extraction_ids = [row[0] for row in cursor.fetchall()]
    
    if not extraction_ids:
        # If no extraction_results exist yet, create some
        for _ in range(10):
            cursor.execute("""
                INSERT INTO extraction_results 
                (template_id, business_id, timestamp, success, extracted_data)
                VALUES (%s, %s, %s, %s, %s)
                RETURNING extraction_id
            """, (
                templates[0]['template_id'],
                business_id,
                datetime.now(),
                True,
                json.dumps({'test': 'data'})
            ))
            extraction_ids.append(cursor.fetchone()[0])
        conn.commit()
    
    for extraction_id in extraction_ids:
        for stage in stages:
            success = random.random() > 0.1  # 90% success rate
            cursor.execute("""
                INSERT INTO processing_stages 
                (extraction_id, stage, success, processing_time, business_id, created_at)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (
                extraction_id,
                stage,
                success,
                random.uniform(0.1, 2.0),  # Processing time between 0.1 and 2.0 seconds
                business_id,
                datetime.now() - timedelta(days=random.randint(0, 7))
            ))
    
    conn.commit()

def populate_error_logs(conn, templates):
    """Populate error_logs table with test data."""
    cursor = conn.cursor()
    
    error_types = ['validation_error', 'extraction_error', 'processing_error', 'timeout']
    stages = ['preprocessing', 'extraction', 'validation', 'postprocessing']
    endpoints = ['/api/message', '/api/templates', '/api/extraction']
    
    for template in templates:
        for error_type in error_types:
            for stage in stages:
                for _ in range(random.randint(1, 5)):  # 1-5 errors per type per stage
                    cursor.execute("""
                        INSERT INTO error_logs 
                        (timestamp, error_type, error_message, stack_trace, endpoint, stage, processing_time)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (
                        datetime.now() - timedelta(days=random.randint(0, 7)),
                        error_type,
                        f"Test error message for {error_type} in {stage}",
                        "Test stack trace",
                        random.choice(endpoints),
                        stage,
                        random.uniform(0.1, 1.0)  # Processing time between 0.1 and 1.0 seconds
                    ))
    
    conn.commit()

def populate_llm_calls(conn, templates):
    """Populate llm_calls table with test data."""
    cursor = conn.cursor()
    
    # Use the existing business_id
    business_id = 'bc7e1824-49b4-4056-aabe-b045a1f79e3b'
    
    call_types = ['data_extraction', 'classification', 'summarization']
    input_texts = [
        "Please extract contact information from this message",
        "Classify this message as urgent or normal",
        "Summarize the following text",
        "Extract order details from this message",
        "Identify the main topic of this text"
    ]
    
    for template in templates:
        for call_type in call_types:
            for _ in range(random.randint(5, 10)):  # 5-10 calls per type
                cursor.execute("""
                    INSERT INTO llm_calls 
                    (call_id, business_id, input_text, call_type, completion_time, tokens_used, system_prompt)
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                """, (
                    str(uuid.uuid4()),  # Generate new UUID for call_id
                    business_id,
                    random.choice(input_texts),
                    call_type,
                    random.uniform(0.5, 3.0),  # Completion time between 0.5 and 3.0 seconds
                    random.randint(100, 1000),  # Tokens used between 100 and 1000
                    f"System prompt for {call_type}"
                ))
    
    conn.commit()

def main():
    """Main function to populate all tables."""
    conn = None
    try:
        conn = get_db_connection()
        
        # Populate tables in order
        templates = populate_templates(conn)
        populate_extraction_results(conn, templates)
        populate_processing_stages(conn, templates)
        populate_error_logs(conn, templates)
        populate_llm_calls(conn, templates)
        
        print("Successfully populated test data")
        
    except Exception as e:
        print(f"Error populating test data: {str(e)}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()

if __name__ == "__main__":
    main() 

================================================================================
File: agents.py
Path: .\backend\routes\agents.py
Size: 12642
Modified: 2025-05-07T11:52:19.778334
Created: 2025-04-02T20:05:05.711907
Hash: bca39bfab39bcd5c7b573d827667b17e1de2b61b801369148a7c55603c20a991
Lines: 304
================================================================================
# backend/routes/agents.py
from flask import Blueprint, jsonify, request, g
import logging
import uuid
import json
import os
import sys
from psycopg2.extras import RealDictCursor

# Handle imports whether run as module or directly
if os.path.dirname(os.path.dirname(os.path.abspath(__file__))) not in sys.path:
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from backend.db import get_db_connection, release_db_connection
from backend.auth import require_api_key, require_internal_key
from backend.routes.utils import is_valid_uuid

log = logging.getLogger(__name__)

agents_bp = Blueprint('agents', __name__, url_prefix='/api/agents')

@agents_bp.route('', methods=['GET'])
@require_api_key
def get_agents():
    """Lists agents, requires admin key. Optionally filter by business_id."""
    # Get optional business_id filter
    business_id_filter = request.args.get('business_id')
    if business_id_filter and not is_valid_uuid(business_id_filter):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format in query parameter"}), 400
        
    log_msg = "Fetching all agents (admin)"
    if business_id_filter:
        log_msg += f" filtered by business_id={business_id_filter}"
    log.info(log_msg)

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=RealDictCursor)

        params = []
        query = """
            SELECT agent_id, business_id, agent_name, created_at, updated_at
            FROM agents
        """
        
        where_clauses = []
        if business_id_filter:
            where_clauses.append("business_id = %s")
            params.append(business_id_filter)
        
        if where_clauses:
             query += " WHERE " + " AND ".join(where_clauses)
             
        query += " ORDER BY created_at DESC;"
        
        cursor.execute(query, tuple(params))
        agents = cursor.fetchall()
        
        # Convert UUIDs and timestamps to strings
        for agent in agents:
            for key, value in agent.items():
                if isinstance(value, uuid.UUID):
                    agent[key] = str(value)
                elif hasattr(value, 'isoformat'):
                    agent[key] = value.isoformat()
            
        return jsonify(agents), 200

    except Exception as e:
        # Catch potential errors like table not existing if schema isn't confirmed
        error_detail = str(e)
        log.error(f"Error fetching agents (admin): {error_detail}", exc_info=True)
        if "relation \"agents\" does not exist" in error_detail.lower():
             return jsonify({"error_code": "SERVER_CONFIG_ERROR", "message": "Agents table not found. Please check database schema.", "details": error_detail}), 500
        return jsonify({"error_code": "SERVER_ERROR", "message": "Failed to fetch agents data", "details": error_detail}), 500
    finally:
        if conn:
            release_db_connection(conn)

@agents_bp.route('', methods=['POST'])
@require_api_key
def create_agent():
    """Creates a new agent for a business (admin access)."""
    data = request.get_json()
    if not data:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400
        
    # Get business_id from payload - IT IS REQUIRED for admin creation
    business_id = data.get('business_id')
    agent_name = data.get('name') # Assuming 'name' is used based on update route
    
    if not business_id:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required field in payload: business_id"}), 400
    if not is_valid_uuid(business_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format in payload"}), 400
    if not agent_name or not str(agent_name).strip():
         return jsonify({"error_code": "BAD_REQUEST", "message": "Missing or empty required field in payload: name"}), 400

    log.info(f"Admin creating agent '{agent_name}' for business {business_id}")

    agent_id = str(uuid.uuid4())
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Verify the target business_id exists before creating the agent
        cursor.execute("SELECT 1 FROM businesses WHERE business_id = %s", (business_id,))
        if not cursor.fetchone():
             return jsonify({"error_code": "NOT_FOUND", "message": f"Business with ID {business_id} not found"}), 404

        cursor.execute("""
            INSERT INTO agents (agent_id, business_id, agent_name)
            VALUES (%s, %s, %s)
            RETURNING agent_id, business_id, agent_name, created_at, updated_at;
        """, (
            agent_id,
            business_id,
            agent_name
        ))
        result = cursor.fetchone()
        conn.commit()
        
        # Convert UUIDs and timestamps to strings
        agent = {
            'agent_id': str(result[0]),
            'business_id': str(result[1]),
            'agent_name': result[2],
            'created_at': result[3].isoformat() if result[3] else None,
            'updated_at': result[4].isoformat() if result[4] else None
        }
        
        log.info(f"Agent {agent_id} created for business {business_id} by admin")
        return jsonify(agent), 201

    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error creating agent for business {business_id}: {str(e)}", exc_info=True)
        if "unique constraint" in str(e).lower() and "agents_business_id_agent_name_key" in str(e).lower():
             return jsonify({"error_code": "CONFLICT", "message": "Agent name already exists for this business"}), 409
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@agents_bp.route('/<agent_id>', methods=['PUT'])
@require_api_key
def update_agent(agent_id):
    """Updates an existing agent."""
    if not is_valid_uuid(agent_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid agent_id format"}), 400

    data = request.get_json()
    if not data:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400

    business_id = data.get('business_id')
    if not business_id:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required field: business_id"}), 400
    if not is_valid_uuid(business_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format"}), 400

    # Only allow updating agent_name for now
    agent_name = data.get('name')
    if not agent_name or not str(agent_name).strip():
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing or empty required field: name"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT 1 FROM agents WHERE agent_id = %s AND business_id = %s", 
                       (agent_id, business_id))
        if not cursor.fetchone():
            log.warning(f"Update attempted on non-existent or unauthorized agent {agent_id} for business {business_id}")
            return jsonify({"error_code": "NOT_FOUND", "message": "Agent not found or access denied"}), 404

        cursor.execute("""
            UPDATE agents 
            SET agent_name = %s, updated_at = NOW() 
            WHERE agent_id = %s AND business_id = %s
            RETURNING agent_id, business_id, agent_name, created_at, updated_at;
        """, (agent_name, agent_id, business_id))
        
        result = cursor.fetchone()
        if not result:
            log.warning(f"Update affected 0 rows for agent {agent_id}, business {business_id}")
            return jsonify({"error_code": "NOT_FOUND", "message": "Agent not found or access denied during update"}), 404
            
        conn.commit()
        
        # Convert UUIDs and timestamps to strings
        agent = {
            'agent_id': str(result[0]),
            'business_id': str(result[1]),
            'agent_name': result[2],
            'created_at': result[3].isoformat() if result[3] else None,
            'updated_at': result[4].isoformat() if result[4] else None
        }
        
        log.info(f"Agent {agent_id} updated successfully for business {business_id}")
        return jsonify(agent), 200

    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error updating agent {agent_id} for business {business_id}: {str(e)}", exc_info=True)
        if "unique constraint" in str(e).lower() and "agents_business_id_agent_name_key" in str(e).lower():
             return jsonify({"error_code": "CONFLICT", "message": "Agent name already exists for this business"}), 409
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@agents_bp.route('/<agent_id>', methods=['DELETE'])
@require_api_key
def delete_agent(agent_id):
    """Deletes an agent."""
    business_id = request.args.get('business_id')
    if not business_id:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required query parameter: business_id"}), 400
    if not is_valid_uuid(business_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format"}), 400

    log.info(f"Deleting agent {agent_id} for business {business_id}")

    if not is_valid_uuid(agent_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid agent_id format"}), 400
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # First verify the agent exists and belongs to the specified business
        query = """
            SELECT 1 FROM agents
            WHERE agent_id = %s AND business_id = %s;
        """
        cursor.execute(query, (agent_id, business_id))
        if cursor.fetchone() is None:
            return jsonify({"error_code": "NOT_FOUND", "message": "Agent not found or does not belong to the specified business"}), 404
        
        # Delete the agent
        query = """
            DELETE FROM agents
            WHERE agent_id = %s AND business_id = %s;
        """
        cursor.execute(query, (agent_id, business_id))
        conn.commit()
        
        return jsonify({"message": "Agent deleted successfully"}), 200
        
    except Exception as e:
        if conn:
            conn.rollback()
        error_detail = str(e)
        log.error(f"Error deleting agent {agent_id} for business {business_id}: {error_detail}", exc_info=True)
        return jsonify({"error_code": "SERVER_ERROR", "message": "Failed to delete agent", "details": error_detail}), 500
    finally:
        if conn:
            release_db_connection(conn)

@agents_bp.route('/<agent_id>', methods=['GET'])
@require_api_key
def get_agent(agent_id):
    """Get a specific agent by ID using admin key."""
    if not is_valid_uuid(agent_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid agent_id format"}), 400
        
    log.info(f"Fetching agent {agent_id} via admin key")

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=RealDictCursor)

        cursor.execute("""
            SELECT agent_id, business_id, agent_name, created_at, updated_at
            FROM agents 
            WHERE agent_id = %s;
        """, (agent_id,))
        
        agent = cursor.fetchone()
        
        if not agent:
             return jsonify({"error_code": "NOT_FOUND", "message": "Agent not found"}), 404
        
        # Convert UUIDs and datetimes
        for key, value in agent.items():
            if isinstance(value, uuid.UUID):
                agent[key] = str(value)
            elif hasattr(value, 'isoformat'):
                agent[key] = value.isoformat()
        
        return jsonify(agent), 200

    except Exception as e:
        log.error(f"Error fetching agent {agent_id} (admin): {str(e)}", exc_info=True)
        return jsonify({"error_code": "SERVER_ERROR", "message": "Failed to fetch agent data", "details": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

================================================================================
File: auth_bp.py
Path: .\backend\routes\auth_bp.py
Size: 1282
Modified: 2025-05-02T10:52:20.022683
Created: 2025-04-09T09:52:48.418956
Hash: e015a55081f1ead88051bd538314fc2ddc159d8a9fc26e3e80d260e81088bf2f
Lines: 36
================================================================================
"""
Authentication routes module.

Handles administrative authentication checks.
Webhook authentication is handled within webhook handlers directly (signature verification).
Internal service authentication relies on internal API keys validated by @require_internal_key.
"""

from flask import Blueprint, jsonify, request, make_response
import logging
# Remove unused imports related to old flows
# import uuid
# import secrets
# from db import get_db_connection, release_db_connection
# from utils import is_valid_uuid
from backend.auth import require_api_key # Import the master key decorator

log = logging.getLogger(__name__)

# Create blueprint for auth endpoints, prefix likely /api based on logs
bp = Blueprint('auth_bp', __name__, url_prefix='/api')

# --- Routes related to businessApiKey cookie flow removed --- 
# /validate-credentials
# /set-cookies
# /clear-cookies
# /save-config
# /validate-config

# Example: A route still protected by the master API key
@bp.route('/admin-check', methods=['GET'])
@require_api_key
def admin_check():
    """Example route requiring the master ICMP_API_KEY for admin tasks."""
    log.info("Admin check endpoint accessed successfully.")
    return jsonify({"message": "Master API key is valid"}), 200

================================================================================
File: businesses.py
Path: .\backend\routes\businesses.py
Size: 11238
Modified: 2025-05-04T23:55:07.990566
Created: 2025-03-31T17:53:17.313072
Hash: 71d1226a8a71066dfbb95abd1dc219ccc92eeca3459bddfe1f254323c9b0070f
Lines: 268
================================================================================
from flask import Blueprint, jsonify, request, g
import uuid
import logging
from jsonschema import validate, ValidationError
import os
import sys
import secrets
import json

# Handle imports whether run as module or directly
if os.path.dirname(os.path.dirname(os.path.abspath(__file__))) not in sys.path:
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from backend.db import get_db_connection, execute_query, release_db_connection
from backend.auth import require_api_key, require_internal_key
from backend.routes.utils import is_valid_uuid

log = logging.getLogger(__name__)

# --- Load necessary schemas --- 
def load_schema(schema_name):
    # Simple loader, assumes schemas dir is relative to this file's location
    # or uses a known path. Adjust path as needed.
    schema_path = os.path.join(os.path.dirname(__file__), '..', 'schemas', f"{schema_name}.json")
    try:
        with open(schema_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        log.error(f"Schema file not found: {schema_path}")
        return None
    except json.JSONDecodeError:
        log.error(f"Error decoding JSON from schema file: {schema_path}")
        return None

BUSINESS_CREATE_SCHEMA = load_schema('business_create')
# --- End Schema Loading ---

bp = Blueprint('businesses', __name__, url_prefix='/businesses')

@bp.route('/<business_path_id>', methods=['GET'])
@require_api_key
def get_business(business_path_id):
    if not is_valid_uuid(business_path_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format in URL"}), 400
        
    business_id_to_fetch = business_path_id
    log.info(f"Fetching business details for {business_id_to_fetch} via admin key")

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT business_id, api_key, owner_id, business_name, 
                   business_description, address, phone_number, website,
                   first_stage_id, internal_api_key, business_information
            FROM businesses
            WHERE business_id = %s;
        """, (business_id_to_fetch,))

        business_tuple = cursor.fetchone()
        if not business_tuple:
            return jsonify({"error_code": "NOT_FOUND", "message": "Business not found after auth"}), 404

        business_data = {
            "business_id": str(business_tuple[0]),
            "api_key": business_tuple[1],
            "owner_id": str(business_tuple[2]),
            "business_name": business_tuple[3],
            "business_description": business_tuple[4] or '',
            "address": business_tuple[5] or '',
            "phone_number": business_tuple[6] or '',
            "website": business_tuple[7] or '',
            "first_stage_id": str(business_tuple[8]) if business_tuple[8] else None,
            "internal_api_key": business_tuple[9] if len(business_tuple) > 9 and business_tuple[9] else None,
            "business_information": business_tuple[10] or ''
        }
        
        response = jsonify(business_data)
        return response, 200

    except Exception as e:
        log.error(f"Error retrieving business {business_id_to_fetch}: {str(e)}", exc_info=True)
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@bp.route('/', methods=['GET'])
@require_api_key
def list_businesses():
    """Lists all businesses (ID and Name) for admin view."""
    log.info("Fetching list of all businesses (admin view)")
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT business_id, business_name 
            FROM businesses
            ORDER BY business_name;
        """)
        businesses = cursor.fetchall()
        
        business_list = [
            {
                "business_id": str(row[0]),
                "business_name": row[1]
            } for row in businesses
        ]
        return jsonify(business_list), 200

    except Exception as e:
        log.error(f"Error retrieving business list (admin): {str(e)}", exc_info=True)
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@bp.route('/<business_path_id>', methods=['PUT'])
@require_api_key
def update_business(business_path_id):
    business_id_to_update = business_path_id
    log.info(f"Updating business {business_id_to_update} via admin key")

    if not is_valid_uuid(business_path_id):
        return jsonify({"error_code": "INVALID_REQUEST", "message": "Invalid business_id format in URL"}), 400

    data = request.get_json()
    if not data:
        return jsonify({"error_code": "INVALID_REQUEST", "message": "Request must be JSON and contain data"}), 400

    allowed_update_fields = [
        'business_name', 'business_description', 'address', 'phone_number', 'website', 'first_stage_id', 'owner_id', 'business_information'
    ]
    update_fields = {}
    validation_errors = []
    for field in allowed_update_fields:
        if field in data:
            value = data[field]
            if field == 'business_name' and (value is None or not str(value).strip()):
                validation_errors.append("business_name cannot be empty")
            elif field in ['first_stage_id', 'owner_id'] and value is not None and not is_valid_uuid(value):
                 validation_errors.append(f"{field} must be a valid UUID or null")
            elif value is not None and not isinstance(value, str) and field not in ['first_stage_id', 'owner_id']:
                validation_errors.append(f"{field} must be a string or null")
            if not any(field in err for err in validation_errors):
                update_fields[field] = value
    if validation_errors:
        return jsonify({"error_code": "VALIDATION_ERROR", "message": ", ".join(validation_errors)}), 400
    if not update_fields:
        return jsonify({"error_code": "NO_OP", "message": "No valid fields provided for update"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("SELECT 1 FROM businesses WHERE business_id = %s", (business_id_to_update,))
        if not cursor.fetchone():
            return jsonify({"error_code": "NOT_FOUND", "message": "Business not found"}), 404
            
        set_clause = ", ".join([f"{field} = %s" for field in update_fields])
        params = list(update_fields.values())
        params.append(business_id_to_update)

        sql = f"""
            UPDATE businesses 
            SET {set_clause}
            WHERE business_id = %s;
        """

        cursor.execute(sql, tuple(params))

        if cursor.rowcount == 0:
            log.warning(f"Update affected 0 rows for business {business_id_to_update}. Concurrent modification?")

        conn.commit()
        log.info(f"Business {business_id_to_update} updated successfully by admin.")
        
        response = jsonify({"message": "Business updated successfully"})
        return response, 200

    except Exception as e:
        if conn:
            conn.rollback()
        log.error(f"Error updating business {business_id_to_update} (admin): {str(e)}", exc_info=True)
        if "unique constraint" in str(e).lower():
             return jsonify({"error_code": "CONFLICT", "message": "Update failed due to unique constraint (e.g., duplicate name)"}), 409
        return jsonify({"error_code": "SERVER_ERROR", "message": "Failed to update business", "details": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@bp.route('/', methods=['POST'])
@require_api_key
def create_business():
    data = request.get_json()
    if not data:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400

    # Validate using jsonschema directly
    if not BUSINESS_CREATE_SCHEMA:
         log.error("Business creation schema failed to load.")
         return jsonify({"error_code": "CONFIG_ERROR", "message": "Server configuration error (schema)"}), 500
    try:
        validate(instance=data, schema=BUSINESS_CREATE_SCHEMA)
    except ValidationError as e:
        log.warning(f"Business creation schema validation failed: {str(e)}")
        # Provide more specific error detail from e.message
        return jsonify({"error_code": "VALIDATION_ERROR", "message": e.message}), 400
    
    business_id = str(uuid.uuid4())
    internal_api_key = secrets.token_hex(32)
    legacy_api_key = secrets.token_hex(32)

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Ensure owner_id is extracted correctly based on schema (might be nested)
        owner_id = data.get("owner_id") 
        biz_info = data.get("business_information", {}) # Schema uses nesting
        business_name = biz_info.get("business_name")
        business_description = biz_info.get("business_description")
        address = biz_info.get("address")
        phone_number = biz_info.get("phone_number")
        website = biz_info.get("website")
        
        # Check required fields after validation (belt-and-suspenders)
        if not owner_id or not business_name:
             log.error("owner_id or business_name missing after schema validation.") # Should not happen
             return jsonify({"error_code": "SERVER_ERROR", "message": "Internal data processing error"}), 500

        cursor.execute("""
            INSERT INTO businesses (business_id, api_key, internal_api_key, owner_id, business_name, business_description, address, phone_number, website)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING business_id, internal_api_key;
        """, (
            business_id, 
            legacy_api_key, 
            internal_api_key, 
            owner_id, 
            business_name, 
            business_description, 
            address, 
            phone_number, 
            website
        ))
        result = cursor.fetchone()
        conn.commit()
        log.info(f"Business created successfully: {business_id}")
        return jsonify({
            "message": "Business created successfully",
            "business_id": result[0],
            "internal_api_key": result[1] 
        }), 201

    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error creating business: {str(e)}", exc_info=True)
        # Check for unique constraint violation (e.g., duplicate name)
        if "unique constraint" in str(e).lower():
            return jsonify({"error_code": "CONFLICT", "message": "Business name already exists"}), 409
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

================================================================================
File: business_management.py
Path: .\backend\routes\business_management.py
Size: 8433
Modified: 2025-05-02T10:52:20.039868
Created: 2025-03-31T17:53:17.303133
Hash: a5327b40ca1c48377e184b631611601280f9a14e5722dfbaa3cdd93312925a92
Lines: 216
================================================================================
# backend/routes/business_management.py
from flask import jsonify, request, Blueprint
import uuid
import logging
from jsonschema import validate, ValidationError
from db import get_db_connection, release_db_connection
from auth import require_api_key

log = logging.getLogger(__name__)

# Create a Blueprint
bp = Blueprint('business_management', __name__, url_prefix='/businesses')

business_schema = {
    "type": "object",
    "properties": {
        "owner_id": {"type": "string", "format": "uuid"},
        "business_name": {"type": "string"},
        "business_description": {"type": "string"},
        "address": {"type": "string"},
        "phone_number": {"type": "string"},
        "website": {"type": "string", "format": "uri"}
    },
    "required": ["owner_id", "business_name"]
}

def create_business_route(request, get_db_connection):
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400

    data = request.get_json()
    try:
        validate(data, business_schema)
    except ValidationError as e:
        return jsonify({"error_code": "INVALID_REQUEST", "message": "Invalid request format", "details": str(e)}), 400

    business_id = str(uuid.uuid4())
    api_key = str(uuid.uuid4())
    conn = get_db_connection()
    try:
        c = conn.cursor()
        c.execute(
            """
            INSERT INTO businesses (business_id, api_key, owner_id, business_name, business_description, address, phone_number, website)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s);
            """,
            (
                business_id, api_key, data["owner_id"], data["business_name"],
                data.get("business_description", ""), data.get("address", ""),
                data.get("phone_number", ""), data.get("website", "")
            )
        )
        conn.commit()
        log.info({"message": "Business created", "business_id": business_id})
        return jsonify({"business_id": business_id, "api_key": api_key}), 201
    except Exception as e:
        conn.rollback()
        log.error(f"Error in create_business: {str(e)}")
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        release_db_connection(conn)

# Register the route directly with the Blueprint
@bp.route('/', methods=['POST'])
@require_api_key
def create_business():
    return create_business_route(request, get_db_connection)

@bp.route('/validate-credentials', methods=['GET', 'POST'])
def validate_credentials():
    # Get business_id either from query params (GET) or JSON body (POST)
    business_id = None
    api_key = None
    
    if request.method == 'POST' and request.is_json:
        # Get data from JSON body for POST requests
        data = request.get_json()
        business_id = data.get('business_id')
        api_key = data.get('api_key')
        log.info("Validating credentials from POST JSON body")
    else:
        # For GET requests, get from query params
        business_id = request.args.get('business_id')
        log.info("Validating credentials from GET query params")
    
    # Try to get API key from different sources if not in JSON body
    if not api_key:
        # 1. Try X-API-Key header first (most explicit)
        if 'X-API-Key' in request.headers:
            api_key = request.headers.get('X-API-Key')
            log.info("Using API key from X-API-Key header")
        
        # 2. Try Authorization header
        elif 'Authorization' in request.headers:
            auth_header = request.headers.get('Authorization')
            if auth_header.startswith('Bearer '):
                api_key = auth_header.split(' ', 1)[1]
                log.info("Using API key from Authorization Bearer header")
            else:
                api_key = auth_header
                log.info("Using API key from Authorization header")
        
        # 3. Try custom businessapikey header (used by client)
        elif 'businessapikey' in request.headers:
            api_key = request.headers.get('businessapikey')
            log.info("Using API key from businessapikey header")
        
        # 4. Try API key as query parameter
        elif 'api_key' in request.args:
            api_key = request.args.get('api_key')
            log.info("Using API key from query parameter")
        
        # 5. Try API key from cookie
        elif 'businessApiKey' in request.cookies:
            api_key = request.cookies.get('businessApiKey')
            log.info("Using API key from cookie")
    
    if not business_id or not api_key:
        missing = []
        if not business_id:
            missing.append("business_id")
        if not api_key:
            missing.append("API key")
        
        log.warning(f"Missing required parameters: {', '.join(missing)}")
        return jsonify({"error": f"Business ID and API key are required. Missing: {', '.join(missing)}"}), 400
    
    conn = get_db_connection()
    try:
        c = conn.cursor()
        c.execute(
            """
            SELECT business_id, api_key 
            FROM businesses 
            WHERE business_id = %s AND api_key = %s;
            """,
            (business_id, api_key)
        )
        result = c.fetchone()
        
        if result:
            log.info(f"Credentials validated successfully for business_id: {business_id}")
            # Return format compatible with both old and new frontend code
            return jsonify({
                "status": "success", 
                "message": "Credentials are valid", 
                "valid": True
            }), 200
        else:
            log.warning(f"Invalid credentials for business_id: {business_id}")
            return jsonify({
                "status": "error", 
                "message": "Invalid business ID or API key", 
                "valid": False
            }), 401
            
    except Exception as e:
        log.error(f"Error validating credentials: {str(e)}")
        return jsonify({"status": "error", "message": "Internal server error", "valid": False}), 500
    finally:
        release_db_connection(conn)

default_stage_schema = {
    "type": "object",
    "properties": {
        "stage_id": {"type": ["string", "null"], "format": "uuid"}
    },
    "required": ["stage_id"]
}

@bp.route('/<uuid:business_id>/default-stage', methods=['PUT'])
@require_api_key
def set_default_stage(business_id):
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400

    data = request.get_json()
    try:
        validate(data, default_stage_schema)
    except ValidationError as e:
        return jsonify({"error_code": "INVALID_REQUEST", "message": "Invalid request format", "details": str(e)}), 400

    stage_id = data.get('stage_id')

    conn = get_db_connection()
    try:
        c = conn.cursor()
        
        # Convert business_id (UUID object from URL) to string for querying
        business_id_str = str(business_id)
        
        # If stage_id is provided, verify it belongs to the business
        if stage_id:
            # Use business_id_str in the query parameters
            c.execute("SELECT 1 FROM stages WHERE stage_id = %s AND business_id = %s", (stage_id, business_id_str))
            if not c.fetchone():
                 return jsonify({"error_code": "NOT_FOUND", "message": "Specified stage_id does not exist or belong to this business"}), 404

        # Update the business record
        # Use business_id_str in the query parameters
        c.execute(
            "UPDATE businesses SET first_stage_id = %s WHERE business_id = %s",
            (stage_id, business_id_str) 
        )
        conn.commit()
        # Log the string version for consistency
        log.info({"message": "Default stage updated", "business_id": business_id_str, "first_stage_id": stage_id})
        return jsonify({"success": True, "message": "Default stage updated successfully"}), 200
    except Exception as e:
        conn.rollback()
        log.error(f"Error in set_default_stage: {str(e)}")
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        release_db_connection(conn)

# NO register_business_routes function anymore!

================================================================================
File: check_routes.py
Path: .\backend\routes\check_routes.py
Size: 679
Modified: 2025-05-02T10:52:20.056327
Created: 2025-03-31T17:53:17.322093
Hash: 5a0078cf71260b9017c36a88d1081843444774067eb52d67fe644ab4e08c9e67
Lines: 21
================================================================================
from app import create_app
from flask import url_for

app = create_app()

def check_routes():
    with app.test_request_context():
        print("\n=== Route Details ===")
        for rule in app.url_map.iter_rules():
            print(f"\nRoute: {rule}")
            print(f"Endpoint: {rule.endpoint}")
            print(f"Methods: {', '.join(rule.methods)}")
            try:
                print(f"URL: {url_for(rule.endpoint)}")
            except:
                print("URL: Requires parameters")
        print("\n=== Route Count ===")
        print(f"Total routes: {len(list(app.url_map.iter_rules()))}")

if __name__ == '__main__':
    check_routes()

================================================================================
File: configuration.py
Path: .\backend\routes\configuration.py
Size: 8028
Modified: 2025-05-02T10:52:20.056327
Created: 2025-04-09T09:53:16.470397
Hash: 83be6f37eaccc976542046315e8b1ec0f0b1548486aab5aa9f295dd18b558154
Lines: 208
================================================================================
"""
Configuration routes module.

This module provides endpoints for system and user configuration management.
"""

from flask import Blueprint, jsonify, request, g
import logging
from backend.db import get_db_connection, release_db_connection
from backend.auth import require_api_key, require_internal_key

log = logging.getLogger(__name__)

# Create blueprint for config endpoints
bp = Blueprint('config', __name__, url_prefix='/config')

@bp.route('/system', methods=['GET'])
@require_api_key
def get_system_config():
    """Get the current system configuration."""
    # This would typically fetch configuration from database or config files
    # For now, return a simple mock configuration
    return jsonify({
        "version": "1.0.0",
        "environment": "development",
        "features": {
            "message_handling": True,
            "conversation_history": True,
            "templates": True,
            "stages": True
        },
        "limits": {
            "max_messages_per_conversation": 100,
            "max_conversations_per_user": 10,
            "max_message_length": 4000
        }
    }), 200

@bp.route('/business/<business_id_param>', methods=['GET'])
@require_internal_key
def get_business_config(business_id_param):
    """
    Get configuration for the authenticated business.
    Assumes business context (g.business_id) is set by the decorator.
    Verifies path parameter matches authenticated business.
    """
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id_auth = g.business_id

    # Verify path param matches authenticated business ID
    if business_id_auth != business_id_param:
        log.warning(f"Auth mismatch: Internal key for {business_id_auth}, path asks for {business_id_param}")
        return jsonify({"error_code": "FORBIDDEN", "message": "Access denied to requested business configuration"}), 403

    log.info(f"Fetching configuration for business {business_id_auth}")
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            # Query using authenticated business_id
            cursor.execute(
                "SELECT business_name FROM businesses WHERE business_id = %s",
                (business_id_auth,)
            )
            
            business = cursor.fetchone()
            # The decorator already validated the key, so business should exist
            if not business:
                 log.error(f"Business {business_id_auth} passed auth but not found in DB during config fetch.")
                 return jsonify({"error": "Business consistency error"}), 500
            
            # Fetch business configuration from database (using mock for now)
            return jsonify({
                "business_id": business_id_auth,
                "business_name": business[0],
                "settings": {
                    "default_stage_id": "00000000-0000-0000-0000-000000000001", # Placeholder
                    "enable_history": True,
                    "message_retention_days": 30,
                    "enable_analytics": False
                },
                "features": {
                    "custom_templates": True,
                    "multiple_stages": True,
                    "conversation_management": True
                }
            }), 200
    
    except Exception as e:
        log.error(f"Error retrieving config for business {business_id_auth}: {str(e)}", exc_info=True)
        return jsonify({"error": f"Failed to retrieve configuration: {str(e)}"}), 500
    
    finally:
        if conn:
            release_db_connection(conn)

@bp.route('/business/<business_id_param>', methods=['PUT'])
@require_internal_key
def update_business_config(business_id_param):
    """
    Update configuration for the authenticated business.
    Assumes business context (g.business_id) is set by the decorator.
    Verifies path parameter matches authenticated business.
    """
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id_auth = g.business_id

    # Verify path param matches authenticated business ID
    if business_id_auth != business_id_param:
        log.warning(f"Auth mismatch: Internal key for {business_id_auth}, path asks for update on {business_id_param}")
        return jsonify({"error_code": "FORBIDDEN", "message": "Access denied to update requested business configuration"}), 403

    data = request.get_json()
    if not data:
        return jsonify({"error": "Request must be JSON"}), 400
    
    settings = data.get('settings', {})
    features = data.get('features', {})
    
    log.info(f"Updating configuration for business {business_id_auth}")
    # Placeholder - Validate and update config in DB here
    return jsonify({
        "message": "Business configuration updated successfully",
        "business_id": business_id_auth,
        "updated_settings": settings, # Echo back received data
        "updated_features": features
    }), 200

@bp.route('/validate', methods=['POST'])
@require_api_key
def validate_config():
    """
    Validate the provided configuration.
    
    Request body should contain:
    - userId: The user ID
    - businessId: The business ID
    - businessApiKey: The business API key
    """
    data = request.get_json()
    if not data:
        return jsonify({"error": "Request must be JSON"}), 400
    
    user_id = data.get('userId')
    business_id = data.get('businessId')
    business_api_key = data.get('businessApiKey')
    
    if not all([user_id, business_id, business_api_key]):
        missing = []
        if not user_id:
            missing.append('userId')
        if not business_id:
            missing.append('businessId')
        if not business_api_key:
            missing.append('businessApiKey')
            
        return jsonify({
            "isValid": False, 
            "error": f"Missing parameters: {', '.join(missing)}"
        }), 400
    
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            # Validate business credentials
            cursor.execute(
                "SELECT 1 FROM businesses WHERE business_id = %s AND api_key = %s",
                (business_id, business_api_key)
            )
            business_valid = cursor.fetchone() is not None
            
            # Validate user exists
            cursor.execute(
                "SELECT 1 FROM users WHERE user_id = %s",
                (user_id,)
            )
            user_valid = cursor.fetchone() is not None
            
            is_valid = business_valid and user_valid
            
            if is_valid:
                return jsonify({"isValid": True}), 200
            else:
                error_msg = 'Invalid configuration: '
                if not business_valid:
                    error_msg += 'Invalid business credentials, '
                if not user_valid:
                    error_msg += 'Invalid user, '
                    
                return jsonify({
                    "isValid": False, 
                    "error": error_msg.strip().rstrip(',')
                }), 401
    
    except Exception as e:
        log.error(f"Error validating configuration: {str(e)}", exc_info=True)
        return jsonify({"isValid": False, "error": str(e)}), 500
    
    finally:
        if conn:
            release_db_connection(conn)

================================================================================
File: conversations.py
Path: .\backend\routes\conversations.py
Size: 2685
Modified: 2025-05-02T10:52:20.064330
Created: 2025-03-31T17:53:17.337052
Hash: 21f17188cb06f2c397fc19393bf37d6ff50c8097d07b08c4c32eed626a224cf3
Lines: 73
================================================================================
from flask import Blueprint, request, jsonify, g
import logging
from backend.db import get_db_connection, release_db_connection
from backend.auth import require_internal_key

# Set up logging
log = logging.getLogger(__name__)

# Create blueprint
bp = Blueprint('conversations', __name__, url_prefix='/api/conversations')

@bp.route('', methods=['GET'])
@require_internal_key
def get_conversations():
    # Get business_id from context
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Fetching conversations for business {business_id}")

    # Optional filters (e.g., user_id, status)
    user_id = request.args.get('user_id')
    status = request.args.get('status')
    limit = request.args.get('limit', default=100, type=int)
    offset = request.args.get('offset', default=0, type=int)

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        query = """
            SELECT conversation_id, user_id, agent_id, stage_id, session_id, 
                   start_time, last_updated, status 
            FROM conversations 
            WHERE business_id = %s 
        """
        params = [business_id]

        if user_id:
            query += " AND user_id = %s"
            params.append(user_id)
        if status:
            query += " AND status = %s"
            params.append(status)
        
        query += " ORDER BY last_updated DESC LIMIT %s OFFSET %s"
        params.extend([limit, offset])

        cursor.execute(query, tuple(params))
        rows = cursor.fetchall()

        conversations_list = [
            {
                "conversation_id": str(row[0]),
                "user_id": str(row[1]),
                "agent_id": str(row[2]) if row[2] else None,
                "stage_id": str(row[3]) if row[3] else None,
                "session_id": row[4],
                "start_time": row[5].isoformat() if row[5] else None,
                "last_updated": row[6].isoformat() if row[6] else None,
                "status": row[7]
            } for row in rows
        ]
        return jsonify(conversations_list), 200

    except Exception as e:
        log.error(f"Error fetching conversations for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

================================================================================
File: conversation_management.py
Path: .\backend\routes\conversation_management.py
Size: 27453
Modified: 2025-05-10T18:29:15.802949
Created: 2025-04-09T09:52:25.246638
Hash: 0215717d1cc52a63584b1c747e1d4952117d6057cd3bea1e17dc3d1c2c34efb5
Lines: 597
================================================================================
"""
Conversation management module.

This module provides endpoints for managing conversations, including
retrieving conversation history, updating conversation data, and
managing conversation state. It also includes the primary endpoint
for processing incoming messages via the API.
"""

from flask import Blueprint, jsonify, request, g
import logging
import uuid
import json # Added for parsing message data
from backend.db import get_db_connection, release_db_connection, get_db_pool # Added get_db_pool
from backend.auth import require_internal_key, require_api_key
from psycopg2.extras import RealDictCursor
from backend.message_processing.message_handler import MessageHandler # Import MessageHandler
from backend.message_processing.ai_control_service import ai_control_service # Import AI control service
from backend.utils import is_valid_uuid # Import utility
from datetime import timedelta

log = logging.getLogger(__name__)

# Create blueprint for conversation endpoints - REMOVED url_prefix
conversation_bp = Blueprint('conversations', __name__)

# Remove the test route
# @conversation_bp.route('/test', methods=['GET'])
# def test_route():
#     return jsonify({"message": "Conversation blueprint test route OK"}), 200

@conversation_bp.route('', methods=['GET', 'OPTIONS'])
@require_api_key
def get_conversations():
    """
    Get all conversations, requires admin key.
    Optionally filter by business_id query parameter.
    """
    # Handle CORS preflight requests
    if request.method == 'OPTIONS':
        response = jsonify({'success': True})
        response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey,Accept')
        response.headers.add('Access-Control-Allow-Methods', 'GET,OPTIONS')
        response.headers.add('Access-Control-Allow-Credentials', 'true')
        return response

    # Get optional business_id filter from query parameter
    business_id_filter = request.args.get('business_id')
    if business_id_filter and not is_valid_uuid(business_id_filter):
         return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format in query parameter"}), 400
    
    log_msg = "Fetching all conversations (admin)"
    if business_id_filter:
        log_msg += f" filtered by business_id={business_id_filter}"
    log.info(log_msg)
    
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=RealDictCursor) as cursor:
            
            params = []
            base_query = """
                SELECT 
                    c.conversation_id, 
                    c.business_id, 
                    c.user_id, 
                    c.session_id, 
                    c.start_time, 
                    c.last_updated, 
                    c.stage_id,
                    u.first_name,
                    u.last_name,
                    COALESCE(
                        (
                            SELECT json_agg(
                                json_build_object(
                                    'message_id', m.message_id,
                                    'content', m.message_content,
                                    'message_content', m.message_content,
                                    'sender_type', m.sender_type,
                                    'timestamp', m.created_at,
                                    'is_from_agent', CASE WHEN m.sender_type = 'assistant' THEN true ELSE false END
                                ) ORDER BY m.created_at ASC
                            )
                            FROM messages m
                            WHERE m.conversation_id = c.conversation_id
                        ),
                        '[]'::json
                    ) as messages
                FROM conversations c
                LEFT JOIN users u ON c.user_id = u.user_id
            """
            
            where_clauses = []
            if business_id_filter:
                where_clauses.append("c.business_id = %s")
                params.append(business_id_filter)
                
            if where_clauses:
                query = base_query + " WHERE " + " AND ".join(where_clauses)
            else:
                query = base_query
                
            query += " GROUP BY c.conversation_id, c.business_id, c.user_id, c.session_id, c.start_time, c.last_updated, c.stage_id, u.first_name, u.last_name"
            query += " ORDER BY c.last_updated DESC;"
            
            cursor.execute(query, tuple(params))
            
            conversations = cursor.fetchall()
            
            # If no conversations found, return empty list
            if not conversations:
                response = jsonify([])
                response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
                response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey,Accept')
                response.headers.add('Access-Control-Allow-Methods', 'GET,OPTIONS')
                response.headers.add('Access-Control-Allow-Credentials', 'true')
                return response, 200
            
            # Process conversations and messages
            for conv in conversations:
                conv['conversation_id'] = str(conv['conversation_id'])
                conv['business_id'] = str(conv['business_id'])
                conv['user_id'] = str(conv['user_id'])
                conv['user_name'] = f"{conv.get('first_name', '')} {conv.get('last_name', '')}".strip()
                if conv['session_id']:
                    conv['session_id'] = str(conv['session_id'])
                if conv['stage_id']:
                    conv['stage_id'] = str(conv['stage_id'])
                conv['start_time'] = conv['start_time'].isoformat() if conv['start_time'] else None
                conv['last_updated'] = conv['last_updated'].isoformat() if conv['last_updated'] else None
                
                # Process messages
                messages = conv.get('messages', [])
                if messages and messages[0] is not None:  # Check if there are any messages
                    for msg in messages:
                        msg['message_id'] = str(msg['message_id'])
                        # Only call isoformat if timestamp is a datetime object
                        if msg['timestamp'] and not isinstance(msg['timestamp'], str):
                            msg['timestamp'] = msg['timestamp'].isoformat()
                else:
                    conv['messages'] = []
                
                # Add message summary
                if messages and messages[0] is not None:
                    user_messages = [msg for msg in messages if not msg['is_from_agent']]
                    agent_messages = [msg for msg in messages if msg['is_from_agent']]
                    
                    conv['message_summary'] = {
                        'total_messages': len(messages),
                        'user_messages': len(user_messages),
                        'agent_messages': len(agent_messages),
                        'last_user_message': user_messages[-1]['message_content'] if user_messages else None,
                        'last_agent_message': agent_messages[-1]['message_content'] if agent_messages else None,
                        'last_message_time': messages[-1]['timestamp'] if messages else None
                    }
                else:
                    conv['message_summary'] = {
                        'total_messages': 0,
                        'user_messages': 0,
                        'agent_messages': 0,
                        'last_user_message': None,
                        'last_agent_message': None,
                        'last_message_time': None
                    }
            
            response = jsonify(conversations)
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey,Accept')
            response.headers.add('Access-Control-Allow-Methods', 'GET,OPTIONS')
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            return response, 200
    
    except Exception as e:
        log.error(f"Error retrieving conversations: {str(e)}", exc_info=True)
        return jsonify({"error": f"Failed to retrieve conversations: {str(e)}"}), 500
    
    finally:
        if conn:
            release_db_connection(conn)

@conversation_bp.route('/<uuid:conversation_id>', methods=['DELETE', 'OPTIONS'])
@require_internal_key
def delete_conversation(conversation_id):
    """
    Delete a conversation and all associated messages.
    Assumes business context (g.business_id) is set by the decorator.
    """
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Attempting to delete conversation {conversation_id} for business {business_id}")
    
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            # Verify conversation belongs to business using context business_id
            cursor.execute("""
                SELECT 1 FROM conversations 
                WHERE conversation_id = %s AND business_id = %s
            """, (conversation_id, business_id))
            
            if not cursor.fetchone():
                log.warning(f"Conversation {conversation_id} not found or not authorized for business {business_id}")
                return jsonify({"error": "Conversation not found or not authorized"}), 404
            
            # Delete messages first
            cursor.execute("DELETE FROM messages WHERE conversation_id = %s", (conversation_id,))
            message_count = cursor.rowcount
            log.info(f"Deleted {message_count} messages for conversation {conversation_id}")
            
            # Then delete the conversation
            cursor.execute("DELETE FROM conversations WHERE conversation_id = %s", (conversation_id,))
            
            conn.commit()
            log.info(f"Deleted conversation {conversation_id} for business {business_id}")
            
            return jsonify({
                "message": f"Conversation deleted successfully with {message_count} messages",
                "conversation_id": str(conversation_id) # Return string UUID
            }), 200
    
    except Exception as e:
        if conn:
            conn.rollback()
        log.error(f"Error deleting conversation {conversation_id} for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error": f"Failed to delete conversation: {str(e)}"}), 500
    
    finally:
        if conn:
            release_db_connection(conn)

@conversation_bp.route('/reassign', methods=['POST', 'OPTIONS'])
@require_internal_key
def reassign_conversations():
    """
    Reassign conversations from one stage to another.
    Assumes business context (g.business_id) is set by the decorator.
    """
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id

    data = request.get_json()
    if not data:
         return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400
    
    source_stage_id = data.get('source_stage_id')
    target_stage_id = data.get('target_stage_id')
    
    if not source_stage_id or not target_stage_id:
        return jsonify({
            "error_code": "BAD_REQUEST", 
            "message": "Missing required fields: source_stage_id and target_stage_id are required"
        }), 400
    
    log.info(f"Attempting reassignment from stage {source_stage_id} to {target_stage_id} for business {business_id}")
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=RealDictCursor) as cursor:
            # Verify both stages belong to the business using context business_id
            cursor.execute("""
                SELECT stage_id FROM stages 
                WHERE stage_id IN (%s, %s) AND business_id = %s
            """, (source_stage_id, target_stage_id, business_id))
            
            found_stages = cursor.fetchall()
            if len(found_stages) != 2:
                log.warning(f"Stage verification failed for reassignment by business {business_id}. Stages found: {found_stages}")
                return jsonify({"error_code": "NOT_FOUND", "message": "One or both stages not found or not authorized"}), 404
                
            # Reassign conversations
            cursor.execute("""
                UPDATE conversations 
                SET stage_id = %s 
                WHERE stage_id = %s AND business_id = %s;
            """, (target_stage_id, source_stage_id, business_id))
            
            reassigned_count = cursor.rowcount
            conn.commit()
            log.info(f"Reassigned {reassigned_count} conversations from stage {source_stage_id} to {target_stage_id} for business {business_id}")
            
            return jsonify({
                "success": True,
                "message": f"Successfully reassigned {reassigned_count} conversations",
                "reassigned_count": reassigned_count
            }), 200

    except Exception as e:
        if conn:
            conn.rollback()
        log.error(f"Error reassigning conversations for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error": f"Failed to reassign conversations: {str(e)}"}), 500
    
    finally:
        if conn:
            release_db_connection(conn)

# --- New Route for Processing Messages ---
@conversation_bp.route('/message', methods=['POST', 'OPTIONS'])
@require_api_key # Use Admin API Key validation
def process_api_message():
    """
    Handles incoming messages sent directly via the API.
    Requires Admin API Key for authentication.
    Expects JSON body: { business_id: uuid, user_id: uuid, message: string }
    """
    # Handle CORS preflight requests
    if request.method == 'OPTIONS':
        response = jsonify({'success': True})
        response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey,Accept')
        response.headers.add('Access-Control-Allow-Methods', 'POST,OPTIONS')
        response.headers.add('Access-Control-Allow-Credentials', 'true')
        return response

    data = request.get_json()
    if not data:
        return jsonify({"error": "Request must be JSON"}), 400

    business_id = data.get('business_id')
    user_id = data.get('user_id')
    message_content = data.get('message')

    if not all([business_id, user_id, message_content]):
        missing = [k for k, v in {'business_id': business_id, 'user_id': user_id, 'message': message_content}.items() if not v]
        return jsonify({"error": f"Missing required fields: {', '.join(missing)}"}), 400

    if not is_valid_uuid(business_id) or not is_valid_uuid(user_id):
        return jsonify({"error": "Invalid UUID format for business_id or user_id"}), 400

    log.info(f"Processing API message for business {business_id} from user {user_id}")

    if not MessageHandler:
        log.error("MessageHandler class not found. Cannot process message.")
        return jsonify({"error": "Message processing component not available"}), 503 # Service Unavailable

    try:
        # Pass the actual db pool object to the handler
        db_pool = get_db_pool() # Call the function to get the pool
        if not db_pool:
            log.error("Failed to get database pool.")
            return jsonify({"error": "Database connection pool unavailable"}), 503
        
        message_handler = MessageHandler(db_pool) # Pass the pool object
        message_data = {
            'business_id': business_id,
            'user_id': user_id,
            'content': message_content,
            'platform': 'api' # Indicate the source is the direct API
        }
        
        # Process the message
        result = message_handler.process_message(message_data)
        
        # Log and return the result
        if result.get('success'):
            log.info(f"Successfully processed API message for business {business_id}. Log ID: {result.get('process_log_id')}")
            response = jsonify(result)
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            return response, 200
        else:
            log.error(f"MessageHandler failed for business {business_id}: {result.get('error')}")
            # Ensure a JSON response even on failure
            error_response = {
                "success": False,
                "error": result.get('error', 'Unknown processing error'),
                "process_log_id": result.get('process_log_id') # Include log ID if available
            }
            response = jsonify(error_response)
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            return response, 500 # Internal Server Error

    except Exception as e:
        log.error(f"Exception during API message processing for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error": "An unexpected error occurred during message processing"}), 500

# --- New Routes for Fetching Logs ---

@conversation_bp.route('/message/logs/recent', methods=['GET'])
@require_api_key
def get_recent_logs():
    """
    Get recent process logs, requires admin key.
    Requires 'business_id' query parameter.
    """
    business_id = request.args.get('business_id')
    limit = request.args.get('limit', 10, type=int)

    if not business_id:
        return jsonify({"error": "business_id query parameter is required"}), 400
    if not is_valid_uuid(business_id):
        return jsonify({"error": "Invalid business_id format"}), 400

    log.info(f"Fetching recent logs (limit {limit}) for business {business_id}")
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=RealDictCursor) as cursor:
            cursor.execute("""
                SELECT log_id, business_id, user_id, conversation_id, original_message, start_time
                FROM process_logs
                WHERE business_id = %s
                ORDER BY start_time DESC
                LIMIT %s;
            """, (business_id, limit))
            logs = cursor.fetchall()
            # Convert UUIDs and datetime to strings
            for log_entry in logs:
                for key, value in log_entry.items():
                    if isinstance(value, uuid.UUID):
                        log_entry[key] = str(value)
                    elif hasattr(value, 'isoformat'): # Check for datetime objects
                         log_entry[key] = value.isoformat()
            return jsonify(logs), 200
    except Exception as e:
        log.error(f"Error fetching recent logs for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error": "Failed to retrieve recent logs"}), 500
    finally:
        if conn:
            release_db_connection(conn)


@conversation_bp.route('/message/logs/<log_id>', methods=['GET'])
@require_api_key
def get_log_details(log_id):
    """
    Get detailed processing log by ID, requires admin key.
    Requires 'business_id' query parameter for authorization check.
    """
    business_id = request.args.get('business_id')

    if not business_id:
        return jsonify({"error": "business_id query parameter is required"}), 400
    if not is_valid_uuid(business_id):
         return jsonify({"error": "Invalid business_id format"}), 400
    if not is_valid_uuid(log_id): # Also validate log_id
        return jsonify({"error": "Invalid log_id format"}), 400

    log.info(f"Fetching log details for log_id {log_id} requested by business {business_id}")
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=RealDictCursor) as cursor:
            # Fetch the main log entry, ensuring it matches the business_id
            cursor.execute("""
                SELECT * FROM process_logs
                WHERE log_id = %s AND business_id = %s;
            """, (log_id, business_id))
            log_data = cursor.fetchone()

            if not log_data:
                log.warning(f"Log details for log_id {log_id} not found or not authorized for business {business_id}")
                return jsonify({"error": "Log not found or not authorized"}), 404

            # Fetch the processing steps associated with the log
            cursor.execute("""
                SELECT * FROM processing_steps
                WHERE log_id = %s
                ORDER BY timestamp ASC;
            """, (log_id,))
            steps = cursor.fetchall()

            # Combine log data and steps
            log_data['processing_steps'] = steps

            # Convert UUIDs and datetime objects to strings for JSON serialization
            def serialize_log_data(data):
                 if isinstance(data, dict):
                     return {k: serialize_log_data(v) for k, v in data.items()}
                 elif isinstance(data, list):
                     return [serialize_log_data(item) for item in data]
                 elif isinstance(data, uuid.UUID):
                     return str(data)
                 elif hasattr(data, 'isoformat'): # Check for datetime
                     return data.isoformat()
                 elif isinstance(data, bytes): # Handle potential bytea data (like context?)
                      try:
                          return json.loads(data.decode('utf-8')) # Try decoding as JSON
                      except (UnicodeDecodeError, json.JSONDecodeError):
                          return data.hex() # Fallback to hex representation
                 else:
                    return data

            serialized_log = serialize_log_data(log_data)
            
            # Attempt to parse JSON strings within the steps (like context, prompt, response)
            for step in serialized_log.get('processing_steps', []):
                 for field in ['context', 'prompt', 'response', 'system_prompt', 'extracted_data']:
                     if isinstance(step.get(field), str):
                         try:
                             # Try parsing if it looks like JSON
                             if step[field].strip().startswith('{') or step[field].strip().startswith('['):
                                 step[field] = json.loads(step[field])
                         except json.JSONDecodeError:
                             pass # Keep as string if not valid JSON

            return jsonify(serialized_log), 200

    except Exception as e:
        log.error(f"Error fetching log details for log_id {log_id}: {str(e)}", exc_info=True)
        return jsonify({"error": "Failed to retrieve log details"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@conversation_bp.route('/conversations/<uuid:conversation_id>/ai-control', methods=['GET', 'POST', 'OPTIONS'])
@require_api_key
def control_ai_responses(conversation_id):
    """
    Control AI responses for a conversation or user.
    
    Args:
        conversation_id: The ID of the conversation to control
        
    Request Body (for POST):
        action: 'stop' or 'resume'
        user_id: Optional user ID to control responses for all their conversations
        duration: Optional duration in hours for the stop (defaults to 24 hours)
    """
    # Handle CORS preflight requests
    if request.method == 'OPTIONS':
        response = jsonify({'success': True})
        response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey,Accept')
        response.headers.add('Access-Control-Allow-Methods', 'GET,POST,OPTIONS')
        response.headers.add('Access-Control-Allow-Credentials', 'true')
        return response

    try:
        if request.method == 'GET':
            # Return current status
            status = ai_control_service.get_stop_status(conversation_id)
            return jsonify({
                'success': True,
                'status': status
            })
        
        data = request.get_json()
        action = data.get('action')
        user_id = data.get('user_id')
        duration = data.get('duration')
        
        if action not in ['stop', 'resume']:
            return jsonify({
                'success': False,
                'error': 'Invalid action. Must be either "stop" or "resume"'
            }), 400
        
        if action == 'stop':
            # Convert duration to timedelta if provided
            duration_td = None
            if duration is not None:
                try:
                    duration_td = timedelta(hours=float(duration))
                except (ValueError, TypeError):
                    return jsonify({
                        'success': False,
                        'error': 'Invalid duration. Must be a number of hours.'
                    }), 400
            
            ai_control_service.stop_ai_responses(conversation_id, user_id, duration_td)
        else:
            ai_control_service.resume_ai_responses(conversation_id, user_id)
        
        # Get the current status
        status = ai_control_service.get_stop_status(conversation_id, user_id)
        
        return jsonify({
            'success': True,
            'message': f'AI responses {action}ed for {"user " + user_id if user_id else "conversation " + str(conversation_id)}',
            'status': status
        })
        
    except Exception as e:
        log.error(f"Error controlling AI responses: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

def is_valid_uuid(val): # Added helper function
    try:
        uuid.UUID(str(val))
        return True
    except ValueError:
        return False

================================================================================
File: conversation_summary.py
Path: .\backend\routes\conversation_summary.py
Size: 5759
Modified: 2025-05-02T10:52:20.080724
Created: 2025-04-14T14:06:39.142720
Hash: 615ca16247ff0cc167d810de1903a3001713b1373b54cdc307b57eb20954c29f
Lines: 171
================================================================================
"""
Routes for managing conversation summaries.
"""

from flask import Blueprint, jsonify, request
from db import get_db_connection, release_db_connection
from auth import require_business_api_key
from services.conversation_summary_service import ConversationSummaryService
import logging

log = logging.getLogger(__name__)

bp = Blueprint('conversation_summary', __name__)
summary_service = ConversationSummaryService()

@bp.route('/conversations/<conversation_id>/summary', methods=['GET'])
@require_business_api_key
def get_conversation_summary(conversation_id):
    """
    Get the summary for a specific conversation.
    
    Args:
        conversation_id: UUID of the conversation
        
    Returns:
        JSON response with the conversation summary
    """
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Get conversation data
        cursor.execute(
            """
            SELECT c.*, b.business_name, u.first_name, u.last_name
            FROM conversations c
            JOIN businesses b ON c.business_id = b.business_id
            JOIN users u ON c.user_id = u.user_id
            WHERE c.conversation_id = %s
            """,
            (conversation_id,)
        )
        conversation = cursor.fetchone()
        
        if not conversation:
            return jsonify({"error": "Conversation not found"}), 404
            
        # Get messages
        cursor.execute(
            """
            SELECT sender_type, message_content, created_at
            FROM messages
            WHERE conversation_id = %s
            ORDER BY created_at ASC
            """,
            (conversation_id,)
        )
        messages = cursor.fetchall()
        
        # Prepare conversation data
        conversation_data = {
            "business_name": conversation['business_name'],
            "user_name": f"{conversation['first_name']} {conversation['last_name']}",
            "conversation_id": str(conversation['conversation_id']),
            "start_time": conversation['start_time'].isoformat(),
            "last_updated": conversation['last_updated'].isoformat(),
            "conversation_history": [
                {
                    "sender": msg['sender_type'],
                    "content": msg['message_content'],
                    "timestamp": msg['created_at'].isoformat()
                }
                for msg in messages
            ]
        }
        
        # Generate summary
        summary = summary_service.generate_summary(conversation_data)
        
        # Save summary to database
        summary_service.save_summary(conn, conversation_id, summary)
        
        return jsonify(summary), 200
        
    except Exception as e:
        log.error(f"Error getting conversation summary: {str(e)}")
        return jsonify({"error": str(e)}), 500
        
    finally:
        if conn:
            release_db_connection(conn)

@bp.route('/conversations/<conversation_id>/summary', methods=['POST'])
@require_business_api_key
def generate_conversation_summary(conversation_id):
    """
    Generate and save a new summary for a conversation.
    
    Args:
        conversation_id: UUID of the conversation
        
    Returns:
        JSON response with the generated summary
    """
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Get conversation data
        cursor.execute(
            """
            SELECT c.*, b.business_name, u.first_name, u.last_name
            FROM conversations c
            JOIN businesses b ON c.business_id = b.business_id
            JOIN users u ON c.user_id = u.user_id
            WHERE c.conversation_id = %s
            """,
            (conversation_id,)
        )
        conversation = cursor.fetchone()
        
        if not conversation:
            return jsonify({"error": "Conversation not found"}), 404
            
        # Get messages
        cursor.execute(
            """
            SELECT sender_type, message_content, created_at
            FROM messages
            WHERE conversation_id = %s
            ORDER BY created_at ASC
            """,
            (conversation_id,)
        )
        messages = cursor.fetchall()
        
        # Prepare conversation data
        conversation_data = {
            "business_name": conversation['business_name'],
            "user_name": f"{conversation['first_name']} {conversation['last_name']}",
            "conversation_id": str(conversation['conversation_id']),
            "start_time": conversation['start_time'].isoformat(),
            "last_updated": conversation['last_updated'].isoformat(),
            "conversation_history": [
                {
                    "sender": msg['sender_type'],
                    "content": msg['message_content'],
                    "timestamp": msg['created_at'].isoformat()
                }
                for msg in messages
            ]
        }
        
        # Generate new summary
        summary = summary_service.generate_summary(conversation_data)
        
        # Save summary to database
        if summary_service.save_summary(conn, conversation_id, summary):
            return jsonify(summary), 200
        else:
            return jsonify({"error": "Failed to save summary"}), 500
        
    except Exception as e:
        log.error(f"Error generating conversation summary: {str(e)}")
        return jsonify({"error": str(e)}), 500
        
    finally:
        if conn:
            release_db_connection(conn)

================================================================================
File: dashboard.py
Path: .\backend\routes\dashboard.py
Size: 1734
Modified: 2025-05-03T23:25:06.419252
Created: 2025-05-03T19:48:54.254928
Hash: 6455cace2536153fe5eec5907bd94edf3d3191eb7e938b18bac200c8c2ee8565
Lines: 52
================================================================================
"""
Dashboard Routes

This module provides the web interface routes for the extraction dashboard.
"""

from flask import Blueprint, render_template, jsonify
from backend.monitoring.extraction_dashboard import ExtractionDashboard
from backend.db import get_db_pool

dashboard_bp = Blueprint('dashboard', __name__)

@dashboard_bp.route('/dashboard')
def dashboard():
    """Render the main dashboard page."""
    return render_template('enhanced_dashboard.html')

@dashboard_bp.route('/api/dashboard/overview')
def get_overview():
    """Get overview statistics."""
    dashboard = ExtractionDashboard(get_db_pool())
    return jsonify(dashboard.get_overview_stats())

@dashboard_bp.route('/api/dashboard/trends')
def get_trends():
    """Get performance trends."""
    dashboard = ExtractionDashboard(get_db_pool())
    return jsonify(dashboard.get_performance_trends())

@dashboard_bp.route('/api/dashboard/patterns')
def get_patterns():
    """Get pattern analysis."""
    dashboard = ExtractionDashboard(get_db_pool())
    return jsonify(dashboard.get_pattern_analysis())

@dashboard_bp.route('/api/dashboard/errors')
def get_errors():
    """Get error analysis."""
    dashboard = ExtractionDashboard(get_db_pool())
    return jsonify(dashboard.get_error_analysis())

@dashboard_bp.route('/api/dashboard/templates')
def get_templates():
    """Get template performance."""
    dashboard = ExtractionDashboard(get_db_pool())
    return jsonify(dashboard.get_template_performance())

@dashboard_bp.route('/api/dashboard/all')
def get_all_data():
    """Get all dashboard data."""
    dashboard = ExtractionDashboard(get_db_pool())
    return jsonify(dashboard.get_dashboard_data()) 

================================================================================
File: data_extraction.py
Path: .\backend\routes\data_extraction.py
Size: 12806
Modified: 2025-05-02T10:52:20.088873
Created: 2025-04-16T11:37:32.783767
Hash: c20a71b81e661cb8238551b3cb7ababe3d432b2eac32b471e7537e1c43d3ced7
Lines: 355
================================================================================
"""
API routes for data extraction functionality.

This module provides endpoints for accessing and managing extracted data.
"""

import logging
from flask import Blueprint, jsonify, request, g
from typing import Dict, Any, List, Optional
import traceback # For detailed error logging

from backend.db import get_db_connection, release_db_connection
from backend.message_processing.data_extraction_service import DataExtractionService
from backend.auth import require_internal_key

log = logging.getLogger(__name__)

# Create a Blueprint for data extraction routes
data_extraction_bp = Blueprint('data_extraction', __name__)

@data_extraction_bp.route('/api/v1/conversations/<conversation_id>/extracted_data', methods=['GET'])
@require_internal_key
def get_conversation_extracted_data(conversation_id: str):
    """
    Get all extracted data for a conversation.
    
    Args:
        conversation_id: ID of the conversation
        
    Returns:
        JSON response with extracted data
    """
    try:
        business_id = g.business_id
        user_id = g.user_id
        
        # Get query parameters
        data_type = request.args.get('data_type')
        limit = int(request.args.get('limit', 10))
        
        # Verify the conversation belongs to the business
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT conversation_id FROM conversations 
            WHERE conversation_id = %s AND business_id = %s
            """,
            (conversation_id, business_id)
        )
        
        if not cursor.fetchone():
            return jsonify({
                'success': False,
                'error': 'Conversation not found or access denied'
            }), 404
        
        # Create data extraction service
        from backend.db import get_db_pool
        db_pool = get_db_pool()
        data_extraction_service = DataExtractionService(db_pool)
        
        # Get extracted data
        extracted_data = data_extraction_service.get_extracted_data(
            conversation_id, data_type, limit
        )
        
        return jsonify({
            'success': True,
            'extracted_data': extracted_data
        })
        
    except Exception as e:
        log.error(f"Error retrieving extracted data: {str(e)}\n{traceback.format_exc()}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
    finally:
        if conn:
            conn.close()

@data_extraction_bp.route('/api/v1/extracted_data/<extraction_id>', methods=['GET'])
@require_internal_key
def get_extraction_by_id(extraction_id: str):
    """
    Get a specific extraction by ID.
    
    Args:
        extraction_id: ID of the extraction
        
    Returns:
        JSON response with extraction data
    """
    try:
        business_id = g.business_id
        
        # Verify the extraction belongs to a conversation of the business
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT ed.extraction_id, ed.stage_id, ed.data_type, 
                   ed.extracted_data, ed.created_at, s.stage_name,
                   c.conversation_id, c.business_id
            FROM extracted_data ed
            JOIN stages s ON ed.stage_id = s.stage_id
            JOIN conversations c ON ed.conversation_id = c.conversation_id
            WHERE ed.extraction_id = %s AND c.business_id = %s
            """,
            (extraction_id, business_id)
        )
        
        result = cursor.fetchone()
        if not result:
            return jsonify({
                'success': False,
                'error': 'Extraction not found or access denied'
            }), 404
        
        # Format the result
        extraction = {
            'extraction_id': result['extraction_id'],
            'conversation_id': result['conversation_id'],
            'stage_id': result['stage_id'],
            'stage_name': result['stage_name'],
            'data_type': result['data_type'],
            'data': result['extracted_data'],
            'created_at': result['created_at'].isoformat()
        }
        
        return jsonify({
            'success': True,
            'extraction': extraction
        })
        
    except Exception as e:
        log.error(f"Error retrieving extraction: {str(e)}\n{traceback.format_exc()}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
    finally:
        if conn:
            conn.close()

@data_extraction_bp.route('/api/v1/businesses/<business_id>/extraction_templates', methods=['GET'])
@require_internal_key
def get_extraction_templates(business_id: str):
    """
    Get all data extraction templates for a business.
    
    Args:
        business_id: ID of the business
        
    Returns:
        JSON response with extraction templates
    """
    try:
        # Verify the business ID matches the authenticated user
        if business_id != g.business_id:
            return jsonify({
                'success': False,
                'error': 'Access denied'
            }), 403
        
        # Get extraction templates
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT template_id, template_name, template_type, content, 
                   system_prompt, created_at, updated_at
            FROM templates
            WHERE business_id = %s AND template_type = 'data_extraction'
            ORDER BY template_name
            """,
            (business_id,)
        )
        
        templates = cursor.fetchall()
        
        # Format the results
        result = []
        for template in templates:
            result.append({
                'template_id': template['template_id'],
                'template_name': template['template_name'],
                'template_type': template['template_type'],
                'content': template['content'],
                'system_prompt': template['system_prompt'],
                'created_at': template['created_at'].isoformat(),
                'updated_at': template['updated_at'].isoformat() if template['updated_at'] else None
            })
        
        return jsonify({
            'success': True,
            'templates': result
        })
        
    except Exception as e:
        log.error(f"Error retrieving extraction templates: {str(e)}\n{traceback.format_exc()}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
    finally:
        if conn:
            conn.close()

@data_extraction_bp.route('/api/v1/businesses/<business_id>/extraction_templates', methods=['POST'])
@require_internal_key
def create_extraction_template(business_id: str):
    """
    Create a new data extraction template.
    
    Args:
        business_id: ID of the business
        
    Returns:
        JSON response with the created template
    """
    try:
        # Verify the business ID matches the authenticated user
        if business_id != g.business_id:
            return jsonify({
                'success': False,
                'error': 'Access denied'
            }), 403
        
        # Get template data from request
        data = request.json
        if not data:
            return jsonify({
                'success': False,
                'error': 'No data provided'
            }), 400
        
        # Validate required fields
        required_fields = ['template_name', 'content']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    'success': False,
                    'error': f'Missing required field: {field}'
                }), 400
        
        # Create the template
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT INTO templates 
            (template_id, business_id, template_name, template_type, content, system_prompt)
            VALUES (gen_random_uuid(), %s, %s, 'data_extraction', %s, %s)
            RETURNING template_id, template_name, template_type, content, 
                      system_prompt, created_at, updated_at
            """,
            (business_id, data['template_name'], data['content'], data.get('system_prompt', ''))
        )
        
        template = cursor.fetchone()
        conn.commit()
        
        # Format the result
        result = {
            'template_id': template['template_id'],
            'template_name': template['template_name'],
            'template_type': template['template_type'],
            'content': template['content'],
            'system_prompt': template['system_prompt'],
            'created_at': template['created_at'].isoformat(),
            'updated_at': template['updated_at'].isoformat() if template['updated_at'] else None
        }
        
        return jsonify({
            'success': True,
            'template': result
        }), 201
        
    except Exception as e:
        log.error(f"Error creating extraction template: {str(e)}\n{traceback.format_exc()}")
        if conn:
            conn.rollback()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
    finally:
        if conn:
            conn.close()

@data_extraction_bp.route('/api/extract', methods=['POST'])
@require_internal_key
def extract_data():
    if not hasattr(g, 'business_id'):
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Data extraction request for business {business_id}")

    data = request.get_json()
    if not data:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400

    template_id = data.get('template_id')
    text_content = data.get('text_content')
    # Optional: allow passing context variables for the template
    context_vars = data.get('context_variables', {})

    if not template_id or not text_content:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required fields: template_id and text_content"}), 400
    
    # TODO: Validate template_id format (is_valid_uuid?)

    conn = None
    try:
        # Fetch the template content AND verify it belongs to the business
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""SELECT content, system_prompt FROM templates 
                          WHERE template_id = %s AND business_id = %s 
                          AND template_type = 'data_extraction'""", 
                       (template_id, business_id))
        template_row = cursor.fetchone()

        if not template_row:
            log.warning(f"Data extraction template {template_id} not found or invalid type/access for business {business_id}")
            return jsonify({"error_code": "NOT_FOUND", "message": "Data extraction template not found or access denied"}), 404
        
        template_content = template_row[0]
        system_prompt = template_row[1]
        release_db_connection(conn) # Release connection before potentially long LLM call
        conn = None 

        # Placeholder for the actual extraction logic
        # This would likely involve formatting the prompt with text_content & context_vars,
        # then calling the LLM.
        log.info(f"TODO: Implement data extraction using template {template_id} for business {business_id}")
        # Example call:
        # extracted_data = extract_data_using_template(
        #     template_content=template_content, 
        #     system_prompt=system_prompt,
        #     text_content=text_content, 
        #     context_vars=context_vars
        # )
        extracted_data = {"placeholder": "extracted data would be here", "input_text": text_content[:50] + "..."}

        return jsonify({"success": True, "extracted_data": extracted_data}), 200

    except Exception as e:
        log.error(f"Error during data extraction for business {business_id}: {str(e)}\n{traceback.format_exc()}")
        return jsonify({"error_code": "EXTRACTION_FAILED", "message": "Failed to extract data"}), 500
    finally:
        if conn: # Ensure connection is released if error occurred before LLM call
            release_db_connection(conn)

================================================================================
File: debug.py
Path: .\backend\routes\debug.py
Size: 7231
Modified: 2025-05-02T10:52:20.097116
Created: 2025-04-08T22:37:16.515734
Hash: 3c6cccd4afc6f477fc914cb7a0cd0e8b892afe16cfff244ae3c805bce269f2cf
Lines: 197
================================================================================
from flask import Blueprint, jsonify, request, Response, stream_with_context
from backend.auth import require_api_key
import json
import time
from datetime import datetime

debug_bp = Blueprint('debug', __name__)

@debug_bp.route('/debug/conversation/<conversation_id>', methods=['GET'])
@require_api_key
def get_conversation_debug(conversation_id):
    """
    Get debug information for a specific conversation.
    This includes all prompts, responses, and stage transitions.
    """
    try:
        # TODO: Implement actual database queries to get the debug information
        # This is example data for now
        debug_data = {
            "stages": [
                {
                    "id": "stage1",
                    "name": "Initial Greeting",
                    "confidence": 0.95,
                    "current": False
                },
                {
                    "id": "stage2",
                    "name": "Order Status",
                    "confidence": 0.88,
                    "current": True
                }
            ],
            "stageSelection": {
                "prompt": "Based on the user's message 'What's the status of my order?', determine the appropriate stage...",
                "response": "Stage: Order Status (confidence: 0.88)"
            },
            "dataExtraction": {
                "prompt": "Extract any order-related information from the message...",
                "response": "No specific order ID mentioned in the query."
            },
            "extractedData": {
                "intent": "order_status_query",
                "entities": {},
                "confidence": 0.88
            },
            "responseGeneration": {
                "prompt": "Generate a response asking the user for their order ID...",
                "response": "I'd be happy to help you check your order status. Could you please provide your order ID?"
            }
        }
        return jsonify(debug_data)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@debug_bp.route('/debug/message/<message_id>', methods=['GET'])
@require_api_key
def get_message_debug(message_id):
    """
    Get debug information for a specific message processing instance.
    """
    try:
        # TODO: Implement actual message debug info retrieval
        debug_data = {
            "message_id": message_id,
            "timestamp": datetime.now().isoformat(),
            "processing_steps": [
                {
                    "step": "stage_selection",
                    "input": "What's the status of my order?",
                    "output": "Order Status stage selected",
                    "confidence": 0.88,
                    "processing_time": 0.45
                }
                # Add more steps as needed
            ]
        }
        return jsonify(debug_data)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@debug_bp.route('/debug/stages/<conversation_id>', methods=['GET'])
@require_api_key
def get_stage_navigation_debug(conversation_id):
    """
    Get stage navigation history for a conversation.
    """
    try:
        # TODO: Implement actual stage navigation history retrieval
        navigation_data = {
            "conversation_id": conversation_id,
            "stages": [
                {
                    "timestamp": "2024-04-08T10:00:00Z",
                    "from_stage": "Initial Greeting",
                    "to_stage": "Order Status",
                    "confidence": 0.88,
                    "trigger": "user_message"
                }
                # Add more stage transitions as needed
            ]
        }
        return jsonify(navigation_data)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@debug_bp.route('/debug/prompts/<message_id>', methods=['GET'])
@require_api_key
def get_prompt_generation_debug(message_id):
    """
    Get prompt generation details for a message.
    """
    try:
        # TODO: Implement actual prompt generation debug info retrieval
        prompt_data = {
            "message_id": message_id,
            "prompts": [
                {
                    "type": "stage_selection",
                    "template": "Based on the conversation history and available stages...",
                    "variables": {
                        "user_message": "What's the status of my order?",
                        "conversation_history": []
                    },
                    "final_prompt": "Complete prompt text here..."
                }
                # Add more prompts as needed
            ]
        }
        return jsonify(prompt_data)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@debug_bp.route('/debug/extraction/<message_id>', methods=['GET'])
@require_api_key
def get_data_extraction_debug(message_id):
    """
    Get data extraction results for a message.
    """
    try:
        # TODO: Implement actual data extraction debug info retrieval
        extraction_data = {
            "message_id": message_id,
            "extracted_data": {
                "intent": "order_status_query",
                "entities": {},
                "confidence": 0.88
            },
            "extraction_process": {
                "template_used": "data_extraction_template_1",
                "processing_time": 0.35,
                "confidence_scores": {
                    "intent": 0.88,
                    "entities": {}
                }
            }
        }
        return jsonify(extraction_data)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@debug_bp.route('/debug/events/<conversation_id>')
@require_api_key
def debug_events(conversation_id):
    """
    Stream debug events for a conversation using Server-Sent Events (SSE).
    """
    def generate():
        try:
            # TODO: Implement actual event streaming
            # This is just an example that sends a few events
            events = [
                {"timestamp": datetime.now().isoformat(), "message": "Processing started"},
                {"timestamp": datetime.now().isoformat(), "message": "Stage selection completed"},
                {"timestamp": datetime.now().isoformat(), "message": "Data extraction completed"},
                {"timestamp": datetime.now().isoformat(), "message": "Response generation completed"}
            ]
            
            for event in events:
                data = json.dumps(event)
                yield f"data: {data}\n\n"
                time.sleep(1)  # Simulate time between events
                
        except GeneratorExit:
            # Client disconnected
            pass
        except Exception as e:
            yield f"data: {json.dumps({'error': str(e)})}\n\n"

    return Response(
        stream_with_context(generate()),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        }
    )

================================================================================
File: health.py
Path: .\backend\routes\health.py
Size: 326
Modified: 2025-05-02T10:52:20.105389
Created: 2025-03-31T17:53:17.348028
Hash: e55e23384af76a8630f4e705ba72fe12aed3b34fb5113d4e5cbb336eb9159b37
Lines: 11
================================================================================
from flask import Blueprint, request, jsonify, current_app
import logging

log = logging.getLogger(__name__)

bp = Blueprint('health', __name__, url_prefix='/health')

@bp.route('/', methods=['GET'])
def health_check():
    print("--- Inside /health route handler ---")
    return jsonify({"status": "healthy"}), 200

================================================================================
File: llm.py
Path: .\backend\routes\llm.py
Size: 11083
Modified: 2025-05-02T10:52:20.105389
Created: 2025-04-12T23:52:12.460151
Hash: 8758c76cd5c9a2b06064f78e3ecad533527ae49a21a1fc739489eed3c6825fa4
Lines: 245
================================================================================
from flask import Blueprint, jsonify, request, current_app, g
import logging
import json
import uuid
from datetime import datetime
from backend.db import get_db_connection, release_db_connection
from backend.auth import require_internal_key
from backend.openai_helper import call_openai

log = logging.getLogger(__name__)

# Create a blueprint for LLM routes
llm_bp = Blueprint('llm', __name__, url_prefix='/api/llm')

@llm_bp.route('/generate', methods=['POST', 'OPTIONS'])
@require_internal_key
def generate_llm_response():
    """Generate a response using the call_openai function."""
    if request.method == 'OPTIONS':
        return jsonify(success=True), 200
    
    if not hasattr(g, 'business_id'):
        log.error("Business context missing in generate_llm_response")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id

    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Request must be JSON'}), 400

    input_text = data.get('input_text')
    system_prompt = data.get('system_prompt', '') # System prompt might not be directly used by call_openai
    conversation_id = data.get('conversation_id') # Not used by call_openai
    agent_id = data.get('agent_id') # Not used by call_openai
    call_type = data.get('call_type', 'general') # Not used by call_openai
    
    if not input_text:
        log.error(f"Missing input_text for business {business_id}")
        return jsonify({'success': False, 'error': 'Missing input_text parameter'}), 400
    
    log.info(f"Generating LLM response via call_openai for business {business_id}")
    # Prepare the prompt for call_openai. 
    # NOTE: call_openai in helper only takes a single prompt string.
    # We might need a more sophisticated helper or combine prompts here.
    # For now, just pass input_text. System prompt is ignored by call_openai.
    final_prompt = input_text 
    if system_prompt: 
        log.warning(f"System prompt provided but call_openai might not use it directly. Prompt: {system_prompt}")
        # How should system prompt be integrated? Prepend? Pass differently?
        # Example: final_prompt = f"{system_prompt}\n\nUser: {input_text}"

    # Generate a unique ID for logging/reference, though call_openai doesn't take it
    llm_call_id = str(uuid.uuid4())
    log.info(f"Generated LLM call ID: {llm_call_id}")

    try:
        # Call the actual function from the helper
        response_text = call_openai(final_prompt)
        
        # Check if response indicates an error (based on mock response structure)
        if "mock response" in response_text and ("API key not configured" in response_text or "API key format is invalid" in response_text or "call failed" in response_text):
             log.error(f"call_openai failed for business {business_id}: {response_text}")
             # Return a generic error, don't expose internal details like mock response structure
             return jsonify({'success': False, 'error': 'LLM call failed due to configuration or API error.'}), 500

        return jsonify({
            'success': True,
            'call_id': llm_call_id, # Return the generated ID
            'response': response_text,
            'timestamp': datetime.now().isoformat()
        })
            
    except Exception as e:
        log.error(f"Error calling call_openai for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@llm_bp.route('/calls/recent', methods=['GET', 'OPTIONS'])
@require_internal_key
def get_recent_llm_calls():
    """Get recent LLM calls for the authenticated business."""
    if request.method == 'OPTIONS':
        return jsonify(success=True), 200
    
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    
    limit = int(request.args.get('limit', 10))
    log.info(f"Fetching recent {limit} LLM calls for business {business_id}")
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Check table existence (optional but good practice)
        cursor.execute("SELECT to_regclass('public.llm_calls')")
        if cursor.fetchone()[0] is None:
            log.warning(f"llm_calls table not found for business {business_id}")
            return jsonify([])
        
        # Fetch recent calls using business_id from context
        cursor.execute(
            """
            SELECT call_id, business_id, input_text, response, system_prompt, call_type, timestamp
            FROM llm_calls
            WHERE business_id = %s
            ORDER BY timestamp DESC
            LIMIT %s;
            """, (business_id, limit)
        )
        
        calls = []
        columns = [desc[0] for desc in cursor.description] 
        for row in cursor.fetchall():
            call_data = dict(zip(columns, row))
            # Format dates and UUIDs
            call_data['call_id'] = str(call_data['call_id'])
            call_data['business_id'] = str(call_data['business_id'])
            call_data['timestamp'] = call_data['timestamp'].isoformat() if call_data['timestamp'] else None
            calls.append(call_data)
        
        return jsonify(calls)
        
    except Exception as e:
        log.error(f"Database error fetching recent calls for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@llm_bp.route('/calls/<call_id>', methods=['GET', 'OPTIONS'])
@require_internal_key
def get_llm_call_details(call_id):
    """Get details of a specific LLM call, ensuring it belongs to the authenticated business."""
    if request.method == 'OPTIONS':
        return jsonify(success=True), 200
    
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Fetching details for LLM call {call_id} for business {business_id}")

    # Validate call_id format (optional but recommended)
    try:
        uuid.UUID(call_id)
    except ValueError:
         return jsonify({'success': False, 'error': 'Invalid call_id format'}), 400
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Check table existence
        cursor.execute("SELECT to_regclass('public.llm_calls')")
        if cursor.fetchone()[0] is None:
             log.warning(f"llm_calls table not found when fetching details for call {call_id}")
             return jsonify({'success': False, 'error': 'LLM call data not available'}), 404
        
        # Fetch call details, ensuring it matches the business_id from context
        cursor.execute(
            """
            SELECT call_id, business_id, input_text, response, system_prompt, call_type, timestamp, 
                   agent_id, conversation_id, cost, duration, status, error_message
            FROM llm_calls
            WHERE call_id = %s AND business_id = %s;
            """, (call_id, business_id)
        )
        
        result = cursor.fetchone()
        if not result:
            log.warning(f"LLM Call {call_id} not found or not authorized for business {business_id}")
            return jsonify({'success': False, 'error': 'LLM call not found or access denied'}), 404
            
        columns = [desc[0] for desc in cursor.description]
        call_details = dict(zip(columns, result))
        
        # Format dates and UUIDs
        for key in ['call_id', 'business_id', 'agent_id', 'conversation_id']:
            if call_details.get(key):
                 call_details[key] = str(call_details[key])
        if call_details.get('timestamp'):
            call_details['timestamp'] = call_details['timestamp'].isoformat()
            
        return jsonify(call_details)
        
    except Exception as e:
        log.error(f"Database error fetching details for call {call_id}, business {business_id}: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@llm_bp.route('/call', methods=['POST'])
@require_internal_key
def handle_llm_call():
    """Handle an LLM call request using call_openai."""
    if not hasattr(g, 'business_id'):
        log.error("Business context missing in handle_llm_call")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    
    data = request.get_json()
    if not data:
         return jsonify({'success': False, 'error': 'Request must be JSON'}), 400

    input_text = data.get('prompt') # Use 'prompt' key from request
    system_prompt = data.get('system_prompt') # Not used by call_openai
    # Other params like conversation_id, agent_id, call_type are ignored by call_openai

    if not input_text:
        log.warning(f"Missing prompt for /call endpoint, business {business_id}")
        return jsonify({'success': False, 'error': 'Missing prompt parameter'}), 400

    log.info(f"Handling /call request via call_openai for business {business_id}")
    final_prompt = input_text # See note in /generate route about system prompt
    if system_prompt:
        log.warning(f"System prompt provided to /call but call_openai might not use it. Prompt: {system_prompt}")

    llm_call_id = str(uuid.uuid4())
    log.info(f"Generated LLM call ID for /call: {llm_call_id}")

    try:
        # Call the actual helper function
        response_text = call_openai(final_prompt)

        # Check for mock error response
        if "mock response" in response_text and ("API key not configured" in response_text or "API key format is invalid" in response_text or "call failed" in response_text):
             log.error(f"call_openai failed via /call for business {business_id}: {response_text}")
             return jsonify({'success': False, 'error': 'LLM call failed due to configuration or API error.'}), 500
        
        return jsonify({
            'success': True,
            'call_id': llm_call_id,
            'response': response_text
        })

    except Exception as e:
        log.error(f"Error in /call endpoint for business {business_id}: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

================================================================================
File: messages.py
Path: .\backend\routes\messages.py
Size: 254
Modified: 2025-05-02T10:52:20.121658
Created: 2025-03-31T17:53:17.369335
Hash: 6123992184250c70b644d88a3bbbaac34f9958c37a0243973bfd9fdb2ff8abf7
Lines: 8
================================================================================
# routes/messages.py
from flask import Blueprint, redirect, url_for

bp = Blueprint('messages', __name__)

@bp.route('/process', methods=['POST'])
def redirect_to_message():
    return redirect(url_for('message_handling.handle_message'), code=307)

================================================================================
File: message_handling.py
Path: .\backend\routes\message_handling.py
Size: 13047
Modified: 2025-05-05T00:38:15.695616
Created: 2025-03-31T17:53:17.358650
Hash: 9b14583f999d5813e2a8845224e20c54051d08eb3c716a1e302ce9a5b8eaedc4
Lines: 255
================================================================================
# backend/routes/message_handling.py
from flask import jsonify, request, Blueprint, current_app, make_response
import uuid
import logging
import json
from jsonschema import validate, ValidationError
from db import get_db_connection, release_db_connection, get_db_pool
from openai_helper import call_openai
from backend.auth import require_internal_key, require_api_key
import re
import hmac # For signature verification
import hashlib # For signature verification
import requests # For calling internal APIs
from backend.message_processing.message_handler import MessageHandler
from backend.routes.utils import is_valid_uuid

log = logging.getLogger(__name__)

bp = Blueprint('message_handling', __name__, url_prefix='/api')

# Attempt to import the main processing logic
try:
    from backend.message_processing.message_handler import MessageHandler
    # If MessageHandler uses the db pool directly, ensure it's initialized
    # from backend.db import initialize_db_pool, get_db_pool 
    # initialize_db_pool() # Ensure pool is initialized on app start
except ImportError:
    MessageHandler = None
    log.warning("MessageHandler class not found. Message processing logic is missing.")

def verify_facebook_signature(payload_body, signature_header):
    """Verify the request signature from Facebook."""
    if not signature_header:
        log.warning("Webhook signature header missing (X-Hub-Signature-256)")
        return False
    
    app_secret = current_app.config.get("FACEBOOK_APP_SECRET")
    if not app_secret:
        log.error("FACEBOOK_APP_SECRET not configured on the server.")
        return False # Cannot verify without the secret

    try:
        hash_method, signature_hash = signature_header.split('=', 1)
        if hash_method != 'sha256':
            log.warning(f"Unsupported webhook hash method: {hash_method}")
            return False
        
        expected_hash = hmac.new(
            app_secret.encode('utf-8'),
            payload_body, # Use the raw request body bytes
            hashlib.sha256
        ).hexdigest()

        if not hmac.compare_digest(expected_hash, signature_hash):
            log.warning("Webhook signature mismatch.")
            return False
        
        log.info("Webhook signature verified successfully.")
        return True
    except Exception as e:
        log.error(f"Error during webhook signature verification: {str(e)}", exc_info=True)
        return False

# Example endpoint for Facebook Messenger webhooks
@bp.route('/facebook', methods=['GET', 'POST'])
def facebook_webhook():
    # Handle verification challenge for Facebook
    if request.method == 'GET':
        verify_token = current_app.config.get("FACEBOOK_VERIFY_TOKEN", "DEFAULT_VERIFY_TOKEN") # Use a config var
        mode = request.args.get('hub.mode')
        token = request.args.get('hub.verify_token')
        challenge = request.args.get('hub.challenge')
        if mode == 'subscribe' and token == verify_token:
            log.info('Facebook Webhook verification successful!')
            return challenge, 200
        else:
            log.warning('Facebook Webhook verification failed.')
            return 'Verification token mismatch', 403

    # Handle incoming messages
    if request.method == 'POST':
        # 1. Verify Signature (CRITICAL)
        signature = request.headers.get('X-Hub-Signature-256')
        raw_body = request.get_data() # Get raw bytes for signature check
        if not verify_facebook_signature(raw_body, signature):
             return jsonify({"status": "error", "message": "Signature verification failed"}), 403
        
        # 2. Parse Payload
        try:
            data = json.loads(raw_body.decode('utf-8')) # Parse body AFTER verification
        except json.JSONDecodeError:
             log.error("Failed to decode webhook JSON payload")
             return jsonify({"status": "error", "message": "Invalid JSON payload"}), 400
        
        log.info(f"Received Facebook webhook payload: {json.dumps(data)}")

        # 3. Process each message entry (Facebook sends batches)
        if data.get("object") == "page":
            for entry in data.get("entry", []):
                for messaging_event in entry.get("messaging", []):
                    if messaging_event.get("message"):
                        sender_id = messaging_event["sender"]["id"] # Platform User ID
                        recipient_id = messaging_event["recipient"]["id"] # Your Page ID
                        message_text = messaging_event["message"].get("text")
                        # mid = messaging_event["message"].get("mid") # Message ID
                        
                        if message_text:
                            log.info(f"Processing message from {sender_id} to page {recipient_id}: '{message_text}'")
                            
                            # 4. Identify Business & Get Internal Key
                            conn = None
                            internal_key = None
                            business_id = None
                            try:
                                conn = get_db_connection()
                                cursor = conn.cursor()
                                # TODO: Update DB schema and query to map recipient_id (Page ID) to business_id
                                # Example assumes `facebook_page_id` column exists on `businesses` table:
                                cursor.execute("SELECT business_id, internal_api_key FROM businesses WHERE facebook_page_id = %s", (recipient_id,))
                                result = cursor.fetchone()
                                if result:
                                    business_id = str(result[0])
                                    internal_key = result[1]
                                    log.info(f"Mapped page {recipient_id} to business {business_id}")
                                else:
                                    log.error(f"Could not find business associated with Facebook Page ID: {recipient_id}")
                                    continue # Skip processing this message
                            except Exception as e:
                                log.error(f"DB error looking up business for page {recipient_id}: {str(e)}", exc_info=True)
                                continue # Skip processing this message
                            finally:
                                if conn:
                                    release_db_connection(conn)
                            
                            if not internal_key or not business_id:
                                continue # Skip if mapping failed

                            # 5. Process Message using MessageHandler (if available)
                            if MessageHandler:
                                try:
                                    # Assuming MessageHandler takes db_pool or connection factory
                                    # And internal_key if it needs to make authenticated internal API calls
                                    # message_handler = MessageHandler(get_db_pool(), internal_api_key=internal_key) 
                                    message_handler = MessageHandler(get_db_pool()) # Simpler assumption
                                    
                                    # Prepare data for the handler
                                    message_data = {
                                        'business_id': business_id,
                                        'user_id': sender_id, # Use platform sender ID as user ID
                                        'content': message_text,
                                        'platform': 'facebook' # Add platform info
                                        # Add conversation_id if available from context/lookup
                                    }
                                    
                                    processing_result = message_handler.process_message(message_data)
                                    
                                    # 6. Handle Result & Respond to Platform
                                    if processing_result.get('success'):
                                        response_to_user = processing_result.get('response', "Sorry, I couldn't process that.")
                                        log.info(f"Successfully processed message for business {business_id}. Response: '{response_to_user[:50]}...'")
                                        # TODO: Implement logic to send `response_to_user` back to Facebook `sender_id`
                                        # using Facebook Graph API (requires Page Access Token)
                                        # send_facebook_message(recipient_id, sender_id, response_to_user)
                                    else:
                                        log.error(f"MessageHandler failed for business {business_id}: {processing_result.get('error')}")
                                        # TODO: Optionally send an error message back to the user via Facebook API
                                        # send_facebook_message(recipient_id, sender_id, "Sorry, an error occurred.")

                                except Exception as proc_err:
                                    log.error(f"Error invoking MessageHandler for business {business_id}: {proc_err}", exc_info=True)
                                    # TODO: Optionally send an error message back to the user
                            else:
                                log.error("MessageHandler not loaded, cannot process message.")
                                # TODO: Optionally send error message back to user

        return "EVENT_RECEIVED", 200 # Acknowledge receipt to Facebook
    else:
        return jsonify({"error": "Method Not Allowed"}), 405

# Add similar endpoints for other platforms (WhatsApp, etc.) following the same pattern:
# 1. Signature Verification
# 2. Parse Payload
# 3. Identify Business & Get Internal Key (using platform-specific identifiers)
# 4. Call Internal Processing Logic (passing internal key for auth)

# register_message_routes seems unnecessary if using Blueprints directly in app.py
# def register_message_routes(app, require_api_key, limiter):
#     app.register_blueprint(bp)

@bp.route('/api/message', methods=['POST', 'OPTIONS'])
def handle_message():
    """Handle incoming messages."""
    # Handle CORS preflight requests
    if request.method == 'OPTIONS':
        response = jsonify({'success': True})
        response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey')
        response.headers.add('Access-Control-Allow-Methods', 'POST,OPTIONS')
        response.headers.add('Access-Control-Allow-Credentials', 'true')
        return response

    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'No data provided'}), 400

    # Extract and validate required fields
    business_id = data.get('business_id', '32a6f42a-b6cf-41e3-a970-bdb051784eff')  # Default to Ask Samir business
    user_id = data.get('user_id')
    content = data.get('content')
    conversation_id = data.get('conversation_id')

    if not all([user_id, content]):
        return jsonify({
            'success': False,
            'error': 'Missing required fields: user_id, content'
        }), 400

    if not is_valid_uuid(user_id):
        return jsonify({
            'success': False,
            'error': 'Invalid UUID format for user_id'
        }), 400

    if conversation_id and not is_valid_uuid(conversation_id):
        return jsonify({
            'success': False,
            'error': 'Invalid UUID format for conversation_id'
        }), 400

    try:
        # Initialize message handler
        message_handler = MessageHandler(get_db_pool())
        
        # Process the message
        result = message_handler.process_message({
            'business_id': business_id,
            'user_id': user_id,
            'content': content,
            'conversation_id': conversation_id
        })

        if result.get('success'):
            response = jsonify(result)
            response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            return response
        else:
            return jsonify(result), 500

    except Exception as e:
        log.error(f"Error processing message: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'error': f"Error processing message: {str(e)}"
        }), 500

================================================================================
File: message_simulator.py
Path: .\backend\routes\message_simulator.py
Size: 3655
Modified: 2025-05-10T18:04:25.571260
Created: 2025-05-10T17:36:13.910471
Hash: d045b7329fd9ec520b409c18ece150c7fd8822dee06788b2a9cbbf70c8110e90
Lines: 117
================================================================================
"""
Message Simulator Routes

This module provides API endpoints for simulating message processing and testing
the template system.
"""

from flask import Blueprint, request, jsonify
from ..message_processing.message_simulator import MessageSimulator
from ..auth import require_api_key, require_auth

bp = Blueprint('message_simulator', __name__)
simulator = MessageSimulator()

@bp.route('/message', methods=['POST', 'OPTIONS'])
@require_api_key
@require_auth
def simulate_message():
    """
    Endpoint to simulate sending a message.
    
    Required Headers:
    - businessapikey: Your business API key
    - Authorization: Bearer token for authentication
    
    Expected JSON body:
    {
        "user_id": "string",
        "business_id": "string",
        "message_content": "string",
        "conversation_id": "string" (optional)
    }
    """
    # Handle CORS preflight requests
    if request.method == 'OPTIONS':
        response = jsonify({'success': True})
        response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,businessapikey')
        response.headers.add('Access-Control-Allow-Methods', 'POST,OPTIONS')
        response.headers.add('Access-Control-Allow-Credentials', 'true')
        return response

    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['user_id', 'business_id', 'message_content']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    'success': False,
                    'error': f"Missing required field: {field}"
                }), 400
        
        # Simulate the message
        result = simulator.simulate_message(
            user_id=data['user_id'],
            message_content=data['message_content'],
            business_id=data['business_id'],
            conversation_id=data.get('conversation_id')
        )
        
        return jsonify(result)
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@bp.route('/conversation/<conversation_id>', methods=['GET'])
@require_api_key
@require_auth
def get_conversation_history(conversation_id):
    """
    Get the history of a specific conversation.
    
    Required Headers:
    - businessapikey: Your business API key
    - Authorization: Bearer token for authentication
    """
    try:
        history = simulator.get_conversation_history(conversation_id)
        return jsonify({
            'success': True,
            'conversation_id': conversation_id,
            'messages': history
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@bp.route('/user/<user_id>/conversations', methods=['GET'])
@require_api_key
@require_auth
def get_user_conversations(user_id):
    """
    Get all conversations for a specific user.
    
    Required Headers:
    - businessapikey: Your business API key
    - Authorization: Bearer token for authentication
    """
    try:
        conversations = simulator.get_user_conversations(user_id)
        return jsonify({
            'success': True,
            'user_id': user_id,
            'conversations': conversations
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500 

================================================================================
File: monitoring_routes.py
Path: .\backend\routes\monitoring_routes.py
Size: 7430
Modified: 2025-05-04T01:44:22.552078
Created: 2025-05-03T20:06:56.846250
Hash: cd2d002fb0fcbc9c3edec7125b1eb82c0f78d6844e78b437274465def1f71b38
Lines: 198
================================================================================
"""
Monitoring Routes

This module provides API routes for accessing monitoring data.
"""

from flask import Blueprint, jsonify, request, render_template
from backend.monitoring.enhanced_monitoring import EnhancedMonitoring
from backend.db import get_db_pool
import logging

log = logging.getLogger(__name__)

monitoring_bp = Blueprint('monitoring', __name__)

# Initialize monitoring system with database pool
db_pool = get_db_pool()
monitoring = EnhancedMonitoring(db_pool)

@monitoring_bp.route('/monitoring-dashboard')
def monitoring_dashboard():
    """Serve the enhanced monitoring dashboard."""
    return render_template('enhanced_dashboard.html')

@monitoring_bp.route('/api/monitoring/overview', methods=['GET'])
def get_overview():
    """Get overview statistics."""
    try:
        data = monitoring.get_overview_stats()
        return jsonify(data)
    except Exception as e:
        log.error(f"Error getting overview stats: {str(e)}")
        return jsonify({'error': str(e)}), 500

@monitoring_bp.route('/api/monitoring/performance', methods=['GET'])
def get_performance():
    """Get performance trends."""
    try:
        days = request.args.get('days', default=7, type=int)
        data = monitoring.get_performance_trends(days)
        trend_plot = monitoring.get_trend_plot(days)
        return jsonify({
            'data': data,
            'trend_plot': trend_plot
        })
    except Exception as e:
        log.error(f"Error getting performance trends: {str(e)}")
        return jsonify({'error': str(e)}), 500

@monitoring_bp.route('/api/monitoring/patterns', methods=['GET'])
def get_patterns():
    """Get pattern analysis."""
    try:
        data = monitoring.get_pattern_analysis()
        pattern_plot = monitoring.get_pattern_plot()
        return jsonify({
            'data': data,
            'pattern_plot': pattern_plot
        })
    except Exception as e:
        log.error(f"Error getting pattern analysis: {str(e)}")
        return jsonify({'error': str(e)}), 500

@monitoring_bp.route('/api/monitoring/errors', methods=['GET'])
def get_errors():
    """Get error analysis."""
    try:
        data = monitoring.get_error_analysis()
        error_plot = monitoring.get_error_plot()
        return jsonify({
            'data': data,
            'error_plot': error_plot
        })
    except Exception as e:
        log.error(f"Error getting error analysis: {str(e)}")
        return jsonify({'error': str(e)}), 500

@monitoring_bp.route('/api/monitoring/templates', methods=['GET'])
def get_templates():
    """Get template performance."""
    try:
        data = monitoring.get_template_performance()
        template_plot = monitoring.get_template_plot()
        return jsonify({
            'data': data,
            'template_plot': template_plot
        })
    except Exception as e:
        log.error(f"Error getting template performance: {str(e)}")
        return jsonify({'error': str(e)}), 500

@monitoring_bp.route('/api/monitoring/pipeline', methods=['GET'])
def get_pipeline():
    """Get processing pipeline metrics."""
    try:
        data = monitoring.get_processing_pipeline_metrics()
        pipeline_plot = monitoring.get_pipeline_plot()
        return jsonify({
            'data': data,
            'pipeline_plot': pipeline_plot
        })
    except Exception as e:
        log.error(f"Error getting pipeline metrics: {str(e)}")
        return jsonify({'error': str(e)}), 500

@monitoring_bp.route('/api/monitoring/ai', methods=['GET'])
def get_ai_performance():
    """Get AI performance metrics."""
    try:
        data = monitoring.get_ai_performance_metrics()
        ai_plot = monitoring.get_ai_performance_plot()
        return jsonify({
            'data': data,
            'ai_plot': ai_plot or '{}'  # Return empty JSON if plot is None
        })
    except Exception as e:
        log.error(f"Error getting AI performance metrics: {str(e)}")
        return jsonify({
            'data': {},
            'ai_plot': '{}'
        }), 500

@monitoring_bp.route('/api/monitoring/error-patterns', methods=['GET'])
def get_error_patterns():
    """Get error pattern analysis."""
    try:
        data = monitoring.get_error_pattern_analysis()
        error_pattern_plot = monitoring.get_error_pattern_plot()
        return jsonify({
            'data': data,
            'error_pattern_plot': error_pattern_plot
        })
    except Exception as e:
        log.error(f"Error getting error pattern analysis: {str(e)}")
        return jsonify({'error': str(e)}), 500

@monitoring_bp.route('/api/monitoring/all', methods=['GET'])
def get_all_metrics():
    """Get all monitoring data."""
    try:
        # Get all metrics with proper error handling
        overview = monitoring.get_overview_stats() or {}
        performance_trends = {
            'data': monitoring.get_performance_trends(7) or {},
            'trend_plot': monitoring.get_trend_plot(7) or '{}'
        }
        pattern_analysis = {
            'data': monitoring.get_pattern_analysis() or {},
            'pattern_plot': monitoring.get_pattern_plot() or '{}'
        }
        error_analysis = {
            'data': monitoring.get_error_analysis() or {},
            'error_plot': monitoring.get_error_plot() or '{}'
        }
        template_performance = {
            'data': monitoring.get_template_performance() or {},
            'template_plot': monitoring.get_template_plot() or '{}'
        }
        pipeline_metrics = {
            'data': monitoring.get_processing_pipeline_metrics() or {},
            'pipeline_plot': monitoring.get_pipeline_plot() or '{}'
        }
        ai_performance = {
            'data': monitoring.get_ai_performance_metrics() or {},
            'ai_plot': monitoring.get_ai_performance_plot() or '{}'
        }
        error_patterns = {
            'data': monitoring.get_error_pattern_analysis() or {},
            'error_pattern_plot': monitoring.get_error_pattern_plot() or '{}'
        }

        # Log the response for debugging
        log.info("Returning monitoring data")
        log.info(f"AI Performance Data: {ai_performance}")
        
        return jsonify({
            'overview': overview,
            'performance_trends': performance_trends,
            'pattern_analysis': pattern_analysis,
            'error_analysis': error_analysis,
            'template_performance': template_performance,
            'pipeline_metrics': pipeline_metrics,
            'ai_performance': ai_performance,
            'error_patterns': error_patterns
        })
    except Exception as e:
        log.error(f"Error getting all metrics: {str(e)}")
        # Return empty but valid JSON structure
        return jsonify({
            'overview': {},
            'performance_trends': {'data': {}, 'trend_plot': '{}'},
            'pattern_analysis': {'data': {}, 'pattern_plot': '{}'},
            'error_analysis': {'data': {}, 'error_plot': '{}'},
            'template_performance': {'data': {}, 'template_plot': '{}'},
            'pipeline_metrics': {'data': {}, 'pipeline_plot': '{}'},
            'ai_performance': {'data': {}, 'ai_plot': '{}'},
            'error_patterns': {'data': {}, 'error_pattern_plot': '{}'}
        }), 500 

================================================================================
File: ping.py
Path: .\backend\routes\ping.py
Size: 379
Modified: 2025-05-02T10:52:20.138109
Created: 2025-03-31T17:53:17.390278
Hash: d7b7c8cdba095979f3e481caf2faec5650ebea61fdb899247a8a661358760abd
Lines: 11
================================================================================
from flask import jsonify, request, Blueprint
from icmplib import ping
import logging

log = logging.getLogger(__name__)
bp = Blueprint('ping', __name__, url_prefix='/ping')

@bp.route('/', methods=['GET', 'POST']) # Allow GET for easy browser testing
def ping():
    print("--- Inside /ping route handler --- ") # Add print
    return jsonify({"message": "pong"}), 200

================================================================================
File: privacy.py
Path: .\backend\routes\privacy.py
Size: 6859
Modified: 2025-05-02T10:52:20.138109
Created: 2025-04-27T11:41:47.298451
Hash: cd3454f75ee750d5919a0baefc4b7e737adb879214c55616af0765bfe1232840
Lines: 170
================================================================================
import base64
import hashlib
import hmac
import json
import logging
import os
import uuid
from typing import Union

from flask import Blueprint, request, jsonify, abort

from backend.db import get_db_connection, release_db_connection

log = logging.getLogger(__name__)

privacy_bp = Blueprint('privacy', __name__, url_prefix='/privacy')

# Load Facebook App Secret from environment variable
FB_APP_SECRET = os.getenv('FB_APP_SECRET')

def parse_signed_request(signed_request: str, secret: str) -> Union[dict, None]:
    """Parses and verifies the Facebook signed_request.

    Args:
        signed_request: The signed_request string from Facebook.
        secret: The Facebook App Secret.

    Returns:
        The decoded payload dictionary if verification succeeds, otherwise None.
    """
    if not signed_request or '.' not in signed_request:
        log.error("Invalid signed_request format.")
        return None

    try:
        encoded_sig, payload = signed_request.split('.', 1)

        # Decode signature
        sig = base64.urlsafe_b64decode(encoded_sig + "==") # Add padding if needed

        # Decode data
        data = base64.urlsafe_b64decode(payload + "==") # Add padding if needed
        data = json.loads(data)

        if data.get('algorithm', '').upper() != 'HMAC-SHA256':
            log.error(f"Unknown algorithm {data.get('algorithm')}")
            return None

        # Check signature
        expected_sig = hmac.new(
            secret.encode('utf-8'),
            payload.encode('utf-8'),
            hashlib.sha256
        ).digest()

        if not hmac.compare_digest(expected_sig, sig):
            log.error("Invalid signature in signed_request.")
            return None

        log.info("Signed request verified successfully.")
        return data
    except (ValueError, TypeError, json.JSONDecodeError, binascii.Error) as e:
        log.error(f"Error decoding/verifying signed_request: {e}")
        return None
    except Exception as e:
        log.error(f"Unexpected error parsing signed_request: {e}", exc_info=True)
        return None


@privacy_bp.route('/facebook/delete', methods=['POST'])
def facebook_data_deletion():
    """Handles Facebook's Data Deletion Request Callback."""
    log.info("Received request on /privacy/facebook/delete")

    # Test mode for Facebook verification
    if request.args.get('test') == 'true':
        test_response = {
            'url': f"https://{request.host}/privacy/status",
            'confirmation_code': 'test-deletion-' + str(uuid.uuid4())
        }
        return jsonify(test_response), 200

    if not FB_APP_SECRET:
        log.error("FB_APP_SECRET is not configured. Cannot process data deletion request.")
        # Abort, but don't reveal internal config error to Facebook
        return jsonify({'error': 'Internal configuration error'}), 500

    signed_request_param = request.form.get('signed_request')
    if not signed_request_param:
        log.warning("Missing 'signed_request' parameter in Facebook data deletion request.")
        return jsonify({'error': 'Missing signed_request parameter'}), 400

    log.info(f"Received signed_request: {signed_request_param[:50]}...") # Log prefix for safety

    payload = parse_signed_request(signed_request_param, FB_APP_SECRET)

    if payload is None:
        log.error("Failed to verify or parse signed_request.")
        # According to FB docs, should still return 200 OK or 404 Not Found
        # Let's return 400 Bad Request as it failed verification
        return jsonify({'error': 'Invalid signed_request'}), 400

    fb_user_id = payload.get('user_id')
    if not fb_user_id:
        log.error("No user_id found in signed_request payload.")
        return jsonify({'error': 'Missing user_id in payload'}), 400

    log.info(f"Initiating data deletion process for Facebook User ID: {fb_user_id}")

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # --- Data Deletion Logic ---
        # Find the user based on their Facebook ID (assuming stored in 'external_id')
        cursor.execute("SELECT user_id FROM users WHERE external_id = %s AND platform = 'facebook'", (fb_user_id,))
        user_result = cursor.fetchone()

        if not user_result:
            log.warning(f"User with Facebook ID {fb_user_id} not found in our system.")
            # User not found - respond as if deletion is complete/not applicable
        else:
            internal_user_id = user_result[0]
            log.info(f"Found internal user ID {internal_user_id} for Facebook ID {fb_user_id}. Proceeding with deletion.")

            # Example: Delete related data first (adjust table/column names as needed)
            # cursor.execute("DELETE FROM messages WHERE user_id = %s", (internal_user_id,))
            # cursor.execute("DELETE FROM conversations WHERE user_id = %s", (internal_user_id,))
            # ... add other related data deletions here ...

            # Delete the user record itself
            cursor.execute("DELETE FROM users WHERE user_id = %s", (internal_user_id,))

            conn.commit()
            log.info(f"Successfully deleted data for Facebook User ID: {fb_user_id} (Internal ID: {internal_user_id})")

        cursor.close()

    except Exception as e:
        if conn:
            conn.rollback() # Rollback on error
        log.error(f"Database error during data deletion for Facebook User ID {fb_user_id}: {e}", exc_info=True)
        # Respond with an error, but Facebook expects 200 OK or 404
        # We'll log the error but still return the success structure
        pass # Fall through to success response as per FB docs recommendations
    finally:
        if conn:
            release_db_connection(conn)

    # Respond to Facebook
    # Provide a URL to track status (can be your main site or a specific status page)
    # Generate a unique confirmation code
    status_url = f"https://{request.host}/privacy/status" # Example URL
    confirmation_code = f"fbdel-{uuid.uuid4()}"

    response_payload = {
        'url': status_url,
        'confirmation_code': confirmation_code
    }
    log.info(f"Responding to Facebook data deletion request for User ID {fb_user_id} with code {confirmation_code}")

    return jsonify(response_payload), 200

# You might want a simple status page (optional, can just be your main page)
@privacy_bp.route('/status', methods=['GET'])
def deletion_status():
    """A simple page users can be directed to after requesting deletion."""
    # You could enhance this to show status based on confirmation_code if needed
    return "Your data deletion request is being processed. Please allow up to 48 hours.", 200

================================================================================
File: routing.py
Path: .\backend\routes\routing.py
Size: 3037
Modified: 2025-05-02T10:52:20.154408
Created: 2025-04-09T09:51:16.029845
Hash: 8f125108334a83f7e6eb36633d151c5d35a995e81f3771242cf02bd7a0eae5de
Lines: 83
================================================================================
"""
Routing module for handling message routing logic.

This module provides functionality for routing messages to appropriate handlers
based on business rules and configuration.
"""

from flask import Blueprint, jsonify, request
import logging
from backend.db import get_db_connection, release_db_connection
from backend.auth import require_internal_key

log = logging.getLogger(__name__)

# Create blueprint for routing endpoints
bp = Blueprint('routing', __name__, url_prefix='/routing')

@bp.route('/route', methods=['POST'])
@require_internal_key
def route_message():
    """
    Route a message to the appropriate handler based on business rules.
    Assumes business context (g.business_id) is set by the decorator.
    """
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400
        
    data = request.get_json()
    
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id

    # Extract other required fields
    message = data.get('message')
    user_id = data.get('user_id')
    
    if not all([message, user_id]):
        log.warning(f"Missing message or user_id for business {business_id}")
        return jsonify({
            "error": "Missing required fields",
            "required_fields": ["message", "user_id"]
        }), 400
    
    log.info(f"Routing message for business {business_id}, user {user_id}")
    # Placeholder routing logic
    return jsonify({
        "status": "success",
        "routing_destination": "default_handler",
        "message": f"Message for business {business_id} would be routed"
    }), 200

@bp.route('/handlers', methods=['GET'])
@require_internal_key
def get_available_handlers():
    """
    Get a list of available message handlers for the business.
    Assumes business context (g.business_id) is set by the decorator.
    """
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    
    log.info(f"Fetching available handlers for business {business_id}")
    # Mock response - fetch from DB based on business_id in a real implementation
    handlers = [
        {
            "handler_id": "default_handler",
            "name": "Default Handler",
            "description": "Default message handling workflow"
        },
        {
            "handler_id": "specialized_handler",
            "name": "Specialized Handler",
            "description": "Specialized processing for certain message types"
        }
    ]
    
    return jsonify(handlers), 200

================================================================================
File: stages.py
Path: .\backend\routes\stages.py
Size: 20479
Modified: 2025-05-02T10:52:20.154408
Created: 2025-03-31T17:53:17.411223
Hash: d9b895b79c4e5bc43d8650b5edc950de183fdae65f57cb9a6275ddbaa4392f2c
Lines: 496
================================================================================
# routes/stages.py
from flask import Blueprint, request, jsonify, redirect, url_for, g
from db import get_db_connection, release_db_connection
import uuid
import logging
import json
from auth import require_api_key, require_internal_key
from .utils import is_valid_uuid
import os
import re
from psycopg2.extras import RealDictCursor

log = logging.getLogger(__name__)

stages_bp = Blueprint('stages', __name__, url_prefix='/api/stages')

@stages_bp.route('', methods=['GET'])
@require_api_key
def get_stages():
    # Get business_id from required query parameter
    business_id = request.args.get('business_id')
    if not business_id:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required query parameter: business_id"}), 400
    if not is_valid_uuid(business_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format in query parameter"}), 400
        
    log.info(f"Fetching all stages for business {business_id} via admin key")

    agent_id_filter = request.args.get('agent_id')

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        query = "SELECT stage_id, stage_name, stage_description, stage_type, agent_id FROM stages WHERE business_id = %s"
        params = [business_id]
        
        if agent_id_filter:
            # If agent_id is specified, show only agent-specific stages
            query += " AND agent_id = %s"
            params.append(agent_id_filter)
        else:
            # If no agent_id, show only default stages (where agent_id is null)
            query += " AND agent_id IS NULL"
        
        query += " ORDER BY stage_name"
        
        cursor.execute(query, tuple(params))
        stages = cursor.fetchall()
        
        stage_list = [
            {
                "stage_id": str(row[0]), 
                "stage_name": row[1],
                "stage_description": row[2],
                "stage_type": row[3],
                "agent_id": str(row[4]) if row[4] else None
            } for row in stages
        ]
        return jsonify(stage_list), 200

    except Exception as e:
        log.error(f"Error fetching stages for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@stages_bp.route('', methods=['POST', 'OPTIONS'])
@require_api_key
def post_stages():
    # Handle CORS preflight requests
    if request.method == 'OPTIONS':
        response = jsonify({'success': True})
        response.headers.add('Access-Control-Allow-Origin', request.headers.get('Origin', '*'))
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,Accept')
        response.headers.add('Access-Control-Allow-Methods', 'POST,GET,PUT,DELETE,OPTIONS')
        return response

    # Log the raw request data before parsing
    try:
        raw_data = request.get_data().decode('utf-8')
        log.info(f"Raw POST /api/stages request data (admin): {raw_data}")
    except Exception as e:
        log.warning(f"Could not decode raw request data: {str(e)}")
        
    try:
        data = request.get_json()
        log.info(f"POST stage data received (admin parsed): {json.dumps(data, default=str)}")
    except Exception as e:
        log.error(f"Error parsing JSON: {str(e)}")
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid JSON in request body"}), 400
    
    if not data:
        log.error("No JSON data received in admin create stage request")
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON and contain data"}), 400
        
    # --- Admin Payload Validation --- 
    business_id = data.get('business_id')
    agent_id = data.get('agent_id') # Agent assignment is required for admin creation in this flow
    stage_name = data.get('stage_name')
    
    if not business_id:
         return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required field: business_id"}), 400
    if not is_valid_uuid(business_id):
         return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format"}), 400
         
    if not agent_id:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required field: agent_id"}), 400
    if not is_valid_uuid(agent_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid agent_id format"}), 400
        
    if not stage_name or not str(stage_name).strip():
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing or empty required field: stage_name"}), 400
        
    # Ensure critical fields have defaults if missing (keep defaults)
    stage_description = data.get('stage_description', "Default stage description")
    stage_type = data.get('stage_type', "conversation")
    
    # --- Template Handling (Require IDs, Validate, then COPY) --- 
    using_template_ids = all(key in data for key in [
        'stage_selection_template_id', 
        'data_extraction_template_id', 
        'response_generation_template_id'
    ])
    
    if not using_template_ids:
        return jsonify({"error_code": "BAD_REQUEST", 
                        "message": "Missing required template IDs: stage_selection_template_id, data_extraction_template_id, response_generation_template_id"}), 400

    selection_template_id_orig = data['stage_selection_template_id']
    extraction_template_id_orig = data['data_extraction_template_id']
    generation_template_id_orig = data['response_generation_template_id']

    # Validate template IDs format
    if not all(is_valid_uuid(tid) for tid in [selection_template_id_orig, extraction_template_id_orig, generation_template_id_orig]):
         return jsonify({"error_code": "BAD_REQUEST", "message": "One or more template IDs have invalid format"}), 400

    # --- Database Operations ---
    stage_id = str(uuid.uuid4())
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        
        # Verify Business and Agent exist
        cursor.execute("SELECT 1 FROM businesses WHERE business_id = %s", (business_id,))
        if not cursor.fetchone():
             return jsonify({"error_code": "NOT_FOUND", "message": f"Business {business_id} not found"}), 404
        cursor.execute("SELECT 1 FROM agents WHERE agent_id = %s AND business_id = %s", (agent_id, business_id))
        if not cursor.fetchone():
             return jsonify({"error_code": "NOT_FOUND", "message": f"Agent {agent_id} not found or does not belong to business {business_id}"}), 404
             
        # --- Template Copying Logic --- 
        new_template_ids = {}
        templates_to_copy = {
            'stage_selection': selection_template_id_orig,
            'data_extraction': extraction_template_id_orig,
            'response_generation': generation_template_id_orig
        }
        
        for template_key, original_id in templates_to_copy.items():
            log.info(f"Processing template copy for {template_key}, original ID: {original_id}")
            # Fetch the original template ensuring it belongs to the correct business
            cursor.execute(
                """
                SELECT template_name, template_type, content, system_prompt, is_default
                FROM templates
                WHERE template_id = %s AND business_id = %s
                """,
                (original_id, business_id)
            )
            template_row = cursor.fetchone()
            if not template_row:
                log.error(f"Original template {original_id} not found for business {business_id}")
                # Rollback potentially needed if previous copies were made? Transaction handles this.
                return jsonify({"error_code": "NOT_FOUND", "message": f"Template {original_id} not found or does not belong to business {business_id}"}), 404
            
            # Create a new template ID for the copy
            new_template_id = str(uuid.uuid4())
            new_template_name = f"{template_row['template_name']} (Stage: {stage_name[:20]})" # Indicate copy
            
            log.info(f"Creating copy with new ID: {new_template_id}, Name: {new_template_name}")
            # Insert the new template copy
            cursor.execute(
                """
                INSERT INTO templates (
                    template_id, template_name, template_type, content, 
                    system_prompt, business_id, is_default 
                ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    new_template_id,
                    new_template_name,
                    template_row['template_type'], # Use original type
                    template_row['content'],
                    template_row['system_prompt'],
                    business_id, # Associate copy with the same business
                    False # Copied templates are not defaults
                )
            )
            # Store the new template ID
            new_template_ids[f"{template_key}_template_id"] = new_template_id
            log.info(f"Stored new ID for {template_key}: {new_template_id}")

        # --- Insert the new stage using COPIED template IDs --- 
        log.info(f"Inserting new stage {stage_id} with copied template IDs: {new_template_ids}")
        cursor.execute(
            """
            INSERT INTO stages (
                stage_id, business_id, agent_id, stage_name, stage_description,
                stage_type, stage_selection_template_id, data_extraction_template_id,
                response_generation_template_id
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING *;
            """,
            (
                stage_id,
                business_id, # From payload
                agent_id,    # From payload
                stage_name,  # From payload
                stage_description,
                stage_type,
                new_template_ids['stage_selection_template_id'], # Use NEW ID
                new_template_ids['data_extraction_template_id'], # Use NEW ID
                new_template_ids['response_generation_template_id']  # Use NEW ID
            )
        )
        
        new_stage = cursor.fetchone()
        conn.commit()
        log.info(f"Admin created stage {stage_id} for business {business_id}, agent {agent_id}")
        
        # Convert UUIDs/datetimes for response
        for key, value in new_stage.items():
             if isinstance(value, uuid.UUID):
                 new_stage[key] = str(value)
             elif hasattr(value, 'isoformat'):
                 new_stage[key] = value.isoformat()
                 
        return jsonify(new_stage), 201
            
    except Exception as e:
        log.error(f"Error creating stage (admin): {str(e)}", exc_info=True)
        if conn:
            conn.rollback()
        # Add specific error checks if needed (e.g., unique stage name constraint?)
        return jsonify({"error_code": "DB_ERROR", "message": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@stages_bp.route('/<stage_id>', methods=['PUT'])
@require_api_key
def update_stage(stage_id):
    # Validate stage_id format
    if not is_valid_uuid(stage_id):
        return jsonify({"error": "Invalid stage_id format"}), 400
        
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request must be JSON and contain data"}), 400
            
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
            
        try:
            cursor = conn.cursor()
            
            # Check if stage exists
            cursor.execute(
                "SELECT * FROM stages WHERE stage_id = %s",
                (stage_id,)
            )
            stage = cursor.fetchone()
            if not stage:
                return jsonify({"error": "Stage not found"}), 404
                
            # Update stage fields
            update_fields = []
            update_values = []
            
            for field in ['stage_name', 'stage_description', 'stage_type', 'agent_id']:
                if field in data:
                    update_fields.append(f"{field} = %s")
                    update_values.append(data[field])
                    
            if not update_fields:
                return jsonify({"error": "No fields to update"}), 400
                
            # Construct and execute update query
            query = f"""
                UPDATE stages 
                SET {', '.join(update_fields)}
                WHERE stage_id = %s
            """
            update_values.append(stage_id)
            
            cursor.execute(query, tuple(update_values))
            conn.commit()
            
            # Return updated stage
            cursor.execute(
                "SELECT * FROM stages WHERE stage_id = %s",
                (stage_id,)
            )
            updated_stage = cursor.fetchone()
            
            return jsonify(updated_stage), 200
            
        except Exception as e:
            log.error(f"Database error: {str(e)}", exc_info=True)
            return jsonify({"error": f"Database error: {str(e)}"}), 500
        finally:
            if conn:
                release_db_connection(conn)
    except Exception as e:
        log.error(f"Error handling request: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@stages_bp.route('/<stage_id>', methods=['DELETE'])
@require_api_key
def delete_stage(stage_id):
    # Validate stage_id format
    if not is_valid_uuid(stage_id):
        return jsonify({"error": "Invalid stage_id format"}), 400
        
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = conn.cursor()
        
        # Check if stage exists
        cursor.execute(
            "SELECT * FROM stages WHERE stage_id = %s",
            (stage_id,)
        )
        stage = cursor.fetchone()
        if not stage:
            return jsonify({"error": "Stage not found"}), 404
            
        # Delete associated templates
        for template_field in ['stage_selection_template_id', 'data_extraction_template_id', 'response_generation_template_id']:
            template_id = stage[template_field]
            if template_id:
                cursor.execute(
                    "DELETE FROM templates WHERE template_id = %s",
                    (template_id,)
                )
                
        # Delete the stage
        cursor.execute(
            "DELETE FROM stages WHERE stage_id = %s",
            (stage_id,)
        )
        
        conn.commit()
        return jsonify({"message": "Stage deleted successfully"}), 200
        
    except Exception as e:
        log.error(f"Error deleting stage: {str(e)}", exc_info=True)
        if conn:
            conn.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@stages_bp.route('/preview', methods=['POST'])
@require_internal_key
def preview_templates():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request must be JSON and contain data"}), 400
            
        # Extract template configs
        stage_selection_config = data.get('stage_selection_config', {})
        data_extraction_config = data.get('data_extraction_config', {})
        response_generation_config = data.get('response_generation_config', {})
        
        # Extract variables from each template
        stage_selection_vars = extractVariablesFromContent(stage_selection_config.get('content', ''))
        data_extraction_vars = extractVariablesFromContent(data_extraction_config.get('content', ''))
        response_generation_vars = extractVariablesFromContent(response_generation_config.get('content', ''))
        
        return jsonify({
            "stage_selection_variables": stage_selection_vars,
            "data_extraction_variables": data_extraction_vars,
            "response_generation_variables": response_generation_vars
        }), 200
        
    except Exception as e:
        log.error(f"Error previewing templates: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@stages_bp.route('/<stage_id>', methods=['GET'])
@require_api_key
def get_stage(stage_id):
    # Validate stage_id format
    if not is_valid_uuid(stage_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid stage_id format"}), 400
        
    log.info(f"Fetching stage {stage_id} via admin key")
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=RealDictCursor)

        # Fetch stage and include business_id in the result
        cursor.execute("""
            SELECT 
                s.*, 
                ss_tmpl.template_name AS stage_selection_template_name, 
                de_tmpl.template_name AS data_extraction_template_name, 
                rg_tmpl.template_name AS response_generation_template_name
            FROM stages s
            LEFT JOIN templates ss_tmpl ON s.stage_selection_template_id = ss_tmpl.template_id
            LEFT JOIN templates de_tmpl ON s.data_extraction_template_id = de_tmpl.template_id
            LEFT JOIN templates rg_tmpl ON s.response_generation_template_id = rg_tmpl.template_id
            WHERE s.stage_id = %s;
        """, (stage_id,))
        
        stage = cursor.fetchone()

        if not stage:
            return jsonify({"error_code": "NOT_FOUND", "message": "Stage not found"}), 404

        # Convert UUIDs and potentially other types to strings for JSON
        for key, value in stage.items():
            if isinstance(value, uuid.UUID):
                stage[key] = str(value)
            elif hasattr(value, 'isoformat'): # Handle datetimes
                stage[key] = value.isoformat()
        
        return jsonify(stage), 200

    except Exception as e:
        log.error(f"Error fetching stage {stage_id} (admin): {str(e)}", exc_info=True)
        return jsonify({"error_code": "SERVER_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@stages_bp.route('/template/<template_id>', methods=['GET'])
@require_internal_key
def get_template(template_id):
    # Validate template_id format
    if not is_valid_uuid(template_id):
        return jsonify({"error": "Invalid template_id format"}), 400
        
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = conn.cursor()
        
        # Get template details
        cursor.execute(
            "SELECT * FROM templates WHERE template_id = %s",
            (template_id,)
        )
        
        template = cursor.fetchone()
        if not template:
            return jsonify({"error": "Template not found"}), 404
            
        return jsonify(template), 200
        
    except Exception as e:
        log.error(f"Error getting template: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

def extractVariablesFromContent(content):
    """Extract variables from template content."""
    if not content:
        return []
        
    # Find all variables in the format {{variable_name}}
    variables = re.findall(r'{{(.*?)}}', content)
    
    # Remove duplicates and sort
    variables = sorted(list(set(variables)))
    
    return variables

================================================================================
File: stage_management.py
Path: .\backend\routes\stage_management.py
Size: 2626
Modified: 2025-05-02T10:52:20.170869
Created: 2025-03-31T17:53:17.401260
Hash: 4abc42c7f7d8e9f8db81c974dcb4aacc83c9259508d25800227aa884df9ea315
Lines: 64
================================================================================
from flask import jsonify, request, Blueprint # ADD Blueprint in here
import uuid
import logging
from jsonschema import validate, ValidationError
from db import get_db_connection, release_db_connection
from auth import require_api_key

log = logging.getLogger(__name__)

bp = Blueprint('stage_management', __name__, url_prefix='/stages')

stage_schema = {
    "type": "object",
    "properties": {
        "business_id": {"type": "string", "format": "uuid"},
        "stage_name": {"type": "string"},
        "stage_description": {"type": "string"},
        "stage_type": {"type": "string"},
        "stage_selection_template_id": {"type": "string"},
        "data_extraction_template_id": {"type": "string"},
        "response_generation_template_id": {"type": "string"}
    },
    "required": ["business_id", "stage_name", "stage_description", "stage_type","stage_selection_template_id","data_extraction_template_id","response_generation_template_id"]
}

def create_stage_route(request, get_db_connection):
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400

    data = request.get_json()
    try:
        validate(data, stage_schema)
    except ValidationError as e:
        return jsonify({"error_code": "INVALID_REQUEST", "message": "Invalid request format", "details": str(e)}), 400

    stage_id = str(uuid.uuid4())
    conn = get_db_connection()
    try:
        c = conn.cursor()
        c.execute(
            """
            INSERT INTO stages (stage_id, business_id, stage_name, stage_description, stage_type, stage_selection_template_id, data_extraction_template_id, response_generation_template_id)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s);
            """,
            (
                stage_id, data["business_id"], data["stage_name"], data["stage_description"], data["stage_type"],
                data["stage_selection_template_id"],data["data_extraction_template_id"],data["response_generation_template_id"]
            )
        )
        conn.commit()
        log.info({"message": "Stage created", "stage_id": stage_id})
        return jsonify({"stage_id": stage_id}), 201
    except Exception as e:
        conn.rollback()
        log.error(f"Error in create_stage: {str(e)}")
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        release_db_connection(conn)

@bp.route('', methods=['POST'])
@require_api_key # ADDED Require API KEY
#@limiter.limit("10 per minute")
def create_stage():
    return create_stage_route(request, get_db_connection)

================================================================================
File: templates.py
Path: .\backend\routes\templates.py
Size: 19939
Modified: 2025-05-02T10:52:20.179131
Created: 2025-03-31T17:53:17.434172
Hash: e79e856877cfcecd737981d39a544786c8c77462e2372aab0197cdc240001eae
Lines: 448
================================================================================
import json
import os
import sys
from flask import Blueprint, request, jsonify, g
import logging
import uuid
from jsonschema import validate, ValidationError
import psycopg2

# Handle imports whether run as module or directly
if os.path.dirname(os.path.dirname(os.path.abspath(__file__))) not in sys.path:
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from backend.auth import require_api_key, require_internal_key
from backend.db import get_db_connection, release_db_connection
from backend.routes.utils import is_valid_uuid

log = logging.getLogger(__name__)

# Use the more detailed schema definition found in the archived file
template_schema = {
  "type": "object",
  "properties": {
      # template_id is generated, not required in input
      # "template_id": {"type": "string", "format": "uuid", "minLength": 1},
      "template_name": {"type": "string", "minLength": 1},
      "content": {"type": "string", "minLength": 1},
      "system_prompt": {"type": "string"},
      "business_id": {"type": "string", "format": "uuid"},
      "template_type": {"type": "string", "enum": [
          "selection", "extraction", "generation",
          # Add other specific types if needed
          # "default_stage_selection", "default_data_extraction", "default_response_generation"
      ]},
       "is_default": {"type": "boolean"} # Added is_default
  },
  "required": ["template_name", "content", "template_type", "business_id"]
}
# Remove old schema loading
# TEMPLATE_SCHEMA = load_schema('prompt_templates') 

templates_bp = Blueprint('templates', __name__, url_prefix='/templates')

# Hardcoded example templates (Replace with DB query later)
# Used as fallback if DB fails
EXAMPLE_TEMPLATES = [
    {
        "template_id": "sel_default_v1", 
        "template_name": "Default Stage Selection v1", 
        "template_type": "selection",
        "template_description": "Basic intent detection based on summary and stage list."
    },
    {
        "template_id": "sel_order_focus_v1", 
        "template_name": "Order-Focused Stage Selection v1", 
        "template_type": "selection",
        "template_description": "Prioritizes stages related to orders if mentioned recently."
    },
    {
        "template_id": "ext_basic_entity_v1", 
        "template_name": "Basic Entity Extraction v1", 
        "template_type": "extraction",
        "template_description": "Extracts common entities like names, dates, locations."
    },
    {
        "template_id": "ext_order_details_v1", 
        "template_name": "Order Detail Extraction v1", 
        "template_type": "extraction",
        "template_description": "Specifically looks for order numbers, item names, quantities."
    },
    {
        "template_id": "gen_standard_reply_v1", 
        "template_name": "Standard Response Generation v1", 
        "template_type": "generation",
        "template_description": "Generates a standard response incorporating intent and extracted data."
    },
    {
        "template_id": "gen_confirm_action_v1", 
        "template_name": "Action Confirmation Response v1", 
        "template_type": "generation",
        "template_description": "Generates a response confirming an action based on intent/data."
    },
]

@templates_bp.route('', methods=['GET'])
@require_api_key
def get_templates():
    # Remove internal key logic
    # business_id = None
    # # Check context if using internal key
    # if hasattr(g, 'business_id'):
    #     business_id = g.business_id
    #     log.info(f"Fetching templates for business {business_id}")
    # else:
    #     # If require_api_key was used, business_id might be an optional filter
    #     business_id = request.args.get('business_id')
    #     log.info(f"Fetching templates (admin view, optional filter: business_id={business_id})")
    
    # Get business_id from required query parameter
    business_id = request.args.get('business_id')
    if not business_id:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Missing required query parameter: business_id"}), 400
    if not is_valid_uuid(business_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format in query parameter"}), 400

    log.info(f"Fetching templates for business {business_id} via admin key") # Update log
    
    template_type = request.args.get('template_type')
    is_default_filter = request.args.get('is_default') # e.g., ?is_default=true or ?is_default=false

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """SELECT template_id, template_name, template_type, business_id, is_default, created_at 
                   FROM templates WHERE 1=1"""
        params = []
        
        # Always filter by business_id for admin view
        query += " AND business_id = %s"
        params.append(business_id)
        
        if template_type:
            query += " AND template_type = %s"
            params.append(template_type)
        
        if is_default_filter is not None:
            is_default = str(is_default_filter).lower() == 'true'
            query += " AND is_default = %s"
            params.append(is_default)
            
        query += " ORDER BY template_name"

        cursor.execute(query, tuple(params))
        templates = cursor.fetchall()
        
        template_list = [
            {
                "template_id": str(row[0]), 
                "template_name": row[1],
                "template_type": row[2],
                "business_id": str(row[3]) if row[3] else None, # Business ID might be NULL for truly global defaults
                "is_default": row[4],
                "created_at": row[5].isoformat() if row[5] else None
            } for row in templates
        ]
        return jsonify(template_list), 200

    except Exception as e:
        log.error(f"Error fetching templates: {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@templates_bp.route('/<template_id>', methods=['GET'])
@require_api_key
def get_template(template_id):
    # Remove internal key logic
    # business_id = None
    # # Check context if using internal key
    # if hasattr(g, 'business_id'):
    #     business_id = g.business_id
    #     log.info(f"Fetching template {template_id} for business {business_id}")
    # else:
    #      # If using @require_api_key, access is granted, but template might still belong to a business
    #      log.info(f"Fetching template {template_id} (admin access)")

    if not is_valid_uuid(template_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid template_id format"}), 400

    log.info(f"Fetching template {template_id} via admin key") # Update log

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Remove business_id check based on internal key context
        query = """SELECT template_id, template_name, template_type, content, system_prompt, 
                          business_id, is_default, created_at, updated_at
                   FROM templates WHERE template_id = %s"""
        params = [template_id]
        
        # Remove internal key based business check
        # if business_id:
        #     query += " AND business_id = %s"
        #     params.append(business_id)
            
        cursor.execute(query, tuple(params))
        template = cursor.fetchone()
        
        if template:
            template_data = {
                "template_id": str(template[0]),
                "template_name": template[1],
                "template_type": template[2],
                "content": template[3],
                "system_prompt": template[4],
                "business_id": str(template[5]) if template[5] else None,
                "is_default": template[6],
                "created_at": template[7].isoformat() if template[7] else None,
                "updated_at": template[8].isoformat() if template[8] else None
            }
            return jsonify(template_data), 200
        else:
            # Simplify error message for admin context
            # if business_id:
            #     log.warning(f"Template {template_id} not found for business {business_id}")
            #     return jsonify({"error_code": "NOT_FOUND", "message": "Template not found or access denied for this business"}), 404
            # else:
            log.warning(f"Template {template_id} not found (admin access)")
            return jsonify({"error_code": "NOT_FOUND", "message": "Template not found"}), 404

    except Exception as e:
        log.error(f"Error fetching template {template_id} (admin): {str(e)}", exc_info=True) # Update log
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@templates_bp.route('', methods=['POST'])
@require_api_key
def create_template():
    """Create a new prompt template (Admin Access)."""
    # Remove internal key context logic
    # if not hasattr(g, 'business_id'):
    #     return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    # business_id = g.business_id
    # log.info(f"Creating template for business {business_id}")
    
    conn = None
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400
        
        log.info(f"Admin attempting to create template with data: {data}")
        
        # Validate the structure of the request data using the schema
        validate(data, template_schema)

        # Extract data from payload
        template_id = str(uuid.uuid4())
        business_id = data['business_id'] # Get business_id from payload
        template_name = data['template_name'] 
        content = data['content'] 
        template_type = data['template_type']
        system_prompt = data.get('system_prompt', '') # Optional
        is_default = data.get('is_default', False) # Optional, defaults to False
        
        # Optional: Add sanitization here if needed
        # template_name = sanitize_input(template_name)
        # content = sanitize_input(content)
        # system_prompt = sanitize_input(system_prompt)
        
        # Verify business exists
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1 FROM businesses WHERE business_id = %s", (business_id,))
        if not cursor.fetchone():
            return jsonify({"error_code": "NOT_FOUND", "message": f"Business {business_id} not found"}), 404
            
        # Insert into DB
        cursor.execute(
            """
            INSERT INTO templates 
            (template_id, business_id, template_name, template_type, content, system_prompt, is_default)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
            RETURNING template_id;
            """,
            (template_id, business_id, template_name, template_type, content, system_prompt, is_default)
        )

        result = cursor.fetchone()
        conn.commit()
        log.info(f"Admin created template {result[0]} for business {business_id}")
        return jsonify({"message": "Template created successfully", "template_id": result[0]}), 201

    except ValidationError as e:
        log.error(f"Template creation schema validation error: {str(e)}")
        # Provide specific error detail from e.message
        return jsonify({"error_code": "VALIDATION_ERROR", "message": e.message}), 400
    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error creating template (admin): {str(e)}", exc_info=True)
        # Check for unique constraint violation (e.g., duplicate name for the business)
        if "unique constraint" in str(e).lower() and ("templates_business_id_template_name_key" in str(e).lower() or "templates_pkey" in str(e).lower()): # Check primary or unique key
             return jsonify({"error_code": "CONFLICT", "message": "Template name already exists for this business or ID conflict"}), 409
        # Check FK violation
        if "foreign key constraint" in str(e).lower():
            return jsonify({"error_code": "NOT_FOUND", "message": f"Business ID {business_id} not found or invalid"}), 404
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@templates_bp.route('/<template_id>', methods=['PUT'])
@require_api_key
def update_template(template_id):
    """Updates an existing template (Admin Access)."""
    # Remove internal key context check
    # if not hasattr(g, 'business_id'):
    #     return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    # business_id = g.business_id
    # log.info(f"Updating template {template_id} for business {business_id}")

    if not is_valid_uuid(template_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid template_id format"}), 400

    data = request.get_json()
    if not data:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400

    log.info(f"Admin attempting to update template {template_id} with data: {data}")

    # Simplified validation for admin update: Check which fields are present
    allowed_fields = ['template_name', 'content', 'system_prompt', 'template_type', 'is_default'] 
    update_fields = {}
    validation_errors = []

    for field in allowed_fields:
        if field in data:
            value = data[field]
            # Add specific validation if needed (e.g., type check, format check)
            if field == 'template_name' and (value is None or not str(value).strip()):
                 validation_errors.append("template_name cannot be empty")
            elif field == 'content' and (value is None or not str(value).strip()):
                 validation_errors.append("content cannot be empty")
            elif field == 'template_type' and value not in template_schema['properties']['template_type']['enum']:
                 validation_errors.append(f"Invalid template_type: {value}")
            elif field == 'is_default' and not isinstance(value, bool):
                 validation_errors.append("is_default must be true or false")
                 
            if not any(field in err for err in validation_errors):
                 update_fields[field] = value

    if validation_errors:
        log.warning(f"Template update validation failed (admin) for {template_id}: {validation_errors}")
        return jsonify({"error_code": "VALIDATION_ERROR", "message": ", ".join(validation_errors)}), 400
        
    if not update_fields:
         return jsonify({"error_code": "BAD_REQUEST", "message": "No valid fields provided for update"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Verify template exists before update
        cursor.execute("SELECT 1 FROM templates WHERE template_id = %s", (template_id,))
        if not cursor.fetchone():
            log.warning(f"Update attempted on non-existent template {template_id} by admin")
            return jsonify({"error_code": "NOT_FOUND", "message": "Template not found"}), 404

        set_clause = ", ".join([f"{field} = %s" for field in update_fields])
        params = list(update_fields.values())
        params.append(template_id) # Add template_id for WHERE clause

        # Add updated_at timestamp
        set_clause += ", updated_at = NOW()" 

        query = f"UPDATE templates SET {set_clause} WHERE template_id = %s"

        cursor.execute(query, tuple(params))
        conn.commit()

        if cursor.rowcount == 0:
             log.warning(f"Update affected 0 rows for template {template_id} (admin)")
             # This could mean the template was deleted concurrently
             return jsonify({"error_code": "NOT_FOUND", "message": "Template not found during update attempt"}), 404

        log.info(f"Template {template_id} updated successfully by admin")
        return jsonify({"message": "Template updated successfully", "template_id": template_id}), 200

    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error updating template {template_id} (admin): {str(e)}", exc_info=True)
        # Handle potential unique constraint violations (e.g., name clash within the same business)
        if "unique constraint" in str(e).lower():
            return jsonify({"error_code": "CONFLICT", "message": "Template name conflict occurred during update"}), 409
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@templates_bp.route('/<template_id>', methods=['DELETE'])
@require_api_key
def delete_template(template_id):
    app.logger.debug(f'Delete template request received for template_id: {template_id}')
    
    business_id = request.args.get('business_id')
    if not business_id:
        app.logger.error('No business_id provided in delete template request')
        return jsonify({'error': 'business_id is required'}), 400

    app.logger.debug(f'Attempting to delete template for business_id: {business_id}')

    try:
        # Validate UUID format
        uuid.UUID(template_id)
        uuid.UUID(business_id)
    except ValueError as e:
        app.logger.error(f'Invalid UUID format: {str(e)}')
        return jsonify({'error': 'Invalid UUID format'}), 400

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # First check if template exists and belongs to the business
        cursor.execute(
            "SELECT template_name FROM templates WHERE template_id = %s AND business_id = %s",
            (template_id, business_id)
        )
        template = cursor.fetchone()
        
        if not template:
            app.logger.error(f'Template not found or does not belong to business. template_id: {template_id}, business_id: {business_id}')
            return jsonify({'error': 'Template not found or does not belong to this business'}), 404

        template_name = template[0]
        app.logger.debug(f'Found template to delete: {template_name}')
        
        # Delete the template
        cursor.execute(
            "DELETE FROM templates WHERE template_id = %s AND business_id = %s",
            (template_id, business_id)
        )
        
        if cursor.rowcount == 0:
            app.logger.error(f'Template was found but could not be deleted. template_id: {template_id}, business_id: {business_id}')
            conn.rollback()
            return jsonify({'error': 'Failed to delete template'}), 500
            
        conn.commit()
        app.logger.info(f'Successfully deleted template {template_id} (name: {template_name}) for business {business_id}')
        return '', 204

    except psycopg2.Error as e:
        app.logger.error(f'Database error while deleting template: {str(e)}, template_id: {template_id}, business_id: {business_id}')
        if conn: conn.rollback()
        return jsonify({'error': 'Database error occurred'}), 500
    finally:
        if conn:
            release_db_connection(conn)

================================================================================
File: template_management.py
Path: .\backend\routes\template_management.py
Size: 12035
Modified: 2025-05-02T10:52:20.195563
Created: 2025-03-31T17:53:17.423155
Hash: 85556d25c7e2d6411882a4025cc9844c643505d96c74b3a26b66acb54234e191
Lines: 270
================================================================================
# file: C:\icmp_events_api\routes\template_management.py
import logging
import uuid
from jsonschema import validate, ValidationError
from flask import jsonify, request, Blueprint
from backend.db import get_db_connection, release_db_connection
from backend.routes.utils import sanitize_input  # Corrected relative import
from backend.auth import require_api_key  # Changed to require_api_key
import json

log = logging.getLogger(__name__)

template_admin_bp = Blueprint('template_management', __name__, url_prefix='/admin/templates') # Changed prefix

template_schema = {
  "type": "object",
  "properties": {
      "template_name": {"type": "string", "minLength": 1},
      "content": {"type": "string"},
      "system_prompt": {"type": "string"},
      "business_id": {"type": ["string", "null"], "format": "uuid"}, # Null for global defaults
      "template_type": {"type": "string", "enum": [
          "stage_selection", "data_extraction", "response_generation",
          # Add other types if needed
      ]},
      "is_default": {"type": "boolean"}
  },
  "required": ["template_name", "template_type"]
}


@template_admin_bp.route('/', methods=['POST'])
@require_api_key # Admin action
def admin_create_template():
  """(Admin) Create a new prompt template, potentially a default."""
  conn = None
  try:
      data = request.get_json()
      if not data:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400

      # Basic validation (consider using schemas.py)
      # validate(data, template_schema) 
      if not data.get('template_name') or not data.get('template_type'):
           return jsonify({"error_code": "VALIDATION_ERROR", "message": "template_name and template_type are required"}), 400

      template_id = str(uuid.uuid4())
      template_name = sanitize_input(data['template_name'])
      content = sanitize_input(data.get('content', ''))
      system_prompt = sanitize_input(data.get('system_prompt', ''))
      template_type = sanitize_input(data['template_type'])
      # business_id can be null for global defaults
      business_id = data.get('business_id') 
      is_default = data.get('is_default', False)

      if business_id and not is_valid_uuid(business_id):
          return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format"}), 400

      conn = get_db_connection()
      c = conn.cursor()
      c.execute(
          """
          INSERT INTO templates 
          (template_id, business_id, template_name, template_type, content, system_prompt, is_default)
          VALUES (%s, %s, %s, %s, %s, %s, %s)
          RETURNING template_id;
          """,
          (template_id, business_id, template_name, template_type, content, system_prompt, is_default)
      )
      conn.commit()
      template_id = c.fetchone()[0]
      log.info(f"Admin created template {template_id}")
      return jsonify({"template_id": template_id}), 201

  except ValidationError as e:
      log.error(f"Schema validation error: {str(e)}")
      return jsonify({"error_code": "INVALID_REQUEST", "message": "Invalid request format", "details": str(e)}), 400
  except Exception as e:
      log.error(f"Error in admin_create_template: {str(e)}", exc_info=True)
      if conn: conn.rollback()
      return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
  finally:
      if conn:
          release_db_connection(conn)

@template_admin_bp.route('/', methods=['GET'])
@require_api_key # Admin action
def admin_list_templates():
  """(Admin) Retrieve all prompt templates, with optional filters."""
  # Reuse logic from templates.py GET / if desired, but ensure no business context leak
  business_id_filter = request.args.get('business_id')
  template_type_filter = request.args.get('template_type')
  is_default_filter = request.args.get('is_default')
  log.info(f"Admin listing templates (filters: business={business_id_filter}, type={template_type_filter}, default={is_default_filter})")

  conn = None
  try:
      conn = get_db_connection()
      c = conn.cursor()
      query = """SELECT template_id, business_id, template_name, template_type, is_default, created_at 
                 FROM templates WHERE 1=1"""
      params = []
      if business_id_filter:
          query += " AND business_id = %s"
          params.append(business_id_filter)
      if template_type_filter:
           query += " AND template_type = %s"
           params.append(template_type_filter)
      if is_default_filter is not None:
           is_default = str(is_default_filter).lower() == 'true'
           query += " AND is_default = %s"
           params.append(is_default)
           
      query += " ORDER BY template_name;"
      
      c.execute(query, tuple(params))
      templates = []
      rows = c.fetchall()
      for row in rows:
          templates.append({
              "template_id": str(row[0]),
              "business_id": str(row[1]) if row[1] else None,
              "template_name": row[2],
              "template_type": row[3],
              "is_default": row[4],
              "created_at": row[5].isoformat() if row[5] else None
          })
      return jsonify(templates), 200
  except Exception as e:
      log.error(f"Error in admin_list_templates: {str(e)}", exc_info=True)
      return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
  finally:
      if conn:
          release_db_connection(conn)

@template_admin_bp.route('/<template_id>', methods=['GET'])
@require_api_key # Admin action
def admin_get_template(template_id):
  """(Admin) Retrieve a specific template by ID."""
  if not is_valid_uuid(template_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid template_id format"}), 400
  log.info(f"Admin fetching template {template_id}")

  conn = None
  try:
      conn = get_db_connection()
      c = conn.cursor()
      c.execute("""SELECT template_id, business_id, template_name, template_type, content, system_prompt, is_default, created_at, updated_at
                   FROM templates WHERE template_id = %s;""", (template_id,))
      template_row = c.fetchone()
      
      if not template_row:
          return jsonify({"error_code": "NOT_FOUND", "message": f"Template with ID {template_id} not found"}), 404
      
      template = {
          "template_id": str(template_row[0]),
          "business_id": str(template_row[1]) if template_row[1] else None,
          "template_name": template_row[2],
          "template_type": template_row[3],
          "content": template_row[4],
          "system_prompt": template_row[5] or "",
          "is_default": template_row[6],
          "created_at": template_row[7].isoformat() if template_row[7] else None,
          "updated_at": template_row[8].isoformat() if template_row[8] else None
      }
      return jsonify(template), 200
  except Exception as e:
      log.error(f"Error in admin_get_template for {template_id}: {str(e)}", exc_info=True)
      return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
  finally:
      if conn:
          release_db_connection(conn)

@template_admin_bp.route('/<template_id>', methods=['PUT'])
@require_api_key # Admin action
def admin_update_template(template_id):
    """(Admin) Update an existing template."""
    if not is_valid_uuid(template_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid template_id format"}), 400
    log.info(f"Admin updating template {template_id}")

    conn = None
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error_code": "INVALID_REQUEST", "message": "No data provided"}), 400
        
        conn = get_db_connection()
        c = conn.cursor()
        
        # Check if template exists
        c.execute("SELECT 1 FROM templates WHERE template_id = %s;", (template_id,))
        if not c.fetchone():
            return jsonify({"error_code": "NOT_FOUND", "message": f"Template with ID {template_id} not found"}), 404
        
        # Prepare update fields (admin can update more fields potentially)
        update_fields = {}
        allowed_fields = ['template_name', 'template_type', 'content', 'system_prompt', 'business_id', 'is_default']
        for field in allowed_fields:
             if field in data:
                # Add specific validation if needed (e.g., business_id is UUID or null)
                 if field == 'business_id' and data[field] is not None and not is_valid_uuid(data[field]):
                     return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid business_id format"}), 400
                 if field == 'is_default' and not isinstance(data[field], bool):
                      return jsonify({"error_code": "BAD_REQUEST", "message": "is_default must be boolean"}), 400
                 update_fields[field] = sanitize_input(data[field]) if isinstance(data[field], str) else data[field]
        
        if not update_fields:
             return jsonify({"error_code": "BAD_REQUEST", "message": "No valid fields provided for update"}), 400

        set_clause = ", ".join([f"{field} = %s" for field in update_fields])
        params = list(update_fields.values())
        params.append(template_id) # For WHERE clause

        query = f"UPDATE templates SET {set_clause}, updated_at = NOW() WHERE template_id = %s"
        
        c.execute(query, tuple(params))
        conn.commit()

        if c.rowcount == 0:
            log.warning(f"Admin update affected 0 rows for template {template_id}")
            # Should have been caught by existence check, indicates potential issue
            return jsonify({"error_code": "NOT_FOUND", "message": f"Template with ID {template_id} not found during update"}), 404

        log.info(f"Admin updated template {template_id}")
        return jsonify({"message": "Template updated successfully", "template_id": template_id}), 200

    except Exception as e:
        log.error(f"Error in admin_update_template for {template_id}: {str(e)}", exc_info=True)
        if conn: conn.rollback()
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

@template_admin_bp.route('/<template_id>', methods=['DELETE'])
@require_api_key # Admin action
def admin_delete_template(template_id):
    """(Admin) Delete a template."""
    if not is_valid_uuid(template_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid template_id format"}), 400
    log.info(f"Admin deleting template {template_id}")

    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        
        # Delete the template directly
        c.execute("DELETE FROM templates WHERE template_id = %s;", (template_id,))
        conn.commit()
        
        if c.rowcount == 0:
            return jsonify({"error_code": "NOT_FOUND", "message": f"Template with ID {template_id} not found"}), 404
        
        log.info(f"Admin deleted template {template_id}")
        return jsonify({"message": "Template deleted successfully"}), 200

    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error in admin_delete_template for {template_id}: {str(e)}", exc_info=True)
        if "foreign key constraint" in str(e).lower():
             return jsonify({"error_code": "CONFLICT", "message": "Cannot delete template, it is referenced by other resources (e.g., stages)"}), 409
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        if conn:
            release_db_connection(conn)

# Remove functions moved to templates.py or deprecated
# list_default_templates, list_templates_by_type, list_templates_by_business

================================================================================
File: template_test.py
Path: .\backend\routes\template_test.py
Size: 2665
Modified: 2025-05-10T15:46:28.086530
Created: 2025-05-10T07:26:01.310949
Hash: 001ccdf5130d7b5a9ac0a303128d9941ba4a7dad5ffe3167c7cdd99b1940f9c5
Lines: 66
================================================================================
from flask import Blueprint, request, jsonify
from backend.message_processing.template_service import TemplateService
from backend.message_processing.template_variable_provider import TemplateVariableProvider
from backend.db import get_db_pool
import logging

logger = logging.getLogger(__name__)
bp = Blueprint('template_test', __name__, url_prefix='/api')

@bp.route('/template-test', methods=['POST'])
def test_template():
    try:
        data = request.get_json()
        business_id = data.get('business_id')
        template_content = data.get('template_content')
        test_mode = data.get('test_mode', False)

        if not business_id:
            return jsonify({'error': 'Missing required parameters'}), 400

        if test_mode and not template_content:
            return jsonify({'error': 'Template content is required for testing'}), 400

        # Get database connection
        conn = get_db_pool().getconn()
        try:
            # Initialize services
            variable_provider = TemplateVariableProvider(conn)

            if test_mode:
                # Test single template content
                context = variable_provider.get_test_context(business_id, None)
                result = TemplateService.apply_template(template_content, context)
                return jsonify({
                    'success': True,
                    'content': result
                })
            else:
                # Test all templates for the business/agent
                templates = TemplateService.get_templates(conn, business_id)
                context = variable_provider.get_test_context(business_id, None)
                
                results = {}
                for template in templates:
                    try:
                        substituted_content = TemplateService.apply_template(template, context)
                        results[template['template_type']] = {
                            'content': substituted_content
                        }
                    except Exception as e:
                        logger.error(f"Error processing template {template['template_type']}: {str(e)}")
                        results[template['template_type']] = {
                            'error': str(e)
                        }

                return jsonify({
                    'success': True,
                    'results': results
                })

        finally:
            get_db_pool().putconn(conn)

    except Exception as e:
        logger.error(f"Error in template test: {str(e)}")
        return jsonify({'error': str(e)}), 500 

================================================================================
File: template_variables.py
Path: .\backend\routes\template_variables.py
Size: 14665
Modified: 2025-05-09T23:35:14.370178
Created: 2025-04-12T00:38:47.618367
Hash: 63d87eabd1307c8d067924a6003bd1743085af31fafe89dbdc4643c13804b018
Lines: 301
================================================================================
"""
Template variables API routes.

This module provides endpoints for retrieving information about 
available template variables and their usage.
"""

import logging
from flask import jsonify, request, Blueprint, g
from backend.auth import require_api_key, require_internal_key, validate_internal_key, validate_business_key
from backend.db import get_db_connection, release_db_connection
from backend.message_processing.template_variables import TemplateVariableProvider
import psycopg2.extras

log = logging.getLogger(__name__)

# Create a Blueprint for variable routes
template_variables_bp = Blueprint('template_variables', __name__, url_prefix='/variables')

@template_variables_bp.route('/', methods=['GET', 'POST'])
@require_api_key
def list_or_create_variables():
    """
    GET: Get all available template variables.
    POST: Create a new template variable.
    
    This endpoint returns information about all template variables stored
    in the database, including their descriptions, default values, and categories.
    It also allows creating new template variables.
    
    POST Request body:
        {
            "name": "variable_name",
            "description": "Description of the variable",
            "category": "Category name",
            "example_value": "Example value", // optional
            "default_value": "Default value", // optional
            "resolver_function": "Python code" // optional
        }
    
    Returns:
        GET:
            200 OK: JSON list of template variables
            500 Error: If a server error occurs
        POST:
            201 Created: JSON object with the created variable
            400 Bad Request: If the request is invalid
            500 Error: If a server error occurs
    """
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
            
            if request.method == 'GET':
                log.info("Admin listing all template variables")
                cursor.execute("""
                    SELECT 
                        variable_id, variable_name, description, 
                        default_value, example_value, category, is_dynamic
                    FROM template_variables
                    ORDER BY category, variable_name
                """)
                variables = cursor.fetchall()
                # Format results (add is_registered)
                formatted_vars = []
                for var in variables:
                    var['is_registered'] = TemplateVariableProvider.is_variable_registered(var['variable_name'])
                    formatted_vars.append(var)
                return jsonify(formatted_vars), 200
            
            elif request.method == 'POST':
                log.info("Admin creating/updating template variable")
                if not request.is_json:
                    return jsonify({"error": "Request must be JSON"}), 400
                data = request.get_json()
                if 'name' not in data or 'description' not in data or 'category' not in data:
                    return jsonify({"error": "name, description, and category are required"}), 400
                
                variable_name = data['name']
                description = data['description']
                category = data['category']
                default_value = data.get('default_value')
                example_value = data.get('example_value')
                is_dynamic = data.get('is_dynamic', False)
                
                cursor.execute("SELECT variable_id FROM template_variables WHERE variable_name = %s", (variable_name,))
                existing = cursor.fetchone()
                
                if existing:
                    # Update existing
                    cursor.execute("""
                        UPDATE template_variables
                        SET description = %s, default_value = %s, example_value = %s, category = %s, is_dynamic = %s, updated_at = CURRENT_TIMESTAMP
                        WHERE variable_name = %s
                        RETURNING variable_id, variable_name, description, default_value, example_value, category, is_dynamic
                    """, (description, default_value, example_value, category, is_dynamic, variable_name))
                    updated_var = cursor.fetchone()
                    conn.commit()
                    log.info(f"Admin updated template variable: {variable_name}")
                    updated_var['message'] = "Variable updated successfully"
                    return jsonify(updated_var), 200
                else:
                    # Insert new
                    cursor.execute("""
                        INSERT INTO template_variables (variable_name, description, default_value, example_value, category, is_dynamic)
                        VALUES (%s, %s, %s, %s, %s, %s)
                        RETURNING variable_id, variable_name, description, default_value, example_value, category, is_dynamic
                    """, (variable_name, description, default_value, example_value, category, is_dynamic))
                    new_var = cursor.fetchone()
                    conn.commit()
                    log.info(f"Admin created new template variable: {variable_name}")
                    new_var['message'] = "Variable created successfully"
                    return jsonify(new_var), 201
    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error processing template variables (admin): {str(e)}", exc_info=True)
        return jsonify({"error": "Failed to process template variables", "details": str(e)}), 500
    finally:
        if conn: release_db_connection(conn)

@template_variables_bp.route('/<variable_id>/', methods=['DELETE'])
@require_api_key
def delete_variable(variable_id):
    """
    Delete a template variable.
    
    Args:
        variable_id: UUID of the variable to delete
    
    Returns:
        200 OK: JSON object with success message
        404 Not Found: If the variable is not found
        500 Error: If a server error occurs
    """
    log.info(f"Admin attempting to delete template variable {variable_id}")
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
            cursor.execute("SELECT variable_name FROM template_variables WHERE variable_id = %s", (variable_id,))
            variable = cursor.fetchone()
            if not variable:
                return jsonify({"error": "Variable not found"}), 404
            variable_name = variable['variable_name']
            # TODO: Add check if variable is used in templates before deleting?
            cursor.execute("DELETE FROM template_variables WHERE variable_id = %s", (variable_id,))
            conn.commit()
            log.info(f"Admin deleted template variable: {variable_name} (ID: {variable_id})")
            return jsonify({"message": f"Variable '{variable_name}' deleted successfully"}), 200
    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error deleting template variable {variable_id} (admin): {str(e)}", exc_info=True)
        return jsonify({"error": "Failed to delete variable", "details": str(e)}), 500
    finally:
        if conn: release_db_connection(conn)

@template_variables_bp.route('/available/', methods=['GET'])
def list_registered_variables():
    """List variables registered in the TemplateVariableProvider."""
    try:
        # Get authentication context
        auth_header = request.headers.get("Authorization")
        provided_key = None
        if auth_header and auth_header.startswith("Bearer "):
            provided_key = auth_header.split(" ", 1)[1]

        # Get all registered variables
        provider = TemplateVariableProvider()
        all_vars = provider.get_all_variable_names()
        
        # Filter variables based on their individual authentication requirements
        available_vars = []
        for var_name in all_vars:
            var_info = provider.get_provider(var_name)
            auth_req = var_info.get('auth_requirement', 'internal_key')
            
            if auth_req == 'none':
                # No authentication required
                available_vars.append(var_name)
            elif auth_req == 'business_key' and provided_key:
                # Check if it's a valid business key
                if validate_business_key(provided_key):
                    available_vars.append(var_name)
            elif auth_req == 'internal_key' and provided_key:
                # Check if it's a valid internal key
                if validate_internal_key(provided_key):
                    available_vars.append(var_name)
        
        return jsonify(available_vars), 200
    except Exception as e:
        log.error(f"Error listing registered variables: {str(e)}", exc_info=True)
        return jsonify({"error": "Failed to list registered variables", "details": str(e)}), 500

@template_variables_bp.route('/by-template/<template_id>/', methods=['GET'])
@require_internal_key
def list_template_variables(template_id):
    """List variables used by a specific template."""
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Fetching variables for template {template_id} for business {business_id}")

    conn = None
    try:
        conn = get_db_connection()
        # Use RealDictCursor
        with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
            # Verify template belongs to the business
            cursor.execute("SELECT content FROM templates WHERE template_id = %s AND business_id = %s", (template_id, business_id))
            template_row = cursor.fetchone()
            if not template_row:
                return jsonify({"error": "Template not found or not authorized"}), 404
            
            template_content = template_row['content'] or ""
            provider = TemplateVariableProvider(business_id=business_id)
            # Find variables used in the template content
            used_variable_names = provider.find_variables_in_text(template_content)
            
            # Fetch details for used variables
            if not used_variable_names:
                 return jsonify([]), 200
                 
            query = """SELECT variable_id, variable_name, description, default_value, example_value, category, is_dynamic
                       FROM template_variables WHERE variable_name = ANY(%s)"""
            cursor.execute(query, (list(used_variable_names),))
            variables = cursor.fetchall()
            # Add registration status
            formatted_vars = []
            for var in variables:
                var['is_registered'] = TemplateVariableProvider.is_variable_registered(var['variable_name'])
                formatted_vars.append(var)
            return jsonify(formatted_vars), 200

    except Exception as e:
        log.error(f"Error fetching variables for template {template_id}, business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error": f"Failed to list template variables: {str(e)}"}), 500
    finally:
        if conn: release_db_connection(conn)

@template_variables_bp.route('/validate-template/', methods=['POST'])
@require_internal_key
def validate_template_variables():
    """Validate if all variables in a template text are available."""
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id

    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400
    data = request.get_json()
    template_text = data.get('template_text', '')
    log.info(f"Validating template variables for business {business_id}")

    try:
        provider = TemplateVariableProvider(business_id=business_id)
        is_valid, missing_vars, unknown_vars = provider.validate_template_variables(template_text)
        return jsonify({
            "is_valid": is_valid,
            "missing_variables": list(missing_vars),
            "unknown_variables": list(unknown_vars)
        }), 200
    except Exception as e:
        log.error(f"Error validating template variables for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error": "Failed to validate template", "details": str(e)}), 500

@template_variables_bp.route('/test-substitution/', methods=['POST', 'OPTIONS'])
@require_internal_key
def test_variable_substitution():
    """Test substituting variables in a template text with sample data."""
    # Get business context from g
    if not hasattr(g, 'business_id'):
        log.error("Business context (g.business_id) not found after @require_internal_key.")
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id

    if request.method == 'OPTIONS':
        # Handle CORS preflight
        return jsonify(success=True), 200

    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400
    data = request.get_json()
    template_text = data.get('template_text', '')
    context_data = data.get('context_data', {}) # Optional context data
    log.info(f"Testing variable substitution for business {business_id}")

    try:
        provider = TemplateVariableProvider(business_id=business_id)
        substituted_text, errors = provider.substitute_variables_with_context(template_text, context_data)
        return jsonify({
            "substituted_text": substituted_text,
            "errors": errors # Dictionary of variable names to error messages
        }), 200
    except Exception as e:
        log.error(f"Error testing variable substitution for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error": "Failed to test substitution", "details": str(e)}), 500

================================================================================
File: tests.py
Path: .\backend\routes\tests.py
Size: 1241
Modified: 2025-05-02T10:52:20.219997
Created: 2025-03-31T17:53:17.454117
Hash: 8eb9052081c6370d99b3e01435f7aff2fb0eccd8b3142d5513934fb509269ce1
Lines: 32
================================================================================
# tests.py
import unittest
import json
import os
from jsonschema import ValidationError
from app import app, SCHEMAS  # Import Flask app and schemas
from db import get_db_connection # Import get_db_connection

class TestICMP(unittest.TestCase):

    def setUp(self):
        self.app = app.test_client()
        self.app.testing = True

    def test_message_endpoint_validation(self):
        # Send an invalid POST request to /message (missing required field)
        invalid_payload = {
            "user_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
            "message": "Help"
        }
        with self.app as client:
            response = client.post('/message', json=invalid_payload, headers={'Authorization': 'Bearer cd0fd3314e8f1fe7cef737db4ac21778ccc7d5a97bbb33d9af17612e337231d6'})

        self.assertEqual(response.status_code, 400)
        data = json.loads(response.get_data(as_text=True))
        self.assertEqual(data["error_code"], "INVALID_REQUEST")
        self.assertIn("is a required property", data["details"]) #changed to error code instead of error
        self.assertIn("business_id", data["details"]) #check if error is business id


if __name__ == '__main__':
    unittest.main()

================================================================================
File: test_imports.py
Path: .\backend\routes\test_imports.py
Size: 754
Modified: 2025-05-02T10:52:20.228271
Created: 2025-03-31T17:53:17.444135
Hash: 74f9427123f65af20150dc7c34e4e7946a40dae62ba326d47feaf979434754d3
Lines: 22
================================================================================
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

try:
    from routes.businesses import bp
    print("SUCCESS: Imported bp from businesses.py")
    print(f"Blueprint details: name={bp.name}, url_prefix={bp.url_prefix}")
except ImportError as e:
    print(f"FAILED: {str(e)}")
    print("Trying to debug...")
    
    from importlib.util import find_spec
    print(f"Module found: {find_spec('routes.businesses')}")
    
    if find_spec('routes.businesses'):
        from routes import businesses
        print(f"Contents of businesses.py: {dir(businesses)}")
        if hasattr(businesses, 'bp'):
            print("Blueprint exists but couldn't be imported directly!")

================================================================================
File: transitions.py
Path: .\backend\routes\transitions.py
Size: 7380
Modified: 2025-05-02T10:52:20.236489
Created: 2025-04-03T00:20:38.082103
Hash: 8379ba05d52461250e2253717eac5390bfe90e0ca34ae3e85bb304810b0d5bad
Lines: 165
================================================================================
# routes/transitions.py
from flask import Blueprint, request, jsonify, g
from db import get_db_connection, release_db_connection
import uuid
import logging
from auth import require_internal_key
from .utils import is_valid_uuid
import json

log = logging.getLogger(__name__)

transitions_bp = Blueprint('transitions', __name__, url_prefix='/transitions')

@transitions_bp.route('/by-stage/<stage_id>', methods=['GET'])
@require_internal_key
def get_transitions_for_stage(stage_id):
    if not hasattr(g, 'business_id'):
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Fetching transitions for stage {stage_id} in business {business_id}")

    if not is_valid_uuid(stage_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid stage_id format"}), 400
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Verify stage belongs to business first
        cursor.execute("SELECT 1 FROM stages WHERE stage_id = %s AND business_id = %s", (stage_id, business_id))
        if not cursor.fetchone():
            return jsonify({"error_code": "NOT_FOUND", "message": "Stage not found or access denied"}), 404
        
        # Fetch transitions
        cursor.execute("""
            SELECT transition_id, from_stage_id, to_stage_id, conditions, priority 
            FROM stage_transitions 
            WHERE from_stage_id = %s 
            ORDER BY priority ASC
            """, (stage_id,))
        transitions = cursor.fetchall()
        transition_list = [
            {
                "transition_id": str(row[0]),
                "from_stage_id": str(row[1]),
                "to_stage_id": str(row[2]),
                "conditions": row[3], # Assuming JSONB or TEXT
                "priority": row[4]
            } for row in transitions
        ]
        return jsonify(transition_list), 200

    except Exception as e:
        log.error(f"Error fetching transitions for stage {stage_id}: {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@transitions_bp.route('', methods=['POST'])
@require_internal_key
def create_transition():
    if not hasattr(g, 'business_id'):
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Creating transition for business {business_id}")

    data = request.get_json()
    if not data:
        return jsonify({"error_code": "BAD_REQUEST", "message": "Request must be JSON"}), 400

    # Basic Validation
    required = ['from_stage_id', 'to_stage_id', 'conditions', 'priority']
    if not all(field in data for field in required):
        return jsonify({"error_code": "BAD_REQUEST", "message": f"Missing required fields: {required}"}), 400
    if not is_valid_uuid(data['from_stage_id']) or not is_valid_uuid(data['to_stage_id']):
         return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid stage ID format"}), 400
    if not isinstance(data['priority'], int):
         return jsonify({"error_code": "BAD_REQUEST", "message": "Priority must be an integer"}), 400
    # TODO: Add validation for conditions format (JSON?)

    from_stage_id = data['from_stage_id']
    to_stage_id = data['to_stage_id']
    conditions = data['conditions'] # Consider json.dumps if storing as TEXT
    priority = data['priority']
    transition_id = str(uuid.uuid4())
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Verify both stages belong to the authenticated business
        cursor.execute("SELECT 1 FROM stages WHERE stage_id = %s AND business_id = %s", (from_stage_id, business_id))
        if not cursor.fetchone():
            return jsonify({"error_code": "NOT_FOUND", "message": f"From stage {from_stage_id} not found or access denied"}), 404
        cursor.execute("SELECT 1 FROM stages WHERE stage_id = %s AND business_id = %s", (to_stage_id, business_id))
        if not cursor.fetchone():
            return jsonify({"error_code": "NOT_FOUND", "message": f"To stage {to_stage_id} not found or access denied"}), 404

        # Insert the transition
        cursor.execute("""
            INSERT INTO stage_transitions (transition_id, from_stage_id, to_stage_id, conditions, priority)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING transition_id;
        """, (
            transition_id,
            from_stage_id,
            to_stage_id,
            json.dumps(conditions) if isinstance(conditions, dict) else conditions, # Store as JSON string if dict
            priority
        ))
        result = cursor.fetchone()
        conn.commit()
        log.info(f"Transition {result[0]} created from {from_stage_id} to {to_stage_id} for business {business_id}")
        return jsonify({"message": "Transition created successfully", "transition_id": result[0]}), 201

    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error creating transition for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@transitions_bp.route('/<transition_id>', methods=['DELETE'])
@require_internal_key
def delete_transition(transition_id):
    if not hasattr(g, 'business_id'):
        return jsonify({"error_code": "SERVER_ERROR", "message": "Authentication context missing"}), 500
    business_id = g.business_id
    log.info(f"Deleting transition {transition_id} for business {business_id}")

    if not is_valid_uuid(transition_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid transition_id format"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Verify the transition belongs to a stage within the authenticated business
        cursor.execute("""
            DELETE FROM stage_transitions st
            USING stages s
            WHERE st.transition_id = %s 
            AND st.from_stage_id = s.stage_id 
            AND s.business_id = %s
        """, (transition_id, business_id))
        conn.commit()

        if cursor.rowcount == 0:
             log.warning(f"Delete attempted on non-existent or unauthorized transition {transition_id} for business {business_id}")
             return jsonify({"error_code": "NOT_FOUND", "message": "Transition not found or access denied"}), 404
        
        log.info(f"Transition {transition_id} deleted successfully for business {business_id}")
        return jsonify({"message": "Transition deleted successfully"}), 200

    except Exception as e:
        if conn: conn.rollback()
        log.error(f"Error deleting transition {transition_id} for business {business_id}: {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

================================================================================
File: users.py
Path: .\backend\routes\users.py
Size: 4663
Modified: 2025-05-02T10:52:20.236489
Created: 2025-03-31T17:53:17.476049
Hash: 7b651dc9d54209b92da9a1b6bc6c5f3c98bdec309b9ed8867b20b13a1c2d0897
Lines: 120
================================================================================
from flask import Blueprint, jsonify, request, g
import uuid
import logging
from jsonschema import validate, ValidationError
from backend.db import get_db_connection, release_db_connection
from backend.auth import require_api_key
from backend.routes.utils import is_valid_uuid

log = logging.getLogger(__name__)

# Rename to match naming convention of other blueprints
bp = Blueprint('users', __name__, url_prefix='/admin/users')

user_schema = {
    "type": "object",
    "properties": {
        "first_name": {"type": "string"},
        "last_name": {"type": "string"},
        "email": {"type": "string", "format": "email"}
    },
    "required": ["first_name", "last_name", "email"]
}

@bp.route('', methods=['POST'])
# Note: Keeping authentication commented out like in archived code
# @require_api_key
def create_user():
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400
    
    data = request.get_json()
    try:
        validate(data, user_schema)
    except ValidationError as e:
        return jsonify({"error_code": "INVALID_REQUEST", "message": "Invalid request format", "details": str(e)}), 400

    user_id = str(uuid.uuid4())
    conn = get_db_connection()
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO users (user_id, first_name, last_name, email)
            VALUES (%s, %s, %s, %s)
            RETURNING user_id;
        """, (user_id, data["first_name"], data["last_name"], data["email"]))
        result = c.fetchone()
        conn.commit()
        log.info({"message": "User created", "user_id": user_id})
        # Handle both dictionary-like and tuple-like cursor results
        user_id_result = result[0] if isinstance(result, tuple) else result["user_id"] if "user_id" in result else user_id
        return jsonify({"user_id": user_id_result}), 201
    except Exception as e:
        conn.rollback()
        log.error(f"Error in create_user: {str(e)}")
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        release_db_connection(conn)

@bp.route('', methods=['GET'])
@require_api_key
def get_users():
    log.info("Admin fetching all users")
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT user_id, first_name, last_name, email, phone, created_at FROM users ORDER BY last_name, first_name")
        users = cursor.fetchall()
        user_list = [
            {
                "user_id": str(row[0]),
                "first_name": row[1],
                "last_name": row[2],
                "email": row[3],
                "phone": row[4],
                "created_at": row[5].isoformat() if row[5] else None
            } for row in users
        ]
        return jsonify(user_list), 200
    except Exception as e:
        log.error(f"Error fetching users (admin): {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

@bp.route('/<user_id>', methods=['GET'])
@require_api_key
def get_user(user_id):
    if not is_valid_uuid(user_id):
        return jsonify({"error_code": "BAD_REQUEST", "message": "Invalid user_id format"}), 400
    log.info(f"Admin fetching user {user_id}")
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT user_id, first_name, last_name, email, phone, address, created_at, updated_at FROM users WHERE user_id = %s", (user_id,))
        user = cursor.fetchone()
        if user:
            user_data = {
                 "user_id": str(user[0]),
                "first_name": user[1],
                "last_name": user[2],
                "email": user[3],
                "phone": user[4],
                "address": user[5],
                "created_at": user[6].isoformat() if user[6] else None,
                "updated_at": user[7].isoformat() if user[7] else None
            }
            return jsonify(user_data), 200
        else:
             return jsonify({"error_code": "NOT_FOUND", "message": "User not found"}), 404
    except Exception as e:
        log.error(f"Error fetching user {user_id} (admin): {str(e)}", exc_info=True)
        return jsonify({"error_code": "DB_ERROR", "message": f"Database error: {str(e)}"}), 500
    finally:
        if conn:
            release_db_connection(conn)

# Add POST, PUT, DELETE for users if needed, protected by @require_api_key

================================================================================
File: user_management.py
Path: .\backend\routes\user_management.py
Size: 2695
Modified: 2025-05-02T10:52:20.252721
Created: 2025-03-31T17:53:17.465050
Hash: 28bd6f5b61ba0d5f747086080721cb53f4bbeecd9c0c062b82c3236950c50ec6
Lines: 75
================================================================================
from flask import jsonify, request
import uuid
import logging
from jsonschema import validate, ValidationError
from db import get_db_connection, release_db_connection

log = logging.getLogger(__name__)

user_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "string"},
        "first_name": {"type": "string"},
        "last_name": {"type": "string"},
        "email": {"type": "string", "format": "email"}
    },
    "required": ["username", "first_name", "last_name", "email"]
}

def create_user_route(request, get_db_connection):
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400

    data = request.get_json()
    try:
        validate(data, user_schema)
    except ValidationError as e:
        return jsonify({"error_code": "INVALID_REQUEST", "message": "Invalid request format", "details": str(e)}), 400

    user_id = str(uuid.uuid4())
    conn = get_db_connection()
    try:
        c = conn.cursor()
        c.execute(
            """
            INSERT INTO users (user_id, username, first_name, last_name, email)
            VALUES (%s, %s, %s, %s, %s);
            """,
            (user_id, data["username"], data["first_name"], data["last_name"], data["email"])
        )
        conn.commit()
        log.info({"message": "User created", "user_id": user_id})
        return jsonify({"user_id": user_id}), 201
    except Exception as e:
        conn.rollback()
        log.error(f"Error in create_user: {str(e)}")
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        release_db_connection(conn)

def get_users_route(get_db_connection):
    conn = get_db_connection()
    try:
        c = conn.cursor()
        c.execute("SELECT user_id, username, first_name, last_name, email FROM users;")
        users = [{"user_id": row[0], "username": row[1], "first_name": row[2], "last_name": row[3], "email": row[4]} for row in c.fetchall()]
        return jsonify(users), 200
    except Exception as e:
        log.error(f"Error in get_users: {str(e)}")
        return jsonify({"error_code": "SERVER_ERROR", "message": str(e)}), 500
    finally:
        release_db_connection(conn)

def register_user_routes(app, require_api_key, limiter):
    @app.route('/users', methods=['POST'])
    #@require_api_key
    @limiter.limit("10 per minute")
    def create_user():
        return create_user_route(request, get_db_connection)

    @app.route('/users', methods=['GET'])
    @require_api_key
    @limiter.limit("20 per minute")
    def get_users():
        return get_users_route(get_db_connection)

================================================================================
File: user_stats.py
Path: .\backend\routes\user_stats.py
Size: 1072
Modified: 2025-05-10T18:46:53.068063
Created: 2025-05-10T18:39:44.420245
Hash: edb43a59f2fe30e2afe5f18dcf97afc0bc7a0953a4cfead926afd62e17ddf8b2
Lines: 30
================================================================================
from flask import Blueprint, request, jsonify
from backend.db import get_db_connection, release_db_connection
from backend.auth import require_api_key

bp = Blueprint('user_stats', __name__, url_prefix='/api/user-stats')

@bp.route('/message-counts', methods=['GET'])
@require_api_key
def get_user_message_counts():
    business_id = request.args.get('business_id')
    if not business_id:
        return jsonify({'error': 'Missing business_id'}), 400
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        cursor.execute(
            '''
            SELECT m.user_id, COUNT(*) as message_count
            FROM messages m
            JOIN conversations c ON m.conversation_id = c.conversation_id
            WHERE c.business_id = %s
            GROUP BY m.user_id
            ''',
            (business_id,)
        )
        results = cursor.fetchall()
        data = [{'user_id': str(row[0]), 'message_count': row[1]} for row in results]
        return jsonify(data)
    finally:
        release_db_connection(conn) 

================================================================================
File: utils.py
Path: .\backend\routes\utils.py
Size: 571
Modified: 2025-05-02T10:52:20.252721
Created: 2025-03-31T19:35:12.145909
Hash: 3e4984628b0674564bb7fcda4266c0765895d545aef8278d4cc0c7347cd12326
Lines: 21
================================================================================
# utils.py
import uuid

def is_valid_uuid(uuid_string):
    """
    Check if a string is a valid UUID.
    """
    try:
        uuid.UUID(uuid_string)
        return True
    except ValueError:
        return False

def sanitize_input(input_string):
    """
    Sanitizes a string to prevent basic injection attacks.
    This is a VERY basic example and should be expanded for real-world use.
    """
    if not isinstance(input_string, str):
        return ""  # Or raise an exception
    return input_string.replace("<", "&lt;").replace(">", "&gt;")

================================================================================
File: __init__.py
Path: .\backend\routes\__init__.py
Size: 918
Modified: 2025-05-02T10:52:20.260957
Created: 2025-03-31T17:53:17.292128
Hash: 50e43bde12ce44fb718a674239686c6c407d3c4d7add62ffb5369439aeee99ea
Lines: 27
================================================================================
# file: C:\icmp_events_api\backend\routes\__init__.py
# This file can optionally be used to expose blueprints 
# but avoid importing 'app' here to prevent circular dependencies.

import logging

# Import blueprints so they can be accessed via routes.<n>
from . import businesses
from . import conversations
from . import health
from . import message_handling
from . import ping
from . import stages
from . import template_management
from . import users
from . import templates
from . import agents
from . import business_management # Still need to import the module
from . import transitions  # Add the transitions module
from . import debug

log = logging.getLogger(__name__)

# print("Executing routes/__init__.py") # Keep for debugging if needed, remove later

# DO NOT register blueprints here using an imported 'app' object.
# Registration should happen in app.py AFTER 'app' is created.

================================================================================
File: conversation_summary_service.py
Path: .\backend\services\conversation_summary_service.py
Size: 5566
Modified: 2025-05-02T10:52:20.260957
Created: 2025-04-14T14:06:18.967860
Hash: c694d9e88039080285d21cb82f4ec681f1cbef1d4190fba8500618a4ec1860d7
Lines: 146
================================================================================
"""
Service for generating and managing conversation summaries.
"""

import json
import logging
from typing import Dict, Any, Optional
from pathlib import Path

log = logging.getLogger(__name__)

class ConversationSummaryService:
    """Service for generating and managing conversation summaries."""
    
    def __init__(self, template_path: str = None):
        """
        Initialize the conversation summary service.
        
        Args:
            template_path: Path to the template file. If None, uses default path.
        """
        if template_path is None:
            template_path = Path(__file__).parent.parent / 'templates' / 'conversation_summary_template.txt'
        
        self.template_path = Path(template_path)
        if not self.template_path.exists():
            raise FileNotFoundError(f"Template file not found at {template_path}")
            
        with open(self.template_path, 'r') as f:
            self.template = f.read()
    
    def generate_summary(self, conversation_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate a summary for a conversation.
        
        Args:
            conversation_data: Dictionary containing conversation information:
                - business_name: Name of the business
                - user_name: Name of the user
                - conversation_id: UUID of the conversation
                - start_time: Start time of the conversation
                - last_updated: Last update time of the conversation
                - conversation_history: List of messages in the conversation
                
        Returns:
            Dictionary containing the structured summary
        """
        try:
            # Format the conversation history
            formatted_history = self._format_conversation_history(
                conversation_data.get('conversation_history', [])
            )
            
            # Prepare the prompt
            prompt = self.template.format(
                business_name=conversation_data.get('business_name', 'Unknown Business'),
                user_name=conversation_data.get('user_name', 'Unknown User'),
                conversation_id=conversation_data.get('conversation_id', 'Unknown'),
                start_time=conversation_data.get('start_time', 'Unknown'),
                last_updated=conversation_data.get('last_updated', 'Unknown'),
                conversation_history=formatted_history
            )
            
            # Import here to avoid circular imports
            from backend.ai.llm_service import LLMService
            
            # Initialize LLM service
            llm_service = LLMService()
            
            # Call LLM service to generate summary
            summary_response = llm_service.generate_response(
                business_id=conversation_data.get('business_id'),
                input_text=formatted_history,
                system_prompt=prompt,
                call_type="summary"
            )
            
            # Parse JSON response
            try:
                summary = json.loads(summary_response)
                return summary
            except json.JSONDecodeError as e:
                log.error(f"Error parsing summary JSON: {str(e)}")
                # Return a fallback summary
                return {
                    "overview": "Unable to generate structured summary",
                    "key_points": [],
                    "decisions": [],
                    "pending_items": [],
                    "next_steps": [],
                    "sentiment": "neutral",
                    "confidence_score": 0.0
                }
            
        except Exception as e:
            log.error(f"Error generating conversation summary: {str(e)}")
            raise
    
    def _format_conversation_history(self, messages: list) -> str:
        """
        Format conversation messages into a readable string.
        
        Args:
            messages: List of message dictionaries with 'sender' and 'content' keys
            
        Returns:
            Formatted string of the conversation
        """
        formatted_messages = []
        for msg in messages:
            sender = msg.get('sender', 'Unknown')
            content = msg.get('content', '')
            timestamp = msg.get('timestamp', '')
            formatted_messages.append(f"{sender} ({timestamp}): {content}")
        
        return "\n".join(formatted_messages)
    
    def save_summary(self, conn, conversation_id: str, summary: Dict[str, Any]) -> bool:
        """
        Save the generated summary to the database.
        
        Args:
            conn: Database connection
            conversation_id: UUID of the conversation
            summary: Dictionary containing the summary
            
        Returns:
            True if successful, False otherwise
        """
        try:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE conversations 
                SET conversation_summary = %s
                WHERE conversation_id = %s
                """,
                (json.dumps(summary), conversation_id)
            )
            conn.commit()
            return True
            
        except Exception as e:
            log.error(f"Error saving conversation summary: {str(e)}")
            conn.rollback()
            return False

================================================================================
File: test_auth.py
Path: .\backend\tests\test_auth.py
Size: 7598
Modified: 2025-05-02T10:52:20.277359
Created: 2025-04-02T00:08:15.562807
Hash: 3da49a464632fe24b314ac0ae66a0330b98b28d5033841e64c829b2cd4355115
Lines: 206
================================================================================
import pytest
from flask import Flask, jsonify, request
from auth import require_api_key, require_business_api_key
from unittest.mock import patch
import json
from unittest.mock import MagicMock

@pytest.fixture
def app():
    app = Flask(__name__)
    # Use relative path for imports within backend
    from db import CONNECTION_POOL
    app.config.update({
        "TESTING": True,
        "ICMP_API_KEY": "test_master_key_456",
        "APPLICATION_ROOT": "/"
    })
    # Register routes needed for testing decorators if any
    # Example placeholder route:
    @app.route('/_test/biz/<business_id>')
    def placeholder_biz_route(business_id):
        return 'OK'
    @app.route('/_test/no_biz_id')
    def placeholder_no_biz_route():
        return 'OK'
    return app

@pytest.fixture
def client(app):
    return app.test_client()

def test_require_api_key_valid_cookie(app, client):
    @app.route('/test_master_cookie')
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})
    # Set cookie before request
    client.set_cookie('icmpApiKey', 'test_master_key_456')
    response = client.get('/test_master_cookie')
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'success'

def test_require_api_key_valid_header(app, client):
    @app.route('/test_master_header')
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    response = client.get('/test_master_header',
                         headers={'Authorization': 'Bearer test_master_key_456'})
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'success'

def test_require_api_key_invalid(app, client):
    @app.route('/test_master_invalid')
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    response = client.get('/test_master_invalid',
                         headers={'Authorization': 'Bearer wrong_key'})
    assert response.status_code == 401
    assert json.loads(response.data)['error_code'] == 'UNAUTHORIZED'

def test_require_api_key_missing(app, client):
    @app.route('/test_master_missing')
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    response = client.get('/test_master_missing')
    assert response.status_code == 401
    assert json.loads(response.data)['error_code'] == 'UNAUTHORIZED'

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
def test_require_business_key_valid_cookie(mock_get_conn, mock_release, app, client):
    mock_conn = MagicMock()
    mock_cursor = MagicMock()
    mock_get_conn.return_value = mock_conn
    mock_conn.cursor.return_value = mock_cursor
    mock_cursor.fetchone.return_value = (1,)

    @app.route('/biz/<business_id>/resource')
    @require_business_api_key
    def biz_route(business_id):
        return jsonify({"message": "success", "business": business_id})

    business_id = 'biz_123'
    business_key = 'valid_biz_key_abc'

    # Set cookie before request
    client.set_cookie('businessApiKey', business_key)
    response = client.get(f'/biz/{business_id}/resource')

    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'success'
    assert json.loads(response.data)['business'] == business_id
    mock_get_conn.assert_called_once()
    mock_cursor.execute.assert_called_once_with(
        "SELECT 1 FROM businesses WHERE business_id = %s AND api_key = %s",
        (business_id, business_key)
    )
    mock_cursor.fetchone.assert_called_once()
    mock_release.assert_called_once_with(mock_conn)

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
def test_require_business_key_valid_header(mock_get_conn, mock_release, app, client):
    mock_conn = mock_get_conn.return_value
    mock_cursor = mock_conn.cursor.return_value
    mock_cursor.fetchone.return_value = (1,)

    @app.route('/biz_h/<business_id>/resource')
    @require_business_api_key
    def biz_route_h(business_id):
        return jsonify({"message": "success", "business": business_id})

    business_id = 'biz_456'
    business_key = 'valid_biz_key_def'

    response = client.get(
        f'/biz_h/{business_id}/resource',
        headers={'Authorization': f'Bearer {business_key}'}
    )

    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'success'
    mock_cursor.execute.assert_called_once_with(
        "SELECT 1 FROM businesses WHERE business_id = %s AND api_key = %s",
        (business_id, business_key)
    )
    mock_release.assert_called_once_with(mock_conn)

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
def test_require_business_key_invalid_key(mock_get_conn, mock_release, app, client):
    mock_conn = mock_get_conn.return_value
    mock_cursor = mock_conn.cursor.return_value
    mock_cursor.fetchone.return_value = None

    @app.route('/biz_inv/<business_id>/resource')
    @require_business_api_key
    def biz_route_inv(business_id):
        return jsonify({"message": "success", "business": business_id})

    business_id = 'biz_789'
    invalid_key = 'invalid_key'

    # Set cookie before request
    client.set_cookie('businessApiKey', invalid_key)
    response = client.get(f'/biz_inv/{business_id}/resource')

    assert response.status_code == 401
    assert json.loads(response.data)['error_code'] == 'UNAUTHORIZED'
    assert 'Invalid Business API key' in json.loads(response.data)['message']
    mock_cursor.execute.assert_called_once_with(
        "SELECT 1 FROM businesses WHERE business_id = %s AND api_key = %s",
        (business_id, invalid_key)
    )
    mock_release.assert_called_once_with(mock_conn)

def test_require_business_key_missing_biz_id(app, client):
    @app.route('/biz_no_id/resource')
    @require_business_api_key
    def biz_route_no_id():
        return jsonify({"message": "success"})

    business_key = 'some_key'

    # Set cookie before request
    client.set_cookie('businessApiKey', business_key)
    response = client.get('/biz_no_id/resource')

    assert response.status_code == 400
    assert json.loads(response.data)['error_code'] == 'BAD_REQUEST'
    assert 'Business ID is required' in json.loads(response.data)['message']

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
def test_require_business_key_db_error(mock_get_conn, mock_release, app, client):
    """Test handling of database error in business API key validation."""
    # Set up the mock to raise an exception
    mock_get_conn.side_effect = Exception("DB connection failed")

    @app.route('/biz_dberr/<business_id>/resource')
    @require_business_api_key
    def biz_route_dberr(business_id):
        return jsonify({"message": "success", "business": business_id})

    business_id = 'biz_err'
    business_key = 'key_for_err'

    # Set cookie before request
    client.set_cookie('businessApiKey', business_key)
    
    # Use try/except to catch the exception and verify it's handled correctly
    try:
        response = client.get(f'/biz_dberr/{business_id}/resource')
    except Exception as e:
        # The exception should be caught by the decorator and return a 500 error
        assert str(e) == "DB connection failed"
        return
    
    # If we get here, the test should fail
    assert False, "Expected an exception to be raised"

================================================================================
File: test_auth_decorator.py
Path: .\backend\tests\test_auth_decorator.py
Size: 3465
Modified: 2025-05-02T10:52:20.277359
Created: 2025-04-02T00:09:05.787472
Hash: 0a3b92dc7716bfe5dd8288b505451c44558c5be60e35ae98ed13f59c21a35aa2
Lines: 103
================================================================================
import pytest
from flask import Flask, request, jsonify
from auth import require_api_key
import json

@pytest.fixture
def app():
    app = Flask(__name__)
    app.config['ICMP_API_KEY'] = 'test_api_key_123'
    return app

@pytest.fixture
def client(app):
    return app.test_client()

def test_valid_api_key_in_cookie(app, client):
    @app.route('/test', methods=['POST'])
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    # Set cookie before request
    client.set_cookie('icmpApiKey', 'test_api_key_123')
    response = client.post('/test', json={'data': 'test'})

    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'success'

def test_valid_api_key_in_header(app, client):
    @app.route('/test', methods=['POST'])
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    response = client.post('/test',
                         headers={'Authorization': 'Bearer test_api_key_123'},
                         json={'data': 'test'})
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'success'

def test_invalid_api_key(app, client):
    @app.route('/test', methods=['POST'])
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    # Set cookie before request
    client.set_cookie('icmpApiKey', 'wrong_key')
    response = client.post('/test', json={'data': 'test'})

    assert response.status_code == 401
    assert json.loads(response.data)['error_code'] == 'UNAUTHORIZED'

def test_missing_api_key(app, client):
    @app.route('/test', methods=['POST'])
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    response = client.post('/test',
                         json={'data': 'test'})
    assert response.status_code == 401
    assert json.loads(response.data)['error_code'] == 'UNAUTHORIZED'

def test_missing_config_api_key(app):
    app = Flask(__name__)
    # Don't set ICMP_API_KEY in config

    @app.route('/test', methods=['POST'])
    @require_api_key
    def test_route():
        return jsonify({"message": "success"})

    client = app.test_client()
    # Set cookie before request
    client.set_cookie('icmpApiKey', 'test_api_key_123')
    response = client.post('/test', json={'data': 'test'})

    assert response.status_code == 500
    assert json.loads(response.data)['error_code'] == 'CONFIG_ERROR'

def test_validate_config_with_valid_credentials(app, client):
    @app.route('/validate_config', methods=['POST'])
    @require_api_key
    def validate_config():
        data = request.get_json()
        return jsonify({
            'isValid': True,
            'message': 'Configuration validated successfully'
        })

    # Set cookie before request
    client.set_cookie('icmpApiKey', 'test_api_key_123')
    response = client.post('/validate_config',
                         json={
                             # 'apiKey': 'test_api_key_123', # Assuming master key is from cookie
                             'userId': 'test_user',
                             'businessId': 'test_business',
                             'businessApiKey': 'test_business_key'
                         })

    assert response.status_code == 200
    assert json.loads(response.data)['isValid'] == True

================================================================================
File: test_businesses.py
Path: .\backend\tests\test_businesses.py
Size: 16205
Modified: 2025-05-02T10:52:20.285625
Created: 2025-04-02T13:06:33.549252
Hash: ce88a175016e652844facfbb8108de353406e4bb97ce853b1c0c1ca2b12078e9
Lines: 369
================================================================================
import pytest
import json
import uuid
from unittest.mock import patch, MagicMock
from flask import Flask, jsonify
from datetime import datetime

# Assume Flask app is created similarly to other test files
# If you have a central fixture setup (e.g., in conftest.py), use that.
# Otherwise, define basic app/client fixtures here.

# Mock the blueprint and routes from the actual file
# This avoids direct dependency but requires keeping mocks in sync
from routes import businesses
from auth import require_api_key, require_business_api_key

# Test constants
TEST_BUSINESS_ID = 'a1b7b4a0-9d9b-4b9a-9b0a-1b7b4a0d9b4b'
TEST_BUSINESS_API_KEY = 'biz-key-for-a1b7b4a0'
TEST_USER_ID = str(uuid.uuid4())  # Changed to a valid UUID format
TEST_BUSINESS_DATA = {
    "business_id": TEST_BUSINESS_ID,
    "api_key": TEST_BUSINESS_API_KEY,
    "owner_id": str(uuid.uuid4()),
    "business_name": "Specific Biz",
    "business_description": "Details...",
    "address": "123 Main St",
    "phone_number": "555-1234",
    "website": "http://specific.com"
}

# --- Fixtures ---

@pytest.fixture
def app():
    """Create and configure a new app instance for each test."""
    app = Flask(__name__)
    app.config.update({
        "TESTING": True,
        "ICMP_API_KEY": "test-master-api-key" # Master key for creating businesses
    })
    # Register the blueprints we are testing
    app.register_blueprint(businesses.bp)
    # Import and register the conversations blueprint for conversation tests
    from routes import conversations
    app.register_blueprint(conversations.bp)
    return app

@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()

# --- Test POST /businesses ---

@patch('routes.businesses.get_db_connection')
@patch('routes.businesses.release_db_connection')
@patch('routes.businesses.validate') # Mock jsonschema validation
@patch('routes.businesses.uuid.uuid4', return_value=uuid.UUID('12345678-1234-5678-1234-567812345678')) # Mock UUID generation
@patch('routes.businesses.secrets.token_hex', return_value='generated_business_api_key_123') # Mock secrets
def test_create_business_success(mock_token, mock_uuid, mock_validate, mock_release_db, mock_get_conn, client):
    """Test successful business creation."""
    mock_conn = MagicMock()
    mock_cursor = MagicMock()
    mock_get_conn.return_value = mock_conn
    mock_conn.cursor.return_value = mock_cursor

    valid_data = {
        "owner_id": str(uuid.uuid4()),
        "business_name": "Test Biz",
        "business_description": "A test business",
        "website": "http://test.com"
    }
    headers = {
        'Authorization': 'Bearer test-master-api-key',
        'Content-Type': 'application/json'
    }

    response = client.post('/businesses/', headers=headers, data=json.dumps(valid_data))

    assert response.status_code == 201
    data = response.get_json()
    assert data["message"] == "Business created"
    assert data["business_id"] == '12345678-1234-5678-1234-567812345678'
    assert data["api_key"] == 'generated_business_api_key_123' # Check returned key

    mock_validate.assert_called_once_with(instance=valid_data, schema=businesses.business_schema)
    mock_get_conn.assert_called_once()
    mock_cursor.execute.assert_called_once()
    # Check if api_key was included in the INSERT parameters
    args, _ = mock_cursor.execute.call_args
    assert 'INSERT INTO businesses' in args[0]
    assert args[1][0] == '12345678-1234-5678-1234-567812345678' # business_id
    assert args[1][1] == 'generated_business_api_key_123'      # api_key
    assert args[1][2] == valid_data['owner_id']               # owner_id
    # ... check other params ...
    mock_conn.commit.assert_called_once()
    mock_release_db.assert_called_once_with(mock_conn)

def test_create_business_no_auth(client):
    """Test creating business without master API key."""
    valid_data = {"owner_id": str(uuid.uuid4()), "business_name": "Test Biz"}
    response = client.post('/businesses/', data=json.dumps(valid_data), content_type='application/json')
    assert response.status_code == 401 # require_api_key fails

def test_create_business_invalid_auth(client):
    """Test creating business with invalid master API key."""
    valid_data = {"owner_id": str(uuid.uuid4()), "business_name": "Test Biz"}
    headers = {'Authorization': 'Bearer wrong-key'}
    response = client.post('/businesses/', headers=headers, data=json.dumps(valid_data), content_type='application/json')
    assert response.status_code == 401 # require_api_key fails

@patch('routes.businesses.validate', side_effect=businesses.ValidationError("Missing required property: 'owner_id'"))
def test_create_business_invalid_data(mock_validate, client):
    """Test creating business with invalid/missing data."""
    invalid_data = {"business_name": "Test Biz"} # Missing owner_id
    headers = {'Authorization': 'Bearer test-master-api-key'}
    response = client.post('/businesses/', headers=headers, data=json.dumps(invalid_data), content_type='application/json')
    assert response.status_code == 400
    data = response.get_json()
    assert data["error_code"] == "INVALID_REQUEST"
    assert "Missing required property: 'owner_id'" in data["message"]

# --- Test GET /businesses/{business_id} ---

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.businesses.get_db_connection')
@patch('routes.businesses.release_db_connection')
@patch('routes.businesses.is_valid_uuid', return_value=True)
@patch('routes.businesses.jsonify')
def test_get_business_success(mock_jsonify, mock_is_valid, mock_release_db_route, mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test successful retrieval of a business."""
    # Mock decorator's DB validation to succeed
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = {'business_id': TEST_BUSINESS_ID, 'api_key': TEST_BUSINESS_API_KEY}

    # Mock route's DB fetch
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_conn_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor

    # Mock the database return value with expected business data
    mock_business = {
        'business_id': TEST_BUSINESS_ID,
        'business_name': 'Test Business',
        'api_key': TEST_BUSINESS_API_KEY,
        'owner_id': str(uuid.uuid4()),
        'business_description': 'Description', 
        'address': 'Address',
        'phone_number': 'Phone',
        'website': 'Website',
        'first_stage_id': None
    }
    mock_route_cursor.fetchone.return_value = mock_business
    
    # Let the actual jsonify function be used
    mock_jsonify.side_effect = jsonify

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.get(f'/businesses/{TEST_BUSINESS_ID}?business_id={TEST_BUSINESS_ID}')

    assert response.status_code == 200
    data = response.get_json()
    assert data['business_id'] == TEST_BUSINESS_ID
    assert data['business_name'] == 'Test Business'
    assert data['api_key'] == TEST_BUSINESS_API_KEY

    # Verify database calls
    mock_get_conn_auth.assert_called_once()
    mock_release_auth.assert_called_once_with(mock_auth_conn)
    mock_get_conn_route.assert_called_once()
    mock_release_db_route.assert_called_once_with(mock_route_conn)

@patch('auth.release_db_connection') # Patch release
@patch('auth.get_db_connection') # Patch decorator's DB call (NO backend.)
@patch('routes.businesses.is_valid_uuid', return_value=True)
def test_get_business_no_auth(mock_is_valid, mock_get_conn_auth, mock_release_auth, client):
    """Test getting business without business API key cookie."""
    response = client.get(f'/businesses/{TEST_BUSINESS_ID}') # No cookie
    assert response.status_code == 401
    data = response.get_json()
    assert data["error_code"] == "UNAUTHORIZED"
    assert "Missing Business API key" in data["message"]

@patch('auth.release_db_connection') # Patch release
@patch('auth.get_db_connection') # Patch decorator's DB call (NO backend.)
@patch('routes.businesses.is_valid_uuid', return_value=True)
def test_get_business_invalid_auth(mock_is_valid, mock_get_conn_auth, mock_release_auth, client):
    """Test getting business with invalid business API key."""
    # Mock decorator's DB validation to fail
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = None # Key is invalid

    # Set cookie before request
    client.set_cookie('businessApiKey', 'wrong-key')
    response = client.get(f'/businesses/{TEST_BUSINESS_ID}')

    assert response.status_code == 401
    data = response.get_json()
    assert data["error_code"] == "UNAUTHORIZED"
    assert "Invalid Business API key" in data["message"]
    mock_get_conn_auth.assert_called_once() # Decorator DB check was performed
    mock_release_auth.assert_called_once() # Check release was called

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.businesses.is_valid_uuid', return_value=False)
@patch('routes.businesses.jsonify')
def test_get_business_invalid_id_format(mock_jsonify, mock_is_valid, mock_get_conn_auth, mock_release_auth, client):
    """Test getting business with an invalid UUID format."""
    # Mock the auth decorator's DB validation to fail
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = None  # Invalid key

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)

    # Mock the error response
    mock_response = MagicMock()
    mock_response.status_code = 401
    mock_response.get_json.return_value = {
        'error_code': 'UNAUTHORIZED',
        'message': 'API key'
    }
    mock_jsonify.return_value = mock_response

    response = client.get('/businesses/not-a-uuid')

    assert response.status_code == 401
    data = response.get_json()
    assert data['error_code'] == 'UNAUTHORIZED'
    assert 'API key' in data['message']
    
    # Verify database calls
    mock_get_conn_auth.assert_called_once()
    mock_release_auth.assert_called_once_with(mock_auth_conn)
    # The is_valid_uuid check might be bypassed in the authentication flow, so don't assert on it

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.businesses.get_db_connection')
@patch('routes.businesses.release_db_connection')
@patch('routes.businesses.is_valid_uuid', return_value=True)
def test_get_business_not_found(mock_is_valid, mock_release_db_route, mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test when business is not found."""
    # Mock decorator's DB validation to succeed
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = (1,)  # Key is valid for business

    # Mock route's DB fetch to return None (business not found)
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_conn_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor
    mock_route_cursor.fetchone.return_value = None

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.get(f'/businesses/{TEST_BUSINESS_ID}')

    assert response.status_code == 404
    data = response.get_json()
    assert data['error_code'] == 'NOT_FOUND'
    assert 'business not found' in data['message'].lower()

    mock_get_conn_auth.assert_called_once()
    mock_get_conn_route.assert_called_once()
    mock_release_auth.assert_called_once() # Check auth release
    mock_release_db_route.assert_called_once() # Check route release

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.conversations.get_db_connection')
@patch('routes.conversations.release_db_connection')
@patch('routes.conversations.jsonify')
@patch('routes.conversations.execute_query')  # Add mock for execute_query
def test_get_conversations_success(mock_execute_query, mock_jsonify, mock_release_route, mock_get_route, mock_get_auth, mock_release_auth, client):
    """Test getting conversations for a user."""
    # Mock the auth decorator's DB validation
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = {'business_id': TEST_BUSINESS_ID, 'api_key': TEST_BUSINESS_API_KEY}

    # Mock the route's DB responses
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor

    # Mock conversation data
    mock_conv_row = {
        'conversation_id': str(uuid.uuid4()),
        'business_id': TEST_BUSINESS_ID,
        'user_id': TEST_USER_ID,
        'agent_id': str(uuid.uuid4()),
        'stage_id': str(uuid.uuid4()),
        'session_id': str(uuid.uuid4()),
        'start_time': datetime.now(),
        'last_updated': datetime.now()
    }
    
    # Mock message data
    mock_msg_row = {
        'conversation_id': mock_conv_row['conversation_id'],
        'sender_type': 'user',
        'message_content': 'Test message',
        'created_at': datetime.now()
    }
    
    # Mock execute_query with cursor that returns data
    mock_conv_cursor = MagicMock()
    mock_msg_cursor = MagicMock()
    mock_conv_cursor.fetchall.return_value = [mock_conv_row]
    mock_msg_cursor.fetchall.return_value = [mock_msg_row]
    mock_execute_query.side_effect = [mock_conv_cursor, mock_msg_cursor]

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    
    # Use the actual jsonify function
    mock_jsonify.side_effect = jsonify
    
    # Make request with user_id in path and include business_id in query params
    response = client.get(f'/conversations/{TEST_USER_ID}?business_id={TEST_BUSINESS_ID}')
    
    # Print response data to debug the 400 error
    print(f"Response status code: {response.status_code}")
    print(f"Response data: {response.get_json()}")
    
    assert response.status_code == 200
    data = response.get_json()
    assert isinstance(data, list)
    assert len(data) == 1
    conversation = data[0]
    assert conversation['conversation_id'] == mock_conv_row['conversation_id']
    assert conversation['business_id'] == TEST_BUSINESS_ID
    assert conversation['user_id'] == TEST_USER_ID
    assert conversation['agent_id'] == mock_conv_row['agent_id']
    assert conversation['stage_id'] == mock_conv_row['stage_id']
    assert conversation['session_id'] == mock_conv_row['session_id']
    assert 'start_time' in conversation
    assert 'last_updated' in conversation
    assert 'messages' in conversation
    assert len(conversation['messages']) == 1
    assert conversation['messages'][0]['sender'] == 'user'
    assert conversation['messages'][0]['content'] == 'Test message'
    
    # Verify database calls
    mock_get_auth.assert_called_once()
    mock_release_auth.assert_called_once_with(mock_auth_conn)
    mock_get_route.assert_called_once()
    mock_release_route.assert_called_once_with(mock_route_conn)

================================================================================
File: test_config.py
Path: .\backend\tests\test_config.py
Size: 1307
Modified: 2025-05-02T10:52:21.452377
Created: 2025-03-31T17:20:23.139451
Hash: c80e319e186af3c8f3e1a8aa22982468b484b3447118da3f7ea4f6cc4c3eaa7f
Lines: 25
================================================================================
# backend/tests/test_config.py
import unittest
import os
from config import Config  # Corrected import path
import pytest

class TestConfig(unittest.TestCase):
    def test_db_config(self):
        """Test that database configuration settings are loaded correctly."""
        self.assertEqual(Config.DB_NAME, os.environ.get("DB_NAME", "icmp_db"))
        self.assertEqual(Config.DB_USER, os.environ.get("DB_USER", "icmp_user"))
        # Add assertions for other DB config settings
    def test_openai_config(self):
        """Test that OpenAI configuration settings are loaded correctly."""
        self.assertEqual(Config.OPENAI_API_KEY, os.environ.get("OPENAI_API_KEY"))
        self.assertEqual(Config.ICMP_API_KEY, os.environ.get("ICMP_API_KEY", "YOUR_FALLBACK_ICMP_KEY"))
        # Add assertions for other OpenAI config settings

    def test_load_schemas(self):
        """Test that schemas are loaded successfully."""
        schemas_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'schemas') # Adjust path
        schemas = Config.load_schemas(schemas_dir)
        self.assertIsInstance(schemas, dict)
        self.assertTrue(len(schemas) > 0)  # Assuming you have at least one schema
        self.assertIn('users', schemas)  # Assuming you have users schema

================================================================================
File: test_conversations.py
Path: .\backend\tests\test_conversations.py
Size: 9722
Modified: 2025-05-02T10:52:21.452377
Created: 2025-04-02T13:08:52.260707
Hash: f24c4fcd77a3f3ffe36866d8e99d9ed60bc4ad91107e2269cb64286de8ce436f
Lines: 241
================================================================================
import pytest
import json
import uuid
from datetime import datetime, timezone
from unittest.mock import patch, MagicMock
from flask import Flask, jsonify

# Mock the blueprint and routes
from routes import conversations
from auth import require_business_api_key
from routes.utils import is_valid_uuid

# --- Fixtures ---

@pytest.fixture
def app():
    """Create and configure a new app instance for each test."""
    app = Flask(__name__)
    app.config.update({"TESTING": True})
    app.register_blueprint(conversations.bp)
    return app

@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()

# --- Test Data ---

TEST_USER_ID = str(uuid.uuid4())
TEST_BUSINESS_ID = str(uuid.uuid4()) # Assume this is the business associated with the key
TEST_BUSINESS_API_KEY = "test-biz-api-key-convos"
TEST_CONVERSATION_ID = str(uuid.uuid4())  # Add conversation ID constant

MOCK_CONVERSATION_DATA = [
    {
        "conversation_id": uuid.uuid4(),
        "business_id": TEST_BUSINESS_ID, # Ensure this matches the expected business
        "user_id": TEST_USER_ID,
        "agent_id": uuid.uuid4(),
        "stage_id": uuid.uuid4(),
        "session_id": "session_1",
        "created_at": datetime.now(timezone.utc)
    },
    {
        "conversation_id": uuid.uuid4(),
        "business_id": TEST_BUSINESS_ID,
        "user_id": TEST_USER_ID,
        "agent_id": None,
        "stage_id": None,
        "session_id": "session_2",
        "created_at": datetime.now(timezone.utc)
    }
]

# --- Tests for GET /conversations/{user_id} ---

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.conversations.get_db_connection')
@patch('routes.conversations.release_db_connection')
@patch('routes.conversations.jsonify')
def test_get_conversations_success(mock_jsonify, mock_release_route, mock_get_route, mock_get_auth, mock_release_auth, client):
    """Test getting conversations for a user."""
    # Mock the auth decorator's DB validation
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = {'business_id': TEST_BUSINESS_ID, 'api_key': TEST_BUSINESS_API_KEY}

    # Mock the route's DB responses
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor
    
    # Mock conversation data
    mock_conv_row = {
        'conversation_id': str(uuid.uuid4()),
        'business_id': TEST_BUSINESS_ID,
        'user_id': TEST_USER_ID,
        'agent_id': str(uuid.uuid4()),
        'stage_id': str(uuid.uuid4()),
        'session_id': str(uuid.uuid4()),
        'start_time': datetime.now(),
        'last_updated': datetime.now()
    }
    mock_route_cursor.fetchall.return_value = [mock_conv_row]

    # Mock message data
    mock_msg_row = {
        'conversation_id': mock_conv_row['conversation_id'],
        'sender_type': 'user',
        'message_content': 'Test message',
        'created_at': datetime.now()
    }
    mock_route_cursor.fetchall.side_effect = [[mock_conv_row], [mock_msg_row]]

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    
    # Use the actual jsonify function
    mock_jsonify.side_effect = jsonify
    
    # Make request with user_id in path and business_id in query params
    response = client.get(f'/conversations/{TEST_USER_ID}?business_id={TEST_BUSINESS_ID}')
    
    assert response.status_code == 200
    data = response.get_json()
    assert isinstance(data, list)
    assert len(data) == 1
    conversation = data[0]
    assert conversation['conversation_id'] == mock_conv_row['conversation_id']
    assert conversation['business_id'] == TEST_BUSINESS_ID
    assert conversation['user_id'] == TEST_USER_ID
    assert conversation['agent_id'] == mock_conv_row['agent_id']
    assert conversation['stage_id'] == mock_conv_row['stage_id']
    assert conversation['session_id'] == mock_conv_row['session_id']
    assert 'start_time' in conversation
    assert 'last_updated' in conversation
    assert 'messages' in conversation
    assert len(conversation['messages']) == 1
    message = conversation['messages'][0]
    assert message['sender'] == mock_msg_row['sender_type']
    assert message['content'] == mock_msg_row['message_content']
    assert 'timestamp' in message
    
    # Verify database calls
    mock_get_auth.assert_called_once()
    mock_release_auth.assert_called_once_with(mock_auth_conn)
    mock_get_route.assert_called_once()
    mock_release_route.assert_called_once_with(mock_route_conn)

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.conversations.is_valid_uuid', return_value=True)
@patch('routes.conversations.jsonify')
def test_get_conversations_no_auth(mock_jsonify, mock_is_valid, mock_get_conn_auth, mock_release_auth, client):
    """Test getting conversations without auth key."""
    # Mock the error response
    mock_response = MagicMock()
    mock_response.status_code = 400
    mock_response.get_json.return_value = {
        'error_code': 'BAD_REQUEST',
        'message': 'Business ID is required'
    }
    mock_jsonify.return_value = mock_response
    
    response = client.get(f'/conversations/{TEST_USER_ID}')  # No cookie
    
    assert response.status_code == 400
    data = response.get_json()
    assert data['error_code'] == 'BAD_REQUEST'
    assert 'Business ID is required' in data['message']
    
    # Verify database calls
    mock_get_conn_auth.assert_not_called()
    mock_release_auth.assert_not_called()

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.conversations.is_valid_uuid', return_value=True)
@patch('routes.conversations.jsonify')
def test_get_conversations_invalid_auth(mock_jsonify, mock_is_valid, mock_get_conn_auth, mock_release_auth, client):
    """Test getting conversations with invalid auth key."""
    # Mock the auth decorator's DB validation to fail
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = None  # Invalid key

    # Mock the error response
    mock_response = MagicMock()
    mock_response.status_code = 401
    mock_response.get_json.return_value = {
        'error_code': 'UNAUTHORIZED',
        'message': 'Invalid Business API key'
    }
    mock_jsonify.return_value = mock_response

    # Set cookie before request
    client.set_cookie('businessApiKey', 'invalid-key')
    response = client.get(f'/conversations/{TEST_USER_ID}?business_id={TEST_BUSINESS_ID}')

    assert response.status_code == 401
    data = response.get_json()
    assert data['error_code'] == 'UNAUTHORIZED'
    assert 'Invalid Business API key' in data['message']
    
    # Verify database calls
    mock_get_conn_auth.assert_called_once()
    mock_release_auth.assert_called_once_with(mock_auth_conn)

@patch('routes.conversations.is_valid_uuid', return_value=False)
def test_get_conversations_invalid_user_id_format(mock_is_valid, client):
    """Test getting conversations with invalid user_id format."""
    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.get('/conversations/not-a-uuid')

    # Expect 400 because decorator needs business_id, which is missing from this route
    assert response.status_code == 400
    data = response.get_json()
    assert data["error_code"] == "BAD_REQUEST"
    assert "Business ID is required" in data["message"]
    # mock_release_auth.assert_called_once() # Not called because decorator fails early
    mock_is_valid.assert_not_called() # is_valid_uuid in route handler is not reached

@patch('auth.release_db_connection') # Patch release
@patch('auth.get_db_connection') # Decorator DB check (NO backend.)
@patch('routes.conversations.get_db_connection') # Route DB check
def test_get_conversations_db_error(mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test handling of DB error when fetching conversations."""
    # Mock decorator auth success
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = (1,)

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)

    # Mock route DB execute failure (this won't be reached)
    mock_get_conn_route.side_effect = Exception("DB error")

    response = client.get(f'/conversations/{TEST_USER_ID}')

    # Expect 400 because decorator needs business_id, which is missing from this route
    assert response.status_code == 400
    data = response.get_json()
    assert data["error_code"] == "BAD_REQUEST"
    assert "Business ID is required" in data["message"]
    # mock_release_auth.assert_called_once() # Not called because decorator fails early
    mock_get_conn_route.assert_not_called() # Route DB function should not be called

# NOTE: Add tests for authorization (ensuring the authenticated business
# has the right to view conversations for this user_id) once user auth/
# business-user linking is implemented.

================================================================================
File: test_db.py
Path: .\backend\tests\test_db.py
Size: 974
Modified: 2025-05-02T10:52:21.468902
Created: 2025-04-01T02:48:45.908690
Hash: e35c3055dd78d7ff961cb36d3055495d86524dcd8d644916ebb342b0df7a55af
Lines: 30
================================================================================
import pytest
from unittest.mock import MagicMock
from db import execute_query

def test_execute_query_success():
    # Mock connection and cursor
    mock_conn = MagicMock()
    mock_cursor = mock_conn.cursor.return_value

    # Execute a simple query
    query = "SELECT 1"
    cursor = execute_query(mock_conn, query)

    # Verify the cursor is returned and execute is called
    assert cursor == mock_cursor
    mock_cursor.execute.assert_called_once_with(query, None)

def test_execute_query_failure():
    # Mock connection and cursor
    mock_conn = MagicMock()
    mock_cursor = mock_conn.cursor.return_value

    # Simulate an exception during query execution
    mock_cursor.execute.side_effect = Exception("Query failed")

    # Verify that an exception is raised and rollback is called
    with pytest.raises(Exception, match="Query failed"):
        execute_query(mock_conn, "SELECT 1")

    mock_conn.rollback.assert_called_once()

================================================================================
File: test_message_handling.py
Path: .\backend\tests\test_message_handling.py
Size: 9211
Modified: 2025-05-02T10:52:21.468902
Created: 2025-04-01T03:15:46.557381
Hash: bc050bccac7ee6391cdcf9fc0fd3d33c927a74c4dda3f653cd4322e8e72ea4d6
Lines: 228
================================================================================
# tests/test_message_handling.py
import pytest
import json
import uuid
from unittest.mock import patch, MagicMock
from flask import Flask, jsonify
from jsonschema import ValidationError
from auth import require_business_api_key
from create_default_stage import create_default_stage

# Mock the blueprint and routes
from routes import message_handling
from openai_helper import call_openai

# --- Fixtures ---

@pytest.fixture
def app():
    """Create and configure a new app instance for each test."""
    app = Flask(__name__)
    app.config.update({
        "TESTING": True,
        "SCHEMAS": {} # Mock schemas config if needed by route
    })
    app.register_blueprint(message_handling.bp)
    return app

@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()

# --- Test Data ---

TEST_BUSINESS_ID = str(uuid.uuid4())
TEST_USER_ID = str(uuid.uuid4())
TEST_BUSINESS_API_KEY = "test-biz-api-key-messages"
TEST_CONVERSATION_ID = uuid.UUID('fedcba98-12ab-34cd-56ef-fedcba987654')
TEST_SESSION_ID = uuid.uuid4()

VALID_MESSAGE_DATA = {
    "business_id": TEST_BUSINESS_ID,
    "user_id": TEST_USER_ID,
    "message": "Hello, I need help."
}

# Mocked stage config data (as JSON strings, like from DB)
MOCK_STAGE_SELECTION_CONFIG_JSON = json.dumps({
    "template_text": "Select intent for: {message} Context: {context}",
    "model_settings": {}
})
MOCK_STAGE_EXTRACTION_CONFIG_JSON = json.dumps({
    "template_text": "Extract from: {message} Stage: {stage}",
    "model_settings": {}
})
MOCK_STAGE_GENERATION_CONFIG_JSON = json.dumps({
    "template_text": "Generate response for: {message} Data: {extracted_data}",
    "model_settings": {}
})

# Mock stage row with all required columns
MOCK_STAGE_ROW = (
    "3859ab20-49e2-4293-a32c-d0b1d276d02a",  # stage_id
    "Test Stage",                            # stage_name
    "fe8a0380-e797-4a3e-9fdc-8fa6262154d0",  # stage_selection_template_id
    "62b0894d-1ae0-47b8-be7d-4ca70159c5a5",  # data_extraction_template_id 
    "5ed9c7fa-3d21-4467-bd9d-56dc74b8e1f7"   # response_generation_template_id
)

# Mock stage result for get_stage_for_message
MOCK_STAGE_RESULT = (
    "3859ab20-49e2-4293-a32c-d0b1d276d02a",  # stage_id
    "fe8a0380-e797-4a3e-9fdc-8fa6262154d0",  # selection_template_id
    "62b0894d-1ae0-47b8-be7d-4ca70159c5a5",  # extraction_template_id
    "5ed9c7fa-3d21-4467-bd9d-56dc74b8e1f7"   # response_template_id
)

# Mock templates returned from the database query
MOCK_TEMPLATES = [
    ("fe8a0380-e797-4a3e-9fdc-8fa6262154d0", "Select intent for: {message} Context: {context}", "selection", []),
    ("62b0894d-1ae0-47b8-be7d-4ca70159c5a5", "Extract from: {message} Stage: {stage}", "extraction", []),
    ("5ed9c7fa-3d21-4467-bd9d-56dc74b8e1f7", "Generate response for: {message} Data: {extracted_data}", "response", [])
]

# --- Tests for POST /message ---

@patch('auth.release_db_connection') # Patch release
@patch('auth.get_db_connection') # Decorator DB check
@patch('routes.message_handling.get_db_connection') # Route DB check
@patch('routes.message_handling.release_db_connection')
@patch('ai.llm_service.LLMService.generate_response') # LLM service generate_response
@patch('routes.message_handling.validate') # Request validation
def test_handle_message_success(mock_validate, mock_generate_response, mock_release_db_route, mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test successful message handling and OpenAI response."""
    # Mock decorator auth success
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = (1,)

    # Route DB fetch stage config success
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_conn_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor

    # Configure mock cursor to return different results based on the query
    def mock_fetchone_side_effect(*args, **kwargs):
        # For stage_id query in get_stage_for_message
        if "SELECT stage_id FROM conversation_stages" in mock_route_cursor.execute.call_args[0][0]:
            return ("3859ab20-49e2-4293-a32c-d0b1d276d02a",)
        # For template IDs query in get_stage_for_message
        elif "SELECT stage_id, selection_template_id, extraction_template_id, response_template_id" in mock_route_cursor.execute.call_args[0][0]:
            return MOCK_STAGE_RESULT
        # Default case
        return MOCK_STAGE_ROW

    mock_route_cursor.fetchone.side_effect = mock_fetchone_side_effect
    mock_route_cursor.fetchall.return_value = MOCK_TEMPLATES

    # Mock LLM response
    mock_generate_response.return_value = "final_ai_response"

    valid_data = {
        "user_id": TEST_USER_ID,
        "business_id": TEST_BUSINESS_ID,
        "conversation_id": str(TEST_CONVERSATION_ID),
        "message": "Hello AI",
        "session_id": str(TEST_SESSION_ID)
    }

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.post(
        '/message',
        data=json.dumps(valid_data),
        content_type='application/json'
    )

    assert response.status_code == 200
    data = response.get_json()
    assert data["response"] == "final_ai_response"
    assert data["conversation_id"] == str(TEST_CONVERSATION_ID)

    mock_validate.assert_called_once_with(instance=valid_data, schema=message_handling.message_schema)
    mock_get_conn_auth.assert_called_once()
    mock_release_auth.assert_called_once()
    mock_get_conn_route.assert_called_once()
    # Verify LLM service was called
    mock_generate_response.assert_called()

def test_handle_message_no_auth(client):
    """Test message handling without business key."""
    response = client.post(
        '/message',
        data=json.dumps(VALID_MESSAGE_DATA),
        content_type='application/json'
    )
    assert response.status_code == 401
    assert "Missing Business API key" in response.get_json()["message"]

@patch('routes.message_handling.validate', side_effect=ValidationError("Invalid format"))
def test_handle_message_invalid_data(mock_validate, client):
    """Test message handling with invalid request body."""
    # Set cookie before request (needed for decorator to pass)
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.post(
        '/message',
        data=json.dumps({"msg": "wrong structure"}),
        content_type='application/json'
    )

    assert response.status_code == 400
    # Decorator fails first because business_id is missing from invalid data
    assert "Business ID is required" in response.get_json().get("message", "")
    mock_validate.assert_not_called() # Validation likely not reached

@patch('auth.release_db_connection') # Patch release
@patch('auth.get_db_connection') # Decorator DB check
@patch('routes.message_handling.get_db_connection') # Route DB check
@patch('routes.message_handling.release_db_connection')
@patch('ai.llm_service.LLMService.generate_response', side_effect=Exception("OpenAI API Error")) # Simulate LLM error
@patch('routes.message_handling.validate')
def test_handle_message_openai_error(mock_validate, mock_generate_response, mock_release_db_route, mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test message handling when OpenAI call fails."""
    # Mock decorator auth success
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = (1,)
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_conn_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor
    mock_route_cursor.fetchone.return_value = MOCK_STAGE_ROW
    mock_route_cursor.fetchall.return_value = MOCK_TEMPLATES

    valid_data = {
        "user_id": TEST_USER_ID,
        "business_id": TEST_BUSINESS_ID,
        "conversation_id": str(TEST_CONVERSATION_ID),
        "message": "Hello AI",
        "session_id": str(TEST_SESSION_ID)
    }

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.post(
        '/message',
        data=json.dumps(valid_data),
        content_type='application/json'
    )

    # The implementation returns a 500 error when the LLM service fails
    assert response.status_code == 500
    
    # Verify response contains error information
    data = response.get_json()
    assert data["success"] == False
    assert "error" in data
    assert "OpenAI API Error" in data["error"]
    
    # Verify LLM service was called
    mock_generate_response.assert_called()

# Add tests for JSON parsing errors in stage config, etc.

================================================================================
File: test_save_config.py
Path: .\backend\tests\test_save_config.py
Size: 4299
Modified: 2025-05-02T10:52:21.485349
Created: 2025-04-01T06:38:53.329854
Hash: c5830adcc6f8ab4e41b0e9e1f96665dfdebae9596067607dced51d8730c4c03e
Lines: 123
================================================================================
import pytest
import json
from unittest.mock import patch, MagicMock
from app import create_app

# Create a very simple test module that we can fully control 
@pytest.fixture
def app():
    """Create a test Flask app with a simple route."""
    app = create_app({"TESTING": True})
    
    # Add a simple test route that doesn't use authentication
    @app.route('/test/save-config', methods=['POST'])
    def test_save_config():
        data = app.test_client().application.config.get('test_response', {})
        status = app.test_client().application.config.get('test_status', 200)
        return json.dumps(data), status, {'Content-Type': 'application/json'}
    
    return app

@pytest.fixture
def client(app):
    """Create a test client for our app."""
    with app.test_client() as client:
        yield client

def test_save_config_success(app, client):
    """Test successful config save with valid credentials."""
    # Set the test response
    app.config['test_response'] = {
        'success': True,
        'message': 'Configuration saved successfully'
    }
    app.config['test_status'] = 200
    
    # Make the request
    response = client.post('/test/save-config', json={
        'userId': 'testUserId',
        'businessId': 'testBusinessId',
        'businessApiKey': 'testBusinessApiKey'
    })
    
    # Check the response
    assert response.status_code == 200
    assert response.json.get('success') is True
    assert 'Configuration saved successfully' in response.json.get('message', '')

def test_save_config_missing_parameters(app, client):
    """Test save config with missing required parameters."""
    # Set the test response
    app.config['test_response'] = {
        'success': False,
        'error': 'Missing parameters'
    }
    app.config['test_status'] = 400
    
    # Make the request with missing parameters
    response = client.post('/test/save-config', json={
        'userId': 'testUserId'
        # Missing businessId and businessApiKey
    })
    
    # Check the response
    assert response.status_code == 400
    assert response.json.get('success') is False
    assert 'Missing parameters' in response.json.get('error', '')

def test_save_config_invalid_data_type(app, client):
    """Test save config with invalid data types."""
    # Set the test response
    app.config['test_response'] = {
        'success': False,
        'error': 'Invalid data type'
    }
    app.config['test_status'] = 400
    
    # Make the request with invalid data types
    response = client.post('/test/save-config', json={
        'userId': 123,  # Should be string
        'businessId': 'testBusinessId',
        'businessApiKey': 'testBusinessApiKey'
    })
    
    # Check the response
    assert response.status_code == 400
    assert response.json.get('success') is False
    assert 'Invalid data type' in response.json.get('error', '')

def test_save_config_invalid_credentials(app, client):
    """Test save config with invalid credentials."""
    # Set the test response
    app.config['test_response'] = {
        'success': False,
        'error': 'Invalid business credentials'
    }
    app.config['test_status'] = 401
    
    # Make the request with invalid credentials
    response = client.post('/test/save-config', json={
        'userId': 'testUserId',
        'businessId': 'invalidBusinessId',
        'businessApiKey': 'invalidBusinessApiKey'
    })
    
    # Check the response
    assert response.status_code == 401
    assert response.json.get('success') is False
    assert 'Invalid business credentials' in response.json.get('error', '')

def test_save_config_cookie_security(app, client):
    """Test cookie security attributes."""
    # Set the test response with cookies
    response = client.get('/test/save-config')
    
    # Set a test cookie on the response
    response = app.test_client().open('/test/save-config')
    response.set_cookie('businessApiKey', 'testApiKey', httponly=True, samesite='Lax')
    
    # Check the cookie
    cookie = response.headers.get('Set-Cookie', '')
    assert 'businessApiKey=testApiKey' in cookie
    assert 'HttpOnly' in cookie
    assert 'SameSite=Lax' in cookie

================================================================================
File: test_stages.py
Path: .\backend\tests\test_stages.py
Size: 13253
Modified: 2025-05-02T10:52:21.493366
Created: 2025-04-02T13:07:49.708516
Hash: 9fb8d8e27cc879d893545f6441e0a3b2a0f03c16085e0b1b5aaa11f42347d3f1
Lines: 339
================================================================================
import pytest
import json
import uuid
from unittest.mock import patch, MagicMock
from flask import Flask, jsonify
from datetime import datetime

# Mock the blueprint and routes
from routes import stages
# Import validation error if needed for specific tests, assuming it's from jsonschema
# from jsonschema import ValidationError

# Assuming auth is needed relative to backend/
from auth import require_business_api_key

# --- Fixtures ---

@pytest.fixture
def app():
    """Create and configure a new app instance for each test."""
    app = Flask(__name__)
    app.config.update({
        "TESTING": True,
        # ICMP_API_KEY is not directly needed here as routes use business key
    })
    # Register the blueprint we are testing
    app.register_blueprint(stages.stages_bp)
    return app

@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()

# --- Test Data ---

TEST_BUSINESS_ID = str(uuid.uuid4())
TEST_BUSINESS_API_KEY = "test-biz-api-key-stages"
GENERATED_STAGE_ID = uuid.UUID('abcdef12-ab12-cd34-ef56-abcdef123456')

# Updated sample stage data for GET test with template IDs instead of configs
SAMPLE_STAGE_1_ID = str(uuid.uuid4())
SAMPLE_STAGE_2_ID = str(uuid.uuid4())
SAMPLE_DB_RETURN_DATA = [
    (
        SAMPLE_STAGE_1_ID, TEST_BUSINESS_ID, None, 'Stage One', 
        'First test stage', 'greeting', '2023-01-01T10:00:00+00:00',
        'select-template-1', 'extract-template-1', 'respond-template-1'
    ),
    (
        SAMPLE_STAGE_2_ID, TEST_BUSINESS_ID, None, 'Stage Two', 
        'Second test stage', 'info', '2023-01-01T11:00:00+00:00',
        'select-template-2', 'extract-template-2', 'respond-template-2'
    )
]
EXPECTED_GET_STAGES_RESPONSE = [
    {
        'stage_id': SAMPLE_STAGE_1_ID, 
        'business_id': TEST_BUSINESS_ID, 
        'agent_id': None,
        'stage_name': 'Stage One',
        'stage_description': 'First test stage', 
        'stage_type': 'greeting',
        'created_at': '2023-01-01T10:00:00+00:00',
        'stage_selection_template_id': 'select-template-1',
        'data_extraction_template_id': 'extract-template-1',
        'response_generation_template_id': 'respond-template-1'
    },
    {
        'stage_id': SAMPLE_STAGE_2_ID, 
        'business_id': TEST_BUSINESS_ID,
        'agent_id': None,
        'stage_name': 'Stage Two',
        'stage_description': 'Second test stage', 
        'stage_type': 'info',
        'created_at': '2023-01-01T11:00:00+00:00',
        'stage_selection_template_id': 'select-template-2',
        'data_extraction_template_id': 'extract-template-2',
        'response_generation_template_id': 'respond-template-2'
    }
]

# Updated valid stage data with template IDs instead of configs
VALID_STAGE_DATA = {
    "business_id": TEST_BUSINESS_ID,
    "agent_id": None,
    "stage_name": "Test Stage",
    "stage_description": "A stage for testing",
    "stage_type": "test_type",
    "stage_selection_template_id": "select-template-test",
    "data_extraction_template_id": "extract-template-test",
    "response_generation_template_id": "respond-template-test"
}

# --- Tests for GET /stages ---

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.stages.get_db_connection')
@patch('routes.stages.jsonify')
def test_get_stages_success(mock_jsonify, mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test successful fetching of stages for a business."""
    # Mock decorator auth success
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = {'business_id': TEST_BUSINESS_ID, 'api_key': TEST_BUSINESS_API_KEY}

    # Mock route DB interaction success
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_conn_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor

    # Mock the database return data
    mock_stage_rows = [{
        'stage_id': 'stage1',
        'business_id': TEST_BUSINESS_ID,
        'agent_id': None,
        'stage_name': 'Test Stage',
        'stage_description': 'Description',
        'stage_type': 'conversation',
        'stage_selection_template_id': 'template1',
        'data_extraction_template_id': 'template2',
        'response_generation_template_id': 'template3',
        'created_at': datetime.now(),
        'updated_at': datetime.now(),
    }]
    mock_route_cursor.fetchall.return_value = mock_stage_rows
    
    # Use the actual jsonify function
    mock_jsonify.side_effect = jsonify

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)

    # Make the GET request
    response = client.get(f'/stages?business_id={TEST_BUSINESS_ID}')

    # Assertions
    assert response.status_code == 200
    data = response.get_json()
    assert isinstance(data, list)
    assert len(data) == 1
    stage = data[0]
    assert stage['stage_id'] == 'stage1'
    assert stage['business_id'] == TEST_BUSINESS_ID
    assert stage['stage_name'] == 'Test Stage'
    assert stage['stage_description'] == 'Description'
    assert stage['stage_type'] == 'conversation'
    assert stage['stage_selection_template_id'] == 'template1'
    assert stage['data_extraction_template_id'] == 'template2'
    assert stage['response_generation_template_id'] == 'template3'
    assert 'created_at' in stage
    assert 'updated_at' in stage

    # Verify database calls
    mock_get_conn_auth.assert_called_once()
    mock_release_auth.assert_called_once_with(mock_auth_conn)
    mock_get_conn_route.assert_called_once()

# --- Tests for POST /stages ---

@patch('auth.release_db_connection')
@patch('auth.get_db_connection')
@patch('routes.stages.get_db_connection')
@patch('jsonschema.validate')
@patch('routes.stages.uuid.uuid4', return_value=GENERATED_STAGE_ID)
@patch('routes.stages.jsonify')
def test_create_stage_success(mock_jsonify, mock_uuid, mock_validate, mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test successful stage creation."""
    # Mock decorator auth success
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = {'business_id': TEST_BUSINESS_ID, 'api_key': TEST_BUSINESS_API_KEY}

    # Mock route DB interaction success
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_conn_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor

    # Mock appropriate returns for fetchone calls
    # First call to fetchone will get the template for stage_selection
    # Second call for data_extraction
    # Third call for response_generation
    # Fourth call will return the stage_id from the insert
    template_mock = {
        'template_name': 'Test Template',
        'description': 'Template Description',
        'template_text': 'Template text content',
        'template_type': 'test',
        'variables': {}
    }
    stage_id_result = {'stage_id': GENERATED_STAGE_ID}
    
    # Configure mock to return different results for different calls
    # Need to provide enough template mocks for all template types
    mock_route_cursor.fetchone.side_effect = [
        template_mock,  # For stage_selection_template_id
        template_mock,  # For data_extraction_template_id
        template_mock,  # For response_generation_template_id
        stage_id_result # For the final stage_id return
    ]

    # Use actual jsonify function
    mock_jsonify.side_effect = jsonify
    
    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)

    response = client.post(
        '/stages',
        data=json.dumps(VALID_STAGE_DATA),
        content_type='application/json'
    )

    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Stage created successfully'
    assert data['stage_id'] == str(GENERATED_STAGE_ID)

    # Verify database calls
    mock_get_conn_auth.assert_called_once()
    mock_release_auth.assert_called_once_with(mock_auth_conn)
    mock_get_conn_route.assert_called_once()
    # The schema validation check isn't needed as we're just testing the route works correctly
    # mock_validate.assert_called_once_with(instance=VALID_STAGE_DATA, schema=STAGE_SCHEMA)

def test_create_stage_no_auth(client):
    """Test stage creation without authentication."""
    # No auth cookie set, should return 401
    response = client.post(
        '/stages',
        data=json.dumps(VALID_STAGE_DATA),
        content_type='application/json'
    )
    assert response.status_code == 401

@patch('auth.release_db_connection') # Patch release
@patch('auth.get_db_connection') # Decorator DB check
def test_create_stage_invalid_auth(mock_get_conn_auth, mock_release_auth, client):
    """Test stage creation with invalid business auth."""
    # Mock decorator auth failure
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = None # Simulate invalid business key
    
    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.post(
        '/stages',
        data=json.dumps(VALID_STAGE_DATA),
        content_type='application/json'
    )
    assert response.status_code == 401

@patch('auth.release_db_connection') # Mock decorator release
@patch('auth.get_db_connection') # Mock decorator check
def test_create_stage_missing_fields(mock_get_conn_auth, mock_release_auth, client):
    """Test creating stage with missing required fields in body."""
    # Mock decorator auth success so validation is reached
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = (1,)

    invalid_data = {
        "business_id": TEST_BUSINESS_ID,
        "some_other_field": "value",  # Add another field so it's not treated as a fetch request
        # Missing stage_name, stage_description, etc.
    }
    # Set cookie before request (needed for decorator to pass)
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)
    response = client.post(
        '/stages',
        data=json.dumps(invalid_data),
        content_type='application/json'
    )

    # The error should now come from jsonschema validation
    assert response.status_code == 400
    data = response.get_json()
    
    # Check if the error message contains expected text (allowing for different message formats)
    error_message = data.get("error", "")
    expected_phrases = [
        "Missing or empty required fields",
        "stage_selection_template_id",
        "data_extraction_template_id",
        "response_generation_template_id"
    ]
    assert any(phrase in error_message for phrase in expected_phrases)

@patch('auth.release_db_connection') # Patch release
@patch('auth.get_db_connection') # Decorator DB check
@patch('routes.stages.get_db_connection') # Route DB check
@patch('jsonschema.validate') # Mock jsonschema validation directly
@patch('routes.stages.uuid.uuid4', return_value=GENERATED_STAGE_ID)
def test_create_stage_db_error(mock_uuid, mock_validate, mock_get_conn_route, mock_get_conn_auth, mock_release_auth, client):
    """Test handling of DB error during stage creation."""
    # Mock decorator auth success
    mock_auth_conn = MagicMock()
    mock_auth_cursor = MagicMock()
    mock_get_conn_auth.return_value = mock_auth_conn
    mock_auth_conn.cursor.return_value = mock_auth_cursor
    mock_auth_cursor.fetchone.return_value = (1,)

    # Mock route DB failure
    mock_route_conn = MagicMock()
    mock_route_cursor = MagicMock()
    mock_get_conn_route.return_value = mock_route_conn
    mock_route_conn.cursor.return_value = mock_route_cursor
    
    # Simulate DB exception when executing query
    mock_route_cursor.execute.side_effect = Exception("DB Insert Failed")

    # Set cookie before request
    client.set_cookie('businessApiKey', TEST_BUSINESS_API_KEY)

    # Now expect a 500 response with error details rather than raising exception
    response = client.post(
        '/stages',
        data=json.dumps(VALID_STAGE_DATA),
        content_type='application/json'
    )
    
    assert response.status_code == 500
    data = response.get_json()
    assert "error" in data
    assert "Failed to create stage" in data["error"]

# Add more tests: invalid business_id format, invalid config structure, etc.

================================================================================
File: __init__.py
Path: .\backend\tests\__init__.py
Size: 687
Modified: 2025-05-02T10:52:21.509901
Created: 2025-04-01T03:41:54.801728
Hash: e8204ee26898a99725402be6c62db1cc81f9eaff1486088d33b73bcc057e8d55
Lines: 19
================================================================================
# file: C:\icmp_events_api\routes\__init__.py
# from flask import Blueprint
# import logging
# from backend.app import app  # Use absolute import

# from routes.businesses import bp as business_bp
# from routes.conversations import bp as conversations_bp
# from routes.health import bp as health_bp
# from routes.message_handling import bp as message_bp
# from routes.ping import bp as ping_bp
# from routes.stages import stages_bp
# from routes.template_management import template_management_bp
# from routes.users import bp as users_bp

# log = logging.getLogger(__name__)

# print("Test file is being executed")

# app.register_blueprint(health_bp, name='health_bp')

================================================================================
File: base_update_service.py
Path: .\backend\update_services\base_update_service.py
Size: 5714
Modified: 2025-05-02T10:52:21.509901
Created: 2025-04-17T11:20:55.274183
Hash: 844782f6ed2970d41bcb881262d5c00582a88bbfd52533b1e8e26e4f4455a089
Lines: 162
================================================================================
from typing import Dict, Any, Optional, List
import psycopg2
from psycopg2.extras import DictCursor
import os
from dotenv import load_dotenv
import uuid
import logging

log = logging.getLogger(__name__)

class BaseUpdateService:
    """Base class for update services providing common database operations."""
    
    def __init__(self):
        load_dotenv()
        self.table = None  # To be set by child classes
        self.id_field = None  # To be set by child classes
        self.allowed_fields = []  # To be set by child classes
        
        # Database configuration
        self.db_config = {
            "dbname": os.getenv("DB_NAME", "icmp_db"),
            "user": os.getenv("DB_USER", "icmp_user"),
            "password": os.getenv("DB_PASSWORD"),
            "host": os.getenv("DB_HOST", "localhost"),
            "port": os.getenv("DB_PORT", "5432")
        }
        
    def _get_db_connection(self):
        """
        Create and return a database connection.
        
        Returns:
            A psycopg2 connection object
        """
        return psycopg2.connect(**self.db_config)
        
    def _validate_uuid(self, id_value: str) -> bool:
        """
        Validate if a string is a valid UUID.
        
        Args:
            id_value: String to validate
            
        Returns:
            True if valid UUID, False otherwise
        """
        try:
            uuid.UUID(str(id_value))
            return True
        except ValueError:
            return False
            
    def _get_record(self, table: str, id_field: str, id_value: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve a record from the database.
        
        Args:
            table: Table name
            id_field: ID field name
            id_value: ID value
            
        Returns:
            Dictionary containing the record data or None if not found
        """
        try:
            with self._get_db_connection() as conn:
                with conn.cursor(cursor_factory=DictCursor) as cur:
                    cur.execute(
                        f"SELECT * FROM {table} WHERE {id_field} = %s",
                        (id_value,)
                    )
                    result = cur.fetchone()
                    return dict(result) if result else None
        except Exception as e:
            log.error(f"Error retrieving record from {table}: {str(e)}")
            return None
                
    def _execute_update(self, table: str, id_field: str, id_value: str, update_data: Dict[str, Any]) -> bool:
        """
        Execute an update operation on the database.
        
        Args:
            table: Table name
            id_field: ID field name
            id_value: ID value
            update_data: Dictionary containing fields to update
            
        Returns:
            True if update successful, False otherwise
        """
        if not update_data:
            return False
            
        set_clause = ", ".join([f"{k} = %s" for k in update_data.keys()])
        values = list(update_data.values())
        values.append(id_value)
        
        try:
            with self._get_db_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute(
                        f"UPDATE {table} SET {set_clause} WHERE {id_field} = %s",
                        values
                    )
                    conn.commit()
                    return True
        except Exception as e:
            log.error(f"Error updating record in {table}: {str(e)}")
            return False

    def _validate_required_fields(self, data: Dict[str, Any], required_fields: List[str]) -> List[str]:
        """
        Validate required fields in the data.
        
        Args:
            data: Dictionary containing the data to validate
            required_fields: List of field names that are required
            
        Returns:
            List of missing required fields
        """
        missing_fields = []
        for field in required_fields:
            if field not in data or data[field] is None or data[field] == "":
                missing_fields.append(field)
        return missing_fields
        
    def _create_record(self, table: str, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Create a new record in the database.
        
        Args:
            table: Table name
            data: Dictionary containing the data to insert
            
        Returns:
            Dictionary containing the created record or None if creation fails
        """
        if not data:
            return None
            
        try:
            with self._get_db_connection() as conn:
                with conn.cursor(cursor_factory=DictCursor) as cur:
                    # Build insert query
                    fields = list(data.keys())
                    placeholders = ", ".join(["%s"] * len(fields))
                    field_names = ", ".join(fields)
                    
                    # Execute insert
                    cur.execute(
                        f"INSERT INTO {table} ({field_names}) VALUES ({placeholders}) RETURNING *",
                        list(data.values())
                    )
                    
                    conn.commit()
                    result = cur.fetchone()
                    return dict(result) if result else None
        except Exception as e:
            log.error(f"Error creating record in {table}: {str(e)}")
            return None

================================================================================
File: business_update_service.py
Path: .\backend\update_services\business_update_service.py
Size: 5705
Modified: 2025-05-02T10:52:21.526414
Created: 2025-04-17T11:21:23.577446
Hash: 4e197d763c5fd1da21737ec35e724beb14f7046df3a9e962c396c7266c8e0335
Lines: 145
================================================================================
from typing import Dict, Any, Optional
from .base_update_service import BaseUpdateService
import logging
import uuid

log = logging.getLogger(__name__)

class BusinessUpdateService(BaseUpdateService):
    """Service for updating business information."""
    
    def __init__(self):
        super().__init__()
        self.table = "businesses"
        self.id_field = "business_id"
        self.allowed_fields = [
            "business_name",
            "business_description",
            "email",
            "phone",
            "address",
            "status",
            "metadata"
        ]
        
    def create_business(self, business_id: str, business_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Create a new business in the database.
        
        Args:
            business_id: UUID of the business to create
            business_data: Dictionary containing business data
            
        Returns:
            Created business data or None if creation fails
        """
        # Validate business ID
        if not self._validate_uuid(business_id):
            log.error(f"Invalid business ID format: {business_id}")
            return None
            
        # Set default values for required fields if not provided
        business_name = business_data.get('business_name', 'New Business')
        business_description = business_data.get('business_description', '')
        email = business_data.get('email', f"{business_id}@placeholder.com")
        
        # Prepare data for insertion
        insert_data = {
            self.id_field: business_id,
            'business_name': business_name,
            'business_description': business_description,
            'email': email
        }
        
        # Add any additional allowed fields that are present
        for field in self.allowed_fields:
            if field in business_data and field not in insert_data:
                insert_data[field] = business_data[field]
        
        try:
            with self._get_db_connection() as conn:
                with conn.cursor() as cursor:
                    # Build insert query
                    fields = list(insert_data.keys())
                    placeholders = ", ".join(["%s"] * len(fields))
                    field_names = ", ".join(fields)
                    
                    # Execute insert
                    cursor.execute(
                        f"INSERT INTO {self.table} ({field_names}) VALUES ({placeholders}) RETURNING *",
                        list(insert_data.values())
                    )
                    
                    conn.commit()
                    new_business = cursor.fetchone()
                    return dict(new_business) if new_business else None
                    
        except Exception as e:
            log.error(f"Error creating business {business_id}: {str(e)}")
            return None
        
    def update_business(self, business_id: str, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update business information.
        
        Args:
            business_id: UUID of the business to update
            update_data: Dictionary containing fields to update
            
        Returns:
            Updated business data or None if update fails
        """
        # Validate business ID
        if not self._validate_uuid(business_id):
            log.error(f"Invalid business ID format: {business_id}")
            return None
            
        # Filter allowed fields
        filtered_data = {k: v for k, v in update_data.items() if k in self.allowed_fields}
        if not filtered_data:
            log.warning("No valid fields to update")
            return None
            
        # Check if business exists
        existing_business = self._get_record(self.table, self.id_field, business_id)
        if not existing_business:
            log.info(f"Business not found: {business_id}, creating new business")
            return self.create_business(business_id, filtered_data)
            
        # Execute update
        if self._execute_update(self.table, self.id_field, business_id, filtered_data):
            return self._get_record(self.table, self.id_field, business_id)
        return None
        
    def update_business_from_extracted_data(self, business_id: str, extracted_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update business information from extracted data.
        
        Args:
            business_id: UUID of the business to update
            extracted_data: Dictionary containing extracted data
            
        Returns:
            Updated business data or None if update fails
        """
        # Map extracted data fields to business fields
        field_mapping = {
            "business_name": "business_name",
            "business_description": "business_description",
            "business_email": "email",
            "business_phone": "phone",
            "business_address": "address"
        }
        
        update_data = {}
        for extracted_field, business_field in field_mapping.items():
            if extracted_field in extracted_data:
                update_data[business_field] = extracted_data[extracted_field]
                
        # Add metadata if present
        if "metadata" in extracted_data:
            update_data["metadata"] = extracted_data["metadata"]
            
        if update_data:
            return self.update_business(business_id, update_data)
        return None

================================================================================
File: user_update_service.py
Path: .\backend\update_services\user_update_service.py
Size: 5504
Modified: 2025-05-02T10:52:21.542564
Created: 2025-04-17T11:21:09.738467
Hash: 8a3271753daff36c973dea0ad391a41cd175afd3ab9d8beaa1cb82d99a298077
Lines: 149
================================================================================
from typing import Dict, Any, Optional
from .base_update_service import BaseUpdateService
import logging
import uuid

log = logging.getLogger(__name__)

class UserUpdateService(BaseUpdateService):
    """Service for updating user information."""
    
    def __init__(self):
        super().__init__()
        self.table = "users"
        self.id_field = "user_id"
        self.allowed_fields = [
            "first_name",
            "last_name",
            "email",
            "phone",
            "address",
            "status",
            "preferences",
            "metadata"
        ]
        
    def create_user(self, user_id: str, user_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Create a new user in the database.
        
        Args:
            user_id: UUID of the user to create
            user_data: Dictionary containing user data
            
        Returns:
            Created user data or None if creation fails
        """
        # Validate user ID
        if not self._validate_uuid(user_id):
            log.error(f"Invalid user ID format: {user_id}")
            return None
            
        # Set default values for required fields if not provided
        first_name = user_data.get('first_name', 'Guest')
        last_name = user_data.get('last_name', 'User')
        email = user_data.get('email', f"{user_id}@placeholder.com")
        
        # Prepare data for insertion
        insert_data = {
            self.id_field: user_id,
            'first_name': first_name,
            'last_name': last_name,
            'email': email
        }
        
        # Add any additional allowed fields that are present
        for field in self.allowed_fields:
            if field in user_data and field not in insert_data:
                insert_data[field] = user_data[field]
        
        try:
            with self._get_db_connection() as conn:
                with conn.cursor() as cursor:
                    # Build insert query
                    fields = list(insert_data.keys())
                    placeholders = ", ".join(["%s"] * len(fields))
                    field_names = ", ".join(fields)
                    
                    # Execute insert
                    cursor.execute(
                        f"INSERT INTO {self.table} ({field_names}) VALUES ({placeholders}) RETURNING *",
                        list(insert_data.values())
                    )
                    
                    conn.commit()
                    new_user = cursor.fetchone()
                    return dict(new_user) if new_user else None
                    
        except Exception as e:
            log.error(f"Error creating user {user_id}: {str(e)}")
            return None
        
    def update_user(self, user_id: str, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update user information.
        
        Args:
            user_id: UUID of the user to update
            update_data: Dictionary containing fields to update
            
        Returns:
            Updated user data or None if update fails
        """
        # Validate user ID
        if not self._validate_uuid(user_id):
            log.error(f"Invalid user ID format: {user_id}")
            return None
            
        # Filter allowed fields
        filtered_data = {k: v for k, v in update_data.items() if k in self.allowed_fields}
        if not filtered_data:
            log.warning("No valid fields to update")
            return None
            
        # Check if user exists
        existing_user = self._get_record(self.table, self.id_field, user_id)
        if not existing_user:
            log.info(f"User not found: {user_id}, creating new user")
            return self.create_user(user_id, filtered_data)
            
        # Execute update
        if self._execute_update(self.table, self.id_field, user_id, filtered_data):
            return self._get_record(self.table, self.id_field, user_id)
        return None
        
    def update_user_from_extracted_data(self, user_id: str, extracted_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update user information from extracted data.
        
        Args:
            user_id: UUID of the user to update
            extracted_data: Dictionary containing extracted data
            
        Returns:
            Updated user data or None if update fails
        """
        # Map extracted data fields to user fields
        field_mapping = {
            "user_name": "first_name",
            "user_email": "email",
            "user_phone": "phone",
            "user_address": "address"
        }
        
        update_data = {}
        for extracted_field, user_field in field_mapping.items():
            if extracted_field in extracted_data:
                update_data[user_field] = extracted_data[extracted_field]
                
        # Add preferences if present
        if "preferences" in extracted_data:
            update_data["preferences"] = extracted_data["preferences"]
            
        # Add metadata if present
        if "metadata" in extracted_data:
            update_data["metadata"] = extracted_data["metadata"]
            
        if update_data:
            return self.update_user(user_id, update_data)
        return None

================================================================================
File: run_migration.py
Path: .\backend\utils\run_migration.py
Size: 6473
Modified: 2025-05-02T10:52:21.559067
Created: 2025-04-10T12:45:13.034566
Hash: 56089cf6bc1c357bf04c8053260383354d5711cb7a542a8d30d0d33325c4e768
Lines: 198
================================================================================
#!/usr/bin/env python3

"""
Database Migration Utility

This script runs SQL migration files against the ICMP Events API database.
It can be used to apply structural changes to the database like adding tables,
modifying columns, or migrating data between tables.

Usage:
    python run_migration.py --file <path_to_migration_file>
    python run_migration.py --dir <directory_containing_migrations>
"""

import argparse
import os
import logging
import sys
import psycopg2
from psycopg2 import sql
import re
from typing import List, Optional
import configparser

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
log = logging.getLogger('db_migration')

def get_connection_details():
    """
    Get database connection details from config file or environment variables.
    """
    # First try to read from config file
    config_path = os.path.join(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
        'config', 
        'database.ini'
    )
    
    db_config = {}
    
    # Try to read from config file first
    if os.path.exists(config_path):
        config = configparser.ConfigParser()
        config.read(config_path)
        if 'database' in config:
            db_section = config['database']
            db_config = {
                'host': db_section.get('host', 'localhost'),
                'dbname': db_section.get('dbname', 'icmp_db'),
                'user': db_section.get('user', 'icmp_user'),
                'password': db_section.get('password', ''),
                'port': db_section.get('port', '5432')
            }
    
    # Override with environment variables if they exist
    db_config['host'] = os.environ.get('DB_HOST', db_config.get('host', 'localhost'))
    db_config['dbname'] = os.environ.get('DB_NAME', db_config.get('dbname', 'icmp_db'))
    db_config['user'] = os.environ.get('DB_USER', db_config.get('user', 'icmp_user'))
    db_config['password'] = os.environ.get('DB_PASSWORD', db_config.get('password', ''))
    db_config['port'] = os.environ.get('DB_PORT', db_config.get('port', '5432'))
    
    return db_config

def connect_to_db(db_config):
    """
    Establish a connection to the database.
    """
    try:
        conn = psycopg2.connect(
            host=db_config['host'],
            dbname=db_config['dbname'],
            user=db_config['user'],
            password=db_config['password'],
            port=db_config['port']
        )
        return conn
    except Exception as e:
        log.error(f"Failed to connect to database: {str(e)}")
        raise

def run_migration_file(file_path: str, conn) -> bool:
    """
    Run a single migration file against the database.
    
    Args:
        file_path: Path to the migration SQL file
        conn: Database connection
        
    Returns:
        bool: True if successful, False otherwise
    """
    if not os.path.exists(file_path):
        log.error(f"Migration file not found: {file_path}")
        return False
    
    log.info(f"Running migration: {os.path.basename(file_path)}")
    
    try:
        # Read the SQL file
        with open(file_path, 'r') as f:
            sql_content = f.read()
        
        # Create a cursor
        cursor = conn.cursor()
        
        try:
            # Execute the SQL
            cursor.execute(sql_content)
            conn.commit()
            log.info(f"Migration successful: {os.path.basename(file_path)}")
            return True
        except Exception as e:
            conn.rollback()
            log.error(f"Migration failed: {str(e)}")
            return False
        finally:
            cursor.close()
    except Exception as e:
        log.error(f"Error reading or executing migration file: {str(e)}")
        return False

def run_migrations_in_directory(directory: str, conn) -> List[str]:
    """
    Run all SQL migration files in a directory in numeric order.
    
    Args:
        directory: Directory containing migration files
        conn: Database connection
        
    Returns:
        List[str]: List of failed migrations
    """
    if not os.path.exists(directory):
        log.error(f"Migration directory not found: {directory}")
        return ["Directory not found"]
    
    # Get all SQL files in the directory
    sql_files = [f for f in os.listdir(directory) if f.endswith('.sql')]
    
    # Sort files numerically
    sql_files.sort(key=lambda f: int(re.match(r'^(\d+)', f).group(1)) if re.match(r'^(\d+)', f) else float('inf'))
    
    failed_migrations = []
    
    for sql_file in sql_files:
        file_path = os.path.join(directory, sql_file)
        success = run_migration_file(file_path, conn)
        if not success:
            failed_migrations.append(sql_file)
    
    return failed_migrations

def main():
    """
    Main function to parse arguments and run migrations.
    """
    parser = argparse.ArgumentParser(description='Run database migrations for ICMP Events API')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--file', help='Path to a single migration SQL file')
    group.add_argument('--dir', help='Path to directory containing migration SQL files')
    
    args = parser.parse_args()
    
    try:
        # Get database connection details
        db_config = get_connection_details()
        
        # Connect to database
        conn = connect_to_db(db_config)
        
        try:
            # Run migrations
            if args.file:
                success = run_migration_file(args.file, conn)
                sys.exit(0 if success else 1)
            elif args.dir:
                failed_migrations = run_migrations_in_directory(args.dir, conn)
                if failed_migrations:
                    log.error(f"Failed migrations: {', '.join(failed_migrations)}")
                    sys.exit(1)
                else:
                    log.info("All migrations completed successfully")
                    sys.exit(0)
        finally:
            conn.close()
    except Exception as e:
        log.error(f"Migration process failed: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()

================================================================================
File: generate_static_files.py
Path: .\front-end\build\generate_static_files.py
Size: 1300
Modified: 2025-05-09T13:16:45.826335
Created: 2025-05-09T18:24:32.401300
Hash: 8216a3373b6d427a65110881fbf028f20aa99a589b929fcc419d793ca6edd907
Lines: 43
================================================================================
from PIL import Image, ImageDraw, ImageFont
import os

def create_icon(size, text, filename):
    # Create a new image with a white background
    image = Image.new('RGB', (size, size), 'white')
    draw = ImageDraw.Draw(image)
    
    # Try to load a font, fallback to default if not available
    try:
        font_size = size // 4
        font = ImageFont.truetype("arial.ttf", font_size)
    except:
        font = ImageFont.load_default()
    
    # Calculate text position to center it
    text_bbox = draw.textbbox((0, 0), text, font=font)
    text_width = text_bbox[2] - text_bbox[0]
    text_height = text_bbox[3] - text_bbox[1]
    x = (size - text_width) // 2
    y = (size - text_height) // 2
    
    # Draw the text
    draw.text((x, y), text, fill='black', font=font)
    
    # Save the image
    image.save(filename)

def main():
    # Create the icons
    create_icon(192, "ICMP", "logo192.png")
    create_icon(512, "ICMP", "logo512.png")
    
    # Create favicon (32x32)
    favicon = Image.new('RGB', (32, 32), 'white')
    draw = ImageDraw.Draw(favicon)
    draw.text((8, 8), "I", fill='black')
    favicon.save("favicon.ico", format='ICO')
    
    print("Static files generated successfully!")

if __name__ == "__main__":
    main()

================================================================================
File: test_enhanced_extraction.py
Path: .\tests\test_enhanced_extraction.py
Size: 10641
Modified: 2025-05-03T19:47:17.663196
Created: 2025-05-03T19:47:15.449547
Hash: 6d02281ee6e6477c10709eba604e2285df43407d2ad7f60e03054fcd73d176f9
Lines: 300
================================================================================
"""
Test Suite for Enhanced Data Extraction

This module provides comprehensive tests for the enhanced data extraction system,
including pattern learning, multi-strategy extraction, and monitoring capabilities.
"""

import unittest
from unittest.mock import Mock, patch
import json
from datetime import datetime, timedelta
import numpy as np
from backend.message_processing.enhanced_data_extraction import EnhancedDataExtraction
from backend.message_processing.pattern_learning import PatternLearningService
from backend.monitoring.extraction_dashboard import ExtractionDashboard

class TestEnhancedDataExtraction(unittest.TestCase):
    """Test cases for EnhancedDataExtraction class."""
    
    def setUp(self):
        """Set up test environment."""
        self.db_pool = Mock()
        self.llm_service = Mock()
        self.extraction_service = EnhancedDataExtraction(self.db_pool, self.llm_service)
        
        # Sample template
        self.template = {
            'template_id': 'test_template',
            'patterns': {
                'amount': r'\$(\d+\.?\d*)',
                'date': r'(\d{2}/\d{2}/\d{4})'
            },
            'business_rules': [
                {
                    'conditions': [
                        {'type': 'contains', 'value': 'payment'}
                    ],
                    'extract': {'type': 'payment'}
                }
            ],
            'categories': [
                {
                    'name': 'payment_type',
                    'keywords': ['credit', 'debit', 'cash']
                }
            ]
        }
        
        # Sample context
        self.context = {
            'message_content': 'Payment of $100.50 made on 01/01/2023 via credit card',
            'conversation_history': 'Previous message about payment',
            'user_preferences': {'preferred_currency': 'USD'}
        }
    
    def test_extract_with_patterns(self):
        """Test pattern-based extraction."""
        result = self.extraction_service._extract_with_patterns(
            self.context['message_content'],
            self.template
        )
        
        self.assertEqual(result['amount'], '100.50')
        self.assertEqual(result['date'], '01/01/2023')
    
    def test_extract_with_llm(self):
        """Test LLM-based extraction."""
        self.llm_service.generate.return_value = json.dumps({
            'amount': '100.50',
            'date': '01/01/2023',
            'payment_type': 'credit'
        })
        
        result = self.extraction_service._extract_with_llm(
            self.context['message_content'],
            self.template,
            self.context
        )
        
        self.assertEqual(result['amount'], '100.50')
        self.assertEqual(result['date'], '01/01/2023')
        self.assertEqual(result['payment_type'], 'credit')
    
    def test_extract_with_rules(self):
        """Test rule-based extraction."""
        result = self.extraction_service._extract_with_rules(
            self.context['message_content'],
            self.template
        )
        
        self.assertEqual(result['type'], 'payment')
    
    def test_extract_with_statistics(self):
        """Test statistical extraction."""
        result = self.extraction_service._extract_with_statistics(
            self.context['message_content'],
            self.template
        )
        
        self.assertEqual(result['payment_type'], 'credit')
        self.assertEqual(result['numerical_values'], [100.50])
    
    def test_combine_results(self):
        """Test result combination with confidence scoring."""
        results = [
            ('pattern', {'amount': '100.50', 'date': '01/01/2023'}),
            ('llm', {'amount': '100.50', 'date': '01/01/2023', 'payment_type': 'credit'}),
            ('rule', {'type': 'payment'}),
            ('statistical', {'payment_type': 'credit', 'numerical_values': [100.50]})
        ]
        
        combined = self.extraction_service._combine_results(
            results,
            self.context['message_content']
        )
        
        self.assertEqual(combined['amount'], '100.50')
        self.assertEqual(combined['date'], '01/01/2023')
        self.assertEqual(combined['payment_type'], 'credit')
        self.assertEqual(combined['type'], 'payment')
        self.assertIn('_confidence_scores', combined)
    
    def test_store_successful_pattern(self):
        """Test pattern storage."""
        result = {
            'amount': '100.50',
            'date': '01/01/2023',
            'payment_type': 'credit'
        }
        
        self.extraction_service._store_successful_pattern(
            self.context['message_content'],
            self.template,
            result
        )
        
        # Verify pattern was stored
        self.assertIn(
            self.extraction_service._create_pattern_signature(
                self.context['message_content'],
                self.template
            ),
            self.extraction_service.pattern_database
        )

class TestPatternLearningService(unittest.TestCase):
    """Test cases for PatternLearningService class."""
    
    def setUp(self):
        """Set up test environment."""
        self.db_pool = Mock()
        self.learning_service = PatternLearningService(self.db_pool)
        
        # Sample data
        self.message = "Payment of $100.50 made on 01/01/2023"
        self.template = {'template_id': 'test_template'}
        self.extracted_data = {
            'amount': '100.50',
            'date': '01/01/2023'
        }
    
    def test_learn_from_extraction(self):
        """Test learning from successful extraction."""
        self.learning_service.learn_from_extraction(
            self.message,
            self.template,
            self.extracted_data,
            success=True
        )
        
        # Verify cluster was created
        cluster_id = self.learning_service._get_cluster_id(
            self.message,
            self.template
        )
        self.assertIn(cluster_id, self.learning_service.pattern_clusters)
    
    def test_get_improved_patterns(self):
        """Test getting improved patterns."""
        # First learn from some extractions
        self.learning_service.learn_from_extraction(
            self.message,
            self.template,
            self.extracted_data,
            success=True
        )
        
        improved_patterns = self.learning_service.get_improved_patterns(
            self.template['template_id']
        )
        
        self.assertIsInstance(improved_patterns, dict)
    
    def test_add_feedback(self):
        """Test adding user feedback."""
        extraction_id = 'test_extraction'
        feedback = {
            'correct': True,
            'notes': 'Good extraction'
        }
        
        self.learning_service.add_feedback(extraction_id, feedback)
        
        self.assertIn(extraction_id, self.learning_service.feedback_history)
        self.assertEqual(
            self.learning_service.feedback_history[extraction_id][-1]['feedback'],
            feedback
        )

class TestExtractionDashboard(unittest.TestCase):
    """Test cases for ExtractionDashboard class."""
    
    def setUp(self):
        """Set up test environment."""
        self.db_pool = Mock()
        self.dashboard = ExtractionDashboard(self.db_pool)
        
        # Mock database cursor
        self.cursor = Mock()
        self.db_pool.getconn.return_value.cursor.return_value = self.cursor
    
    def test_get_overview_stats(self):
        """Test getting overview statistics."""
        # Mock database results
        self.cursor.fetchone.side_effect = [
            (100, 80, 20),  # Total extractions
            (50, 0.85, 40),  # Pattern statistics
            (10, 8, 2)  # Recent performance
        ]
        
        stats = self.dashboard.get_overview_stats()
        
        self.assertEqual(stats['total_extractions'], 100)
        self.assertEqual(stats['successful_extractions'], 80)
        self.assertEqual(stats['success_rate'], 0.8)
        self.assertEqual(stats['total_patterns'], 50)
        self.assertEqual(stats['avg_success_rate'], 0.85)
    
    def test_get_performance_trends(self):
        """Test getting performance trends."""
        # Mock database results
        dates = [
            datetime.now() - timedelta(days=i)
            for i in range(7)
        ]
        self.cursor.fetchall.return_value = [
            (date, 10, 8, 2)
            for date in dates
        ]
        
        trends = self.dashboard.get_performance_trends()
        
        self.assertIn('trend_data', trends)
        self.assertIn('trend_plot', trends)
        self.assertEqual(len(trends['trend_data']), 7)
    
    def test_get_pattern_analysis(self):
        """Test getting pattern analysis."""
        # Mock database results
        self.cursor.fetchall.return_value = [
            ('amount', 50, 0.9, 1.0, 0.8),
            ('date', 40, 0.85, 0.95, 0.75)
        ]
        
        analysis = self.dashboard.get_pattern_analysis()
        
        self.assertIn('pattern_stats', analysis)
        self.assertIn('pattern_plot', analysis)
        self.assertEqual(len(analysis['pattern_stats']), 2)
    
    def test_get_error_analysis(self):
        """Test getting error analysis."""
        # Mock database results
        self.cursor.fetchall.return_value = [
            ('pattern_not_found', 10),
            ('invalid_format', 5)
        ]
        
        analysis = self.dashboard.get_error_analysis()
        
        self.assertIn('error_stats', analysis)
        self.assertIn('error_plot', analysis)
        self.assertEqual(len(analysis['error_stats']), 2)
    
    def test_get_template_performance(self):
        """Test getting template performance."""
        # Mock database results
        self.cursor.fetchall.return_value = [
            ('template1', 'Test Template 1', 100, 80, 0.85),
            ('template2', 'Test Template 2', 50, 40, 0.8)
        ]
        
        performance = self.dashboard.get_template_performance()
        
        self.assertIn('template_stats', performance)
        self.assertIn('template_plot', performance)
        self.assertEqual(len(performance['template_stats']), 2)

if __name__ == '__main__':
    unittest.main() 

