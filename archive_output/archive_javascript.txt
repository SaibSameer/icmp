================================================================================
File: App.js
Path: .\backend\App.js
Size: 466
Modified: 2025-03-30T16:55:10.402513
Created: 2025-03-28T21:45:20.764993
Hash: 5264420b15662214d0f1c9272be3aa08b1e1de00cb63748768a82f093ce53cd4
Lines: 19
================================================================================
// File: src/App.js
// Last Modified: 2026-03-29
import React from 'react';
import MyInterface from './components/MyInterface';
import './App.css';
import Container from '@mui/material/Container';
import Typography from '@mui/material/Typography';

function App() {
    return (
        <Container maxWidth="md">
            <div className="App">
                <MyInterface />
            </div>
        </Container>
    );
}

export default App;

================================================================================
File: BusinessManagement.js
Path: .\components\BusinessManagement.js
Size: 2086
Modified: 2025-03-30T15:14:09.453086
Created: 2025-03-29T03:37:07.424202
Hash: 1e0ca6ae327059e13f397d490c8bcf524a40256e4c1e37cd2fe206fd0dd81761
Lines: 43
================================================================================
// File: src/components/BusinessManagement.js
// Last Modified: 2026-03-29

import React, { useState } from 'react';
import { TextField, Button, Typography, Card, CardContent, Box } from '@mui/material';
import { fetchBusinessDetails as fetchBusinessDetailsApi } from '../services/testService';

function BusinessManagement({ businessName, setBusinessName, businessOutput, setBusinessOutput, fetchBusinessDetails, handleSnackbarOpen, apiKey, businessId, }) {
    const handleFetchBusinessDetails = async () => {
        if (!businessId) {
            setBusinessOutput("Please enter a Business ID.");
            handleSnackbarOpen("Please enter a Business ID.", "warning")
            return;
        }
        try {
            const response = await fetchBusinessDetailsApi(businessId, apiKey)
            //setBusinessOutput("Business endpoint not implemented yet.");

            setBusinessOutput(JSON.stringify(response, null, 2)); // this data will be displayed in json form
            handleSnackbarOpen("Business endpoint Fetched!", "info")

        } catch (error) {
            setBusinessOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    return (
        <Card sx={{ mt: 2 }}>
            <CardContent>
                <Typography variant="h6" gutterBottom>Business Management</Typography>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
                    <TextField label="Business Name" variant="outlined" value={businessName} onChange={(e) => setBusinessName(e.target.value)} />
                    <Button variant="contained" onClick={() => console.log("Create Business not yet implemented")}>Create Business</Button>
                    <Button variant="contained" onClick={handleFetchBusinessDetails}>Fetch Business Details</Button>
                    <Typography variant="body1">{businessOutput}</Typography>
                </Box>
            </CardContent>
        </Card>
    );
}

export default BusinessManagement;

================================================================================
File: ErrorDisplay.js
Path: .\components\ErrorDisplay.js
Size: 224
Modified: 2025-03-30T15:14:09.462063
Created: 2025-03-28T17:41:15.357819
Hash: d9fc498ba30cb164ed56c300c6edf9f0fb76b8d6bc96582cc60bf92532c6a91d
Lines: 11
================================================================================
import React from 'react';

function ErrorDisplay({ message }) {
  return (
    <div style={{ color: 'red', margin: '10px' }}>
      <strong>Error:</strong> {message}
    </div>
  );
}

export default ErrorDisplay;

================================================================================
File: HealthCheck.js
Path: .\components\HealthCheck.js
Size: 1423
Modified: 2025-03-30T15:14:09.475024
Created: 2025-03-28T17:39:08.379094
Hash: 512cab4c2319857d95d17ed057110949f55f7561632c64a0c8240a4a459fc598
Lines: 52
================================================================================
import React, { useState, useEffect } from 'react';
import { getHealthCheck } from '../services/healthCheckService';
import ErrorDisplay from './ErrorDisplay';
import LoadingIndicator from './LoadingIndicator';
import './HealthCheck.css'; // Import the CSS file

function HealthCheck() {
  const [healthData, setHealthData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchHealthData = async () => {
      setLoading(true);
      setError(null);
      try {
        const data = await getHealthCheck();
        setHealthData(data);
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    };

    fetchHealthData();
  }, []);

  if (loading) {
    return <LoadingIndicator />;
  }

  if (error) {
    return <ErrorDisplay message={error} />;
  }

  return (
    <div className="health-check-container">
      <h2>Health Check</h2>
      {healthData && (
        <div className="health-data">
          <p><strong>Status:</strong> {healthData.status}</p>
          <p><strong>Date:</strong> {healthData.date}</p>
          <p><strong>Database:</strong> {healthData.database}</p>
          <p><strong>Schemas Loaded:</strong> {healthData.schemas_loaded}</p>
        </div>
      )}
    </div>
  );
}

export default HealthCheck;

================================================================================
File: healthCheckService.js
Path: .\components\healthCheckService.js
Size: 932
Modified: 2025-03-30T15:14:09.483006
Created: 2025-03-28T17:42:18.913431
Hash: e364d21ff4f3ea3a30733aa443fb79020d6c27097888ea0fc14c9f45a21519c6
Lines: 26
================================================================================
const API_KEY = 'YOUR_API_KEY'; // Replace with your actual API key
const API_ENDPOINT = '/health'; // Replace with your API endpoint if different

export const getHealthCheck = async () => {
  try {
    const response = await fetch(API_ENDPOINT, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${API_KEY}`,
        'Content-Type': 'application/json'  // Ensure Content-Type is set
      }
    });

    if (!response.ok) {
      const errorData = await response.json(); // Try to get error message from API
      const errorMessage = errorData.message || `HTTP error! Status: ${response.status}`;
      throw new Error(errorMessage); // Throw the API's error message
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error fetching health check:", error);
    throw error; // Re-throw the error for the component to handle
  }
};

================================================================================
File: LoadingIndicator.js
Path: .\components\LoadingIndicator.js
Size: 184
Modified: 2025-03-30T15:14:09.489986
Created: 2025-03-28T17:41:50.839494
Hash: 3bda0a8d4ad1de87eaee4f894d9778482b4a34dc7e347851a408a7b2ebdbc5be
Lines: 11
================================================================================
import React from 'react';

function LoadingIndicator() {
  return (
    <div style={{ margin: '10px' }}>
      Loading...
    </div>
  );
}

export default LoadingIndicator;

================================================================================
File: Login.js
Path: .\components\Login.js
Size: 4680
Modified: 2025-04-12T19:06:37.849865
Created: 2025-04-06T15:48:18.667110
Hash: 129e9657e9177cd3ddd7e9bc29bfbdddffe231da8aa15e49a2965ea07de89d76
Lines: 116
================================================================================
import React, { useState } from 'react';
import { TextField, Button, Typography, Card, CardContent, Box, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { API_CONFIG, AUTH_CONFIG } from '../config';
import { login } from '../services/authService';

function Login({ 
    setIsAuthenticated, 
    handleSnackbarOpen,
    setUserId,
    setBusinessId,
    setBusinessApiKey
}) {
    const [isLoading, setIsLoading] = useState(false);
    const [userIdInput, setUserIdInput] = useState(API_CONFIG.DEFAULTS.USER_ID);
    const [businessIdInput, setBusinessIdInput] = useState(API_CONFIG.DEFAULTS.BUSINESS_ID);
    const [businessApiKeyInput, setBusinessApiKeyInput] = useState(API_CONFIG.DEFAULTS.API_KEY);
    const navigate = useNavigate();

    const handleSubmit = async (event) => {
        event.preventDefault();
        setIsLoading(true);

        // Trim inputs to avoid whitespace issues
        const trimmedUserId = userIdInput.trim();
        const trimmedBusinessId = businessIdInput.trim();
        const trimmedBusinessApiKey = businessApiKeyInput.trim();

        try {
            console.log('Logging in with:', {
                userId: trimmedUserId,
                businessId: trimmedBusinessId,
                businessApiKey: trimmedBusinessApiKey
            });

            const data = await login(trimmedUserId, trimmedBusinessId, trimmedBusinessApiKey);
            
            if (data.success) {
                // Update parent state
                setUserId(trimmedUserId);
                setBusinessId(trimmedBusinessId);
                setBusinessApiKey(trimmedBusinessApiKey);

                handleSnackbarOpen('Login successful', 'success');
                setIsAuthenticated(true);
                navigate('/');
            } else {
                throw new Error(data.error || 'Login failed');
            }
        } catch (error) {
            console.error('Login error:', error);
            handleSnackbarOpen(error.message || 'Login failed', 'error');
            setIsAuthenticated(false);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Card sx={{ mt: 4, maxWidth: 400, mx: 'auto' }}>
            <CardContent>
                <Typography variant="h5" gutterBottom align="center">
                    Login
                </Typography>
                <Box component="form" onSubmit={handleSubmit} sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
                    <TextField 
                        label="User ID" 
                        variant="outlined" 
                        value={userIdInput}
                        onChange={(e) => setUserIdInput(e.target.value)}
                        disabled={isLoading}
                        required
                        error={!userIdInput}
                        helperText={!userIdInput ? "User ID is required" : ""}
                        fullWidth
                    />
                    <TextField 
                        label="Business ID" 
                        variant="outlined" 
                        value={businessIdInput}
                        onChange={(e) => setBusinessIdInput(e.target.value)}
                        disabled={isLoading}
                        required
                        error={!businessIdInput}
                        helperText={!businessIdInput ? "Business ID is required" : ""}
                        fullWidth
                    />
                    <TextField
                        label="Business API Key"
                        variant="outlined"
                        value={businessApiKeyInput}
                        onChange={(e) => setBusinessApiKeyInput(e.target.value)}
                        disabled={isLoading}
                        type="password"
                        required
                        error={!businessApiKeyInput}
                        helperText={!businessApiKeyInput ? "Business API Key is required" : ""}
                        fullWidth
                    />
                    <Button 
                        type="submit" 
                        variant="contained" 
                        color="primary" 
                        disabled={isLoading}
                        fullWidth
                    >
                        {isLoading ? <CircularProgress size={24} /> : 'Login'}
                    </Button>
                </Box>
            </CardContent>
        </Card>
    );
}

export default Login;


================================================================================
File: MyInterface.js
Path: .\components\MyInterface.js
Size: 13679
Modified: 2025-03-30T15:14:09.501689
Created: 2025-03-28T18:40:04.865679
Hash: e08b77330a801b27c13195cdbbd17c8481471809996b4e32f235acbc8e9f7c6f
Lines: 285
================================================================================
// File: src/components/MyInterface.js
// Last Modified: 2026-03-30
import React, { useState, useEffect } from 'react';
import './MyInterface.css';
import {
    TextField, Button, Typography, Card, CardContent, Box, TextareaAutosize,
    Snackbar, Alert, Grid, Select, MenuItem, InputLabel, FormControl
} from '@mui/material';
import {
    saveConfig as saveConfigApi,
    createUser as createUserApi,
    fetchBusinessDetails as fetchBusinessDetailsApi,
    createTemplate as createTemplateApi,
    fetchTemplates as fetchTemplatesApi,
    createStage as createStageApi,
    fetchStages as fetchStagesApi,
    processMessage as processMessageApi,
    getStage as getStageApi, // new one
    updateStage as updateStageApi, // new one
    getDefaultTemplates as getDefaultTemplatesApi,
    saveDefaultTemplate as saveDefaultTemplateApi // new api end point
} from '../services/testService'
import Configuration from './Configuration';
import UserManagement from './UserManagement';
import BusinessManagement from './BusinessManagement';
import TemplateManagement from './TemplateManagement';
import StageManagement from './StageManagement';
import SendMessage from './SendMessage';

function MyInterface() {
    const [apiKey, setApiKey] = useState(localStorage.getItem('icmpApiKey') || '');
    const [userId, setUserId] = useState('');
    const [businessId, setBusinessId] = useState('');
    const [defaultTemplates, setDefaultTemplates] = React.useState([]);
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [email, setEmail] = useState('');
    const [availableVariable, setAvailableVariable] = React.useState([]);
    const [selectedVariable, setSelectedVariable] = React.useState('');
    const [businessName, setBusinessName] = useState('');
    const [templateID, setTemplateID] = React.useState('');
    const [templateName, setTemplateName] = useState('');
    const [templateText, setTemplateText] = useState('');
    const [stageId, setStageId] = useState(''); // Stage ID for editing
    const [stageName, setStageName] = useState('');
    const [stageDescription, setStageDescription] = useState('');
    const [stageType, setStageType] = useState('');
    const [selectionTemplateId, setSelectionTemplateId] = useState('');
    const [selectionCustomPrompt, setSelectionCustomPrompt] = useState('');
    const [extractionTemplateId, setExtractionTemplateId] = useState('');
    const [extractionCustomPrompt, setExtractionCustomPrompt] = useState('');
    const [responseTemplateId, setResponseTemplateId] = useState('');
    const [responseCustomPrompt, setResponseCustomPrompt] = useState('');
    const [messageInput, setMessageInput] = useState('');

    const [configOutput, setConfigOutput] = useState('');
    const [userOutput, setUserOutput] = useState('');
    const [businessOutput, setBusinessOutput] = useState('');
    const [templateOutput, setTemplateOutput] = useState('');
    const [stageOutput, setStageOutput] = useState('');
    const [messageOutput, setMessageOutput] = useState('');

    // Snackbar
    const [snackbarOpen, setSnackbarOpen] = useState(false);
    const [snackbarMessage, setSnackbarMessage] = useState('');
    const [snackbarSeverity, setSnackbarSeverity] = useState('success'); // or 'error'

    // Open and close snackbar
    const handleSnackbarOpen = (message, severity) => {
        setSnackbarMessage(message);
        setSnackbarSeverity(severity);
        setSnackbarOpen(true);
    };

    const handleSnackbarClose = (event, reason) => {
        if (reason === 'clickaway') {
            return;
        }
        setSnackbarOpen(false);
    };

    // Configuration
    const saveConfig = async () => {
        try {
            const response = await saveConfigApi(apiKey, userId, businessId)
            localStorage.setItem('icmpApiKey', apiKey);
            setConfigOutput(`Configuration Saved:\nUser ID: ${userId}\nBusiness ID: ${businessId}\nAPI Key: ${apiKey}`);
            handleSnackbarOpen("Configuration Saved!", "success")

        } catch (error) {
            setConfigOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    //user section
    const createUser = async () => {
        try {
            const response = await createUserApi(firstName, lastName, email)
            setUserOutput("User Created (dummy)");
            handleSnackbarOpen("User Created!", "success")

        } catch (error) {
            setUserOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")

        }
    };

    const fetchBusinessDetails = async () => {
        if (!businessId) {
            setBusinessOutput("Please enter a Business ID.");
            handleSnackbarOpen("Please enter a Business ID.", "warning")
            return;
        }
        try {
            const response = await fetchBusinessDetailsApi(businessId, apiKey)
            setBusinessOutput("Business endpoint not implemented yet.");
            handleSnackbarOpen("Business endpoint not implemented yet.", "info")

        } catch (error) {
            setBusinessOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")

        }
    };

    const createTemplate = async () => {
        const templateData = {
            template_name: templateName,
            template_text: templateText
        };
        try {
            const data = await createTemplateApi(templateData, apiKey)
            setTemplateOutput(`Template Created: ${data.template_id}`);
            handleSnackbarOpen(`Template Created: ${data.template_id}`, "success")
        } catch (error) {
            setTemplateOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")

        }
    };

    const fetchTemplates = async () => {
        try {
            const data = await fetchTemplatesApi(apiKey)
            setTemplateOutput(JSON.stringify(data, null, 2));
            handleSnackbarOpen("Templates Fetched!", "success")

        } catch (error) {
            setTemplateOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    const addVariableToTemplate = () => {
        // Combine the static and dynamic variables
        let newTemplateText = templateText + "{" + selectedVariable + "}";
        setTemplateText(newTemplateText);
    };

    const handleTemplateSelection = (event) => {
        const selectedTemplateId = event.target.value;
        setTemplateID(selectedTemplateId);
        // Find the selected template object
        const selectedTemplate = defaultTemplates.find(template => template.template_id === selectedTemplateId);

        // If the template is found, update the templateText state
        if (selectedTemplate) {
            setTemplateText(selectedTemplate.template_text);
        } else {
            setTemplateText(''); // Clear the template text if the template is not found
        }

    };

    const handleSaveDefaultTemplate = async () => {
        try {
            const templateData = {
                template_name: templateName,
                template_text: templateText
            };
            // const data = await createTemplateApi(templateData, apiKey)
            // await saveDefaultTemplateApi(templateData, apiKey); // Implement API call to save the current template to defaults
            setTemplateOutput(`Template Saved to Defaults: ${templateID}`);
            handleSnackbarOpen(`Template Saved to Defaults: ${templateID}`, "success");

        } catch (error) {
            handleSnackbarOpen(`Error saving template: ${error.message}`, "error");
        }
    };

    const handleVariableSelection = (event) => {
        setSelectedVariable(event.target.value);
    };
    //stage section
    const createStage = async () => {
        const stageData = {
            business_id: businessId,
            stage_name: stageName,
            stage_description: stageDescription,
            stage_type: stageType,
            selection_template_id: selectionTemplateId || null,
            selection_custom_prompt: selectionCustomPrompt || null,
            extraction_template_id: extractionTemplateId || null,
            extraction_custom_prompt: extractionCustomPrompt || null,
            response_template_id: responseTemplateId || null,
            response_custom_prompt: responseCustomPrompt || null
        };

        try {
            const data = await createStageApi(stageData, apiKey)
            setStageOutput(`Stage Created: ${data.stage_id}`);
            handleSnackbarOpen(`Stage Created: ${data.stage_id}`, "success")
        } catch (error) {
            setStageOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    const fetchStages = async () => {
        if (!businessId) {
            setStageOutput("Please enter a Business ID.");
            handleSnackbarOpen("Please enter a Business ID.", "warning");

            return;
        }
        try {
            const data = await fetchStagesApi(businessId, apiKey)
            setStageOutput(JSON.stringify(data, null, 2));
            handleSnackbarOpen("Stages Fetched!", "success")

        } catch (error) {
            setStageOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    const processMessage = async () => {
        const messageData = {
            business_id: businessId,
            user_id: userId,
            message: messageInput
        };
        try {
            const data = await processMessageApi(messageData, apiKey)
            setMessageOutput(`Response: ${data.response}\nConversation ID: ${data.conversation_id}`);
            handleSnackbarOpen(`Response: ${data.response}\nConversation ID: ${data.conversation_id}`, "success")

        } catch (error) {
            setMessageOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    useEffect(() => {
        // When the app load, load the API KEY
        const storedApiKey = localStorage.getItem('icmpApiKey');
        if (storedApiKey) {
            setApiKey(storedApiKey);
        }
    }, []);

    return (
        <div className="container">
            <Typography variant="h4" align="center" gutterBottom>ICMP Proof of Concept</Typography>

            <Configuration apiKey={apiKey} setApiKey={setApiKey} userId={userId} setUserId={setUserId} businessId={businessId} setBusinessId={setBusinessId} handleSnackbarOpen={handleSnackbarOpen} />
            <UserManagement firstName={firstName} setFirstName={setFirstName} lastName={lastName} setLastName={setLastName} email={email} setEmail={setEmail} userOutput={userOutput} createUser={createUser} handleSnackbarOpen={handleSnackbarOpen} />
            <BusinessManagement businessName={businessName} setBusinessName={setBusinessName} businessOutput={businessOutput} fetchBusinessDetails={fetchBusinessDetails} handleSnackbarOpen={handleSnackbarOpen} />
            <TemplateManagement templateID={templateID} setTemplateID={setTemplateID} availableVariable={availableVariable} setAvailableVariable={setAvailableVariable} selectedVariable={selectedVariable} setSelectedVariable={setSelectedVariable} handleTemplateSelection={handleTemplateSelection} handleVariableSelection={handleVariableSelection} addVariableToTemplate={addVariableToTemplate} templateName={templateName} setTemplateName={setTemplateName} templateText={templateText} setTemplateText={setTemplateText} templateOutput={templateOutput} createTemplate={createTemplate} fetchTemplates={fetchTemplates} handleSnackbarOpen={handleSnackbarOpen} />
            <StageManagement stageId={stageId} setStageId={setStageId} stageName={stageName} setStageName={setStageName} stageDescription={stageDescription} setStageDescription={setStageDescription} stageType={stageType} setStageType={setStageType} selectionTemplateId={selectionTemplateId} setSelectionTemplateId={setSelectionTemplateId} selectionCustomPrompt={selectionCustomPrompt} setSelectionCustomPrompt={setSelectionCustomPrompt} extractionTemplateId={extractionTemplateId} setExtractionTemplateId={setExtractionTemplateId} extractionCustomPrompt={extractionCustomPrompt} setExtractionCustomPrompt={setExtractionCustomPrompt} responseTemplateId={responseTemplateId} setResponseTemplateId={setResponseTemplateId} responseCustomPrompt={responseCustomPrompt} setResponseCustomPrompt={setResponseCustomPrompt} stageOutput={stageOutput} createStage={createStage} updateStage={processMessage} fetchStages={fetchStages} handleSnackbarOpen={handleSnackbarOpen} />
            <SendMessage messageInput={messageInput} setMessageInput={setMessageInput} messageOutput={messageOutput} processMessage={processMessage} handleSnackbarOpen={handleSnackbarOpen} />

            {/* Snackbar for notifications */}
            <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={handleSnackbarClose} anchorOrigin={{ vertical: 'bottom', horizontal: 'left' }}>
                <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
                    {snackbarMessage}
                </Alert>
            </Snackbar>
        </div>
    );
}

export default MyInterface;

================================================================================
File: babel.config.js
Path: .\front-end\babel.config.js
Size: 190
Modified: 2025-04-02T00:33:49.341542
Created: 2025-04-02T00:27:15.608115
Hash: da5dcba91bead64c9fc735395803bc0eb836f96484d4b5ff644ce12556d4c97e
Lines: 9
================================================================================
module.exports = {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }],
    '@babel/preset-react'
  ],
  plugins: [
    '@babel/plugin-transform-runtime'
  ]
}; 

================================================================================
File: jest.config.js
Path: .\front-end\jest.config.js
Size: 576
Modified: 2025-04-02T01:10:31.631716
Created: 2025-04-02T00:18:56.960119
Hash: b1d7165b0f62558fc4e4569b657cc475ceae2de6e07eb73464cae92fa052f22c
Lines: 21
================================================================================
module.exports = {
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.(js|jsx)$': 'babel-jest',
  },
  transformIgnorePatterns: [
    '/node_modules/(?!(axios)/)'
  ],
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapper: {
    '\\.(css|less|sass|scss)$': 'identity-obj-proxy',
    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js'
  },
  testMatch: ['**/__tests__/**/*.js', '**/?(*.)+(spec|test).js'],
  verbose: true,
  collectCoverage: true,
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/__tests__/'
  ]
};

================================================================================
File: App.js
Path: .\front-end\src\App.js
Size: 5250
Modified: 2025-04-12T16:07:23.566633
Created: 2025-03-28T18:55:14.288411
Hash: 02254cafa96150b73a03f9a1994de8815253b42c6004db52d56cc0d965ef788b
Lines: 173
================================================================================
// src/App.js
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Container, CssBaseline, ThemeProvider, createTheme, Box } from '@mui/material';
import Login from './components/Login';
import BusinessDetailsView from './components/BusinessDetailsView/BusinessDetailsView.jsx';
import StageManager from './components/StageManager';
import TemplateEditor from './components/TemplateEditor';
import TemplateManagement from './components/TemplateManagement';
import Snackbar from '@mui/material/Snackbar';
import Alert from '@mui/material/Alert';
import Header from './components/Header';
import Footer from './components/Footer';
import Home from './components/Home';
import StageViewPage from './pages/StageViewPage';
import MessageDebugPage from './pages/MessageDebugPage';
import { UI_CONFIG } from './config';
import { AuthProvider, useAuth } from './contexts/AuthContext';
import './App.css';

const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

function AppContent() {
  const { isAuthenticated, userId, businessId, businessApiKey, setUserId, setBusinessId, setBusinessApiKey, setIsAuthenticated } = useAuth();
  const [snackbar, setSnackbar] = React.useState({ open: false, message: '', severity: 'success' });

  const handleSnackbarOpen = (message, severity = 'success') => {
    setSnackbar({ open: true, message, severity });
  };

  const handleSnackbarClose = () => {
    setSnackbar({ ...snackbar, open: false });
  };

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
      <Header />
      <Container component="main" sx={{ flexGrow: 1, py: 3 }}>
        <Routes>
          <Route 
            path="/" 
            element={
              isAuthenticated ? (
                <Navigate to="/business" replace />
              ) : (
                <Navigate to="/login" replace />
              )
            } 
          />
          <Route 
            path="/stages" 
            element={
              isAuthenticated ? <StageManager /> : <Navigate to="/login" replace />
            } 
          />
          <Route 
            path="/stages/:stageId" 
            element={
              isAuthenticated ? <StageViewPage /> : <Navigate to="/login" replace />
            } 
          />
          <Route 
            path="/stage-management/business_id=:businessId/agent_id=:agentId" 
            element={
              isAuthenticated ? <StageManager /> : <Navigate to="/login" replace />
            } 
          />
          <Route 
            path="/debug/conversation/:conversationId" 
            element={
              isAuthenticated ? <MessageDebugPage /> : <Navigate to="/login" replace />
            } 
          />
          <Route 
            path="/login" 
            element={
              isAuthenticated ? (
                <Navigate to="/business" replace />
              ) : (
                <Login 
                  userId={userId}
                  setUserId={setUserId}
                  businessId={businessId}
                  setBusinessId={setBusinessId}
                  businessApiKey={businessApiKey}
                  setBusinessApiKey={setBusinessApiKey}
                  setIsAuthenticated={setIsAuthenticated}
                  handleSnackbarOpen={handleSnackbarOpen}
                />
              )
            } 
          />
          <Route 
            path="/business" 
            element={
              isAuthenticated ? (
                <BusinessDetailsView />
              ) : (
                <Navigate to="/login" replace />
              )
            } 
          />
          <Route 
            path="/templates" 
            element={
              isAuthenticated ? (
                <TemplateManagement />
              ) : (
                <Navigate to="/login" replace />
              )
            } 
          />
          <Route 
            path="/template-editor/:templateId" 
            element={
              isAuthenticated ? (
                <TemplateEditor />
              ) : (
                <Navigate to="/login" replace />
              )
            } 
          />
          <Route 
            path="/template-editor/new" 
            element={
              isAuthenticated ? (
                <TemplateEditor />
              ) : (
                <Navigate to="/login" replace />
              )
            } 
          />
        </Routes>
      </Container>
      <Footer />
      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={UI_CONFIG.SNACKBAR.AUTO_HIDE_DURATION} 
        onClose={handleSnackbarClose}
        anchorOrigin={UI_CONFIG.SNACKBAR.POSITION}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
}

function App() {
  return (
    <Router>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <AuthProvider>
          <AppContent />
        </AuthProvider>
      </ThemeProvider>
    </Router>
  );
}

export default App;

================================================================================
File: config.js
Path: .\front-end\src\config.js
Size: 1394
Modified: 2025-04-12T18:46:40.636670
Created: 2025-04-08T13:30:30.684730
Hash: 715776b1a05bca300b9ba6664d12104830045437d8fc37e9329e582f8e0989ce
Lines: 62
================================================================================
// Configuration settings for the application

// API Configuration
const API_CONFIG = {
  // Base URL for API requests
  BASE_URL: process.env.REACT_APP_API_BASE_URL || 'http://localhost:5000',
  
  // API endpoints
  ENDPOINTS: {
    LOGIN: '/api/save-config',
    MESSAGE: '/api/message',
    CONVERSATIONS: '/conversations',
    BUSINESSES: '/businesses',
    STAGES: '/stages',
    TEMPLATES: '/api/templates',
    DEBUG: '/debug'
  },
  
  // Default values
  DEFAULTS: {
    BUSINESS_ID: '1c8cde77-0306-42dd-a0b6-c366a07651ad',
    API_KEY: 'default_api_key',
    USER_ID: '00000000-0000-0000-0000-000000000000'
  }
};

// Log API configuration for debugging
console.log('API Configuration:', {
  baseUrl: API_CONFIG.BASE_URL,
  endpoints: API_CONFIG.ENDPOINTS
});

// Authentication settings
const AUTH_CONFIG = {
  // Cookie names
  COOKIES: {
    BUSINESS_API_KEY: 'businessApiKey'
  },
  
  // Local storage keys
  STORAGE_KEYS: {
    USER_ID: 'userId',
    BUSINESS_ID: 'businessId',
    BUSINESS_API_KEY: 'businessApiKey'
  }
};

// UI Configuration
const UI_CONFIG = {
  // Snackbar settings
  SNACKBAR: {
    AUTO_HIDE_DURATION: 6000,
    POSITION: { vertical: 'top', horizontal: 'center' }
  },
  
  // Debug panel settings
  DEBUG_PANEL: {
    ID: 'debugPanel'
  }
};

export { API_CONFIG, AUTH_CONFIG, UI_CONFIG }; 

================================================================================
File: index.js
Path: .\front-end\src\index.js
Size: 550
Modified: 2025-03-30T15:14:09.569308
Created: 2025-03-28T18:54:14.864247
Hash: a0485d1062e8b675955592c0d51a2dcba12c2c9b70ad88f3efa98e14dd34debf
Lines: 17
================================================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

================================================================================
File: jest.setup.js
Path: .\front-end\src\jest.setup.js
Size: 1873
Modified: 2025-04-02T00:58:32.763757
Created: 2025-04-02T00:28:59.398894
Hash: 8183753a7bf9aaa22dcdd7254c2a999e549d636567b770f7796ea83cfb9cbb48
Lines: 87
================================================================================
import '@testing-library/jest-dom';
import 'jest-canvas-mock';

// Mock axios
const mockAxios = {
  get: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  delete: jest.fn()
};

jest.mock('axios', () => ({
  __esModule: true,
  default: mockAxios
}));

// Mock fetch
const mockFetch = jest.fn(() =>
  Promise.resolve({
    ok: true,
    json: () => Promise.resolve({})
  })
);
mockFetch.mockClear = jest.fn();
global.fetch = mockFetch;

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
global.localStorage = localStorageMock;

// Mock useNavigate
const mockNavigate = jest.fn();
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => mockNavigate
}));

// Mock useConfig hook
jest.mock('../hooks/useConfig', () => ({
  __esModule: true,
  default: () => ({
    config: {
      apiKey: 'test_api_key',
      userId: 'test_user',
      businessId: 'test_business',
      businessApiKey: 'test_business_key'
    },
    setConfig: jest.fn(),
    loading: false,
    error: null
  })
}));

// Mock useBusiness hook
jest.mock('../hooks/useBusiness', () => ({
  __esModule: true,
  default: () => ({
    business: {
      id: 'test_business',
      name: 'Test Business',
      apiKey: 'test_business_key'
    },
    setBusiness: jest.fn(),
    loading: false,
    error: null
  })
}));

================================================================================
File: reportWebVitals.js
Path: .\front-end\src\reportWebVitals.js
Size: 373
Modified: 2025-03-30T15:14:09.579439
Created: 2025-03-28T20:45:25.341227
Hash: a1178ce3b04297218a756cc0c68f640336e25727e03200b5997f04677f9ff954
Lines: 13
================================================================================
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================================================================================
File: setupTests.js
Path: .\front-end\src\setupTests.js
Size: 1144
Modified: 2025-04-02T02:19:01.584595
Created: 2025-04-01T13:38:51.018812
Hash: 942009893ab9474350e826e639560e566553d62f65784ba00134f8cced2da7aa
Lines: 48
================================================================================
import '@testing-library/jest-dom';
import { configure } from '@testing-library/react';
import { act } from 'react';

// Increase test timeout
jest.setTimeout(10000);

// Configure testing-library
configure({
  asyncUtilTimeout: 5000,
  testIdAttribute: 'data-testid',
});

// Configure global test environment
global.React = { act };

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// Setup fetch mock
global.fetch = jest.fn();

// Helper to reset all mocks
beforeEach(() => {
  global.fetch.mockClear();
  jest.clearAllMocks();
});

// Add fetch mock implementations
global.fetch.mockImplementation(() => Promise.resolve({
  ok: true,
  json: () => Promise.resolve({}),
}));

// Configure MUI for testing environment
window.HTMLElement.prototype.scrollIntoView = jest.fn(); 

================================================================================
File: test-utils.js
Path: .\front-end\src\test-utils.js
Size: 2555
Modified: 2025-04-06T00:28:27.671746
Created: 2025-04-02T02:09:40.402565
Hash: 26befafe492a7aa549029fad10d58acbd79582f3ba580f7cf1f66cc6990f4037
Lines: 92
================================================================================
import React from 'react';
import { render } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';

// Custom render function that includes router context
const customRender = (ui, options = {}) => {
  return render(ui, {
    wrapper: ({ children }) => (
      <BrowserRouter>
        {children}
      </BrowserRouter>
    ),
    ...options,
  });
};

// Mock template data
export const mockTemplates = {
  stage_selection: [
    {
      template_id: 'template1',
      template_name: 'Stage Selection Template',
      template_type: 'stage_selection',
      template_text: 'Test stage selection template'
    }
  ],
  data_extraction: [
    {
      template_id: 'template2',
      template_name: 'Data Extraction Template',
      template_type: 'data_extraction',
      template_text: 'Test data extraction template'
    }
  ],
  response_generation: [
    {
      template_id: 'template3',
      template_name: 'Response Generation Template',
      template_type: 'response_generation',
      template_text: 'Test response generation template'
    }
  ],
  default_stage_selection: [
    {
      template_id: 'default1',
      template_name: 'Default Stage Selection',
      template_type: 'default_stage_selection',
      template_text: 'Default stage selection template'
    }
  ],
  default_data_extraction: [
    {
      template_id: 'default2',
      template_name: 'Default Data Extraction',
      template_type: 'default_data_extraction',
      template_text: 'Default data extraction template'
    }
  ],
  default_response_generation: [
    {
      template_id: 'default3',
      template_name: 'Default Response Generation',
      template_type: 'default_response_generation',
      template_text: 'Default response generation template'
    }
  ]
};

// Helper to mock localStorage
export const mockLocalStorage = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn()
};

// Helper to setup localStorage mock
export const setupLocalStorageMock = (credentials = null) => {
  if (credentials) {
    mockLocalStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return credentials.businessId;
      if (key === 'businessApiKey') return credentials.businessApiKey;
      return null;
    });
  } else {
    mockLocalStorage.getItem.mockImplementation(() => null);
  }
};

// Export everything
export * from '@testing-library/react';
export { customRender as render }; 

================================================================================
File: AgentSection.js
Path: .\front-end\src\components\AgentSection.js
Size: 11076
Modified: 2025-04-12T16:07:30.201858
Created: 2025-04-01T16:09:47.910680
Hash: 458dab36c0deeec61bd001cfdd2383bae081dc5b8ee0f5c7bf50c928bf383e95
Lines: 287
================================================================================
import React, { useState, useEffect } from 'react';
import {
    Typography,
    Card,
    CardContent,
    List,
    ListItem,
    ListItemText,
    ListItemIcon,
    IconButton,
    CircularProgress,
    Alert,
    Button,
    Box,
    Divider,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    Tooltip
} from '@mui/material';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import StageIcon from '@mui/icons-material/Layers';
import { useNavigate } from 'react-router-dom';
import useAgents from '../hooks/useAgents';
import { createAgent, updateAgent, deleteAgent } from '../services/agentService';
import useConfig from '../hooks/useConfig';
import { normalizeUUID } from '../hooks/useConfig';

function AgentSection({ handleSnackbarOpen, onAgentSelect }) {
    console.log("Rendering AgentSection component");
    const { agents, isLoading, error, refreshAgents } = useAgents(handleSnackbarOpen);
    const [selectedAgentId, setSelectedAgentId] = useState(null);
    const { businessId } = useConfig(); // Get businessId from config
    const normalizedBusinessId = normalizeUUID(businessId);
    const navigate = useNavigate();

    // Debug logging
    useEffect(() => {
        console.log("AgentSection - Current state:", { 
            agents, 
            isLoading, 
            error, 
            businessId,
            normalizedBusinessId,
            selectedAgentId
        });
    }, [agents, isLoading, error, businessId, normalizedBusinessId, selectedAgentId]);

    // Dialog state
    const [openDialog, setOpenDialog] = useState(false);
    const [dialogMode, setDialogMode] = useState('create'); // 'create' or 'edit'
    const [agentData, setAgentData] = useState({
        business_id: normalizedBusinessId,
        agent_name: ''
    });
    const [isSubmitting, setIsSubmitting] = useState(false);

    // Update agent data whenever businessId changes
    useEffect(() => {
        setAgentData(prev => ({
            ...prev,
            business_id: normalizedBusinessId
        }));
    }, [normalizedBusinessId]);

    const handleAgentClick = (agentId) => {
        console.log("Selected Agent ID:", agentId);
        setSelectedAgentId(agentId);
        if (onAgentSelect) {
            onAgentSelect(agentId);
        }
    };

    const navigateToStageManagement = (agentId, agentName) => {
        console.log(`Navigating to stage management for agent: ${agentName} (${agentId})`);
        
        // Store agent ID in localStorage
        localStorage.setItem('agentId', agentId);
        
        // Navigate to stage management with proper URL format
        navigate(`/stage-management/business_id=${normalizedBusinessId}/agent_id=${agentId}`);
    };

    const openCreateDialog = () => {
        console.log("Opening create dialog with businessId:", normalizedBusinessId);
        setAgentData({
            business_id: normalizedBusinessId,
            agent_name: ''
        });
        setDialogMode('create');
        setOpenDialog(true);
    };

    const openEditDialog = (agent, event) => {
        if (event) event.stopPropagation();
        console.log("Opening edit dialog for agent:", agent);
        setAgentData({
            business_id: normalizedBusinessId,
            agent_name: agent.agent_name
        });
        setSelectedAgentId(agent.agent_id);
        setDialogMode('edit');
        setOpenDialog(true);
    };

    const handleCloseDialog = () => {
        setOpenDialog(false);
        setIsSubmitting(false);
    };

    const handleSubmit = async () => {
        if (!agentData.agent_name.trim()) {
            handleSnackbarOpen("Agent name is required", "error");
            return;
        }

        setIsSubmitting(true);
        try {
            // Make sure we're using the normalized businessId
            const submissionData = {
                ...agentData,
                business_id: normalizedBusinessId
            };
            
            console.log(`${dialogMode === 'create' ? 'Creating' : 'Updating'} agent with data:`, submissionData);
            if (dialogMode === 'create') {
                await createAgent(submissionData);
                handleSnackbarOpen("Agent created successfully", "success");
            } else {
                await updateAgent(selectedAgentId, submissionData);
                handleSnackbarOpen("Agent updated successfully", "success");
            }
            refreshAgents(); // Refresh the agents list
            handleCloseDialog();
        } catch (err) {
            console.error(dialogMode === 'create' ? "Error creating agent:" : "Error updating agent:", err);
            handleSnackbarOpen(err.message || "An error occurred", "error");
            setIsSubmitting(false);
        }
    };

    const handleDeleteAgent = async (agentId, event) => {
        if (event) event.stopPropagation();
        if (!window.confirm("Are you sure you want to delete this agent?")) return;

        try {
            if (!normalizedBusinessId) {
                throw new Error('Business ID not found');
            }

            console.log(`Deleting agent ${agentId} for business ${normalizedBusinessId}`);
            const response = await deleteAgent(agentId, normalizedBusinessId);
            if (response) {
                handleSnackbarOpen("Agent deleted successfully", "success");
                refreshAgents(); // Refresh the agents list
                if (selectedAgentId === agentId) {
                    setSelectedAgentId(null); // Clear selection if deleted agent was selected
                }
            }
        } catch (err) {
            console.error("Error deleting agent:", err);
            handleSnackbarOpen(err.message || "An error occurred while deleting the agent", "error");
        }
    };

    let agentListContent;
    if (isLoading) {
        agentListContent = (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', p: 2 }}>
                <CircularProgress size={24} />
                <Typography sx={{ ml: 1 }} variant="body2">Loading Agents...</Typography>
            </Box>
        );
    } else if (error) {
        agentListContent = <Alert severity="error">Error loading agents: {error}</Alert>;
    } else if (agents.length > 0) {
        agentListContent = (
            <List dense>
                {agents.map((agent) => (
                    <ListItem
                        key={agent.agent_id}
                        button
                        selected={selectedAgentId === agent.agent_id}
                        onClick={() => handleAgentClick(agent.agent_id)}
                        secondaryAction={
                            <Box>
                                <Tooltip title="Manage Stages">
                                    <IconButton
                                        edge="end"
                                        aria-label="manage-stages"
                                        color="primary"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            navigateToStageManagement(agent.agent_id, agent.agent_name);
                                        }}
                                    >
                                        <StageIcon />
                                    </IconButton>
                                </Tooltip>
                                <IconButton
                                    edge="end"
                                    aria-label="edit"
                                    onClick={(e) => openEditDialog(agent, e)}
                                >
                                    <EditIcon />
                                </IconButton>
                                <IconButton
                                    edge="end"
                                    aria-label="delete"
                                    onClick={(e) => handleDeleteAgent(agent.agent_id, e)}
                                >
                                    <DeleteIcon />
                                </IconButton>
                            </Box>
                        }
                    >
                        <ListItemText
                            primary={agent.agent_name || 'Unnamed Agent'}
                            secondary={`Created: ${new Date(agent.created_at).toLocaleDateString()}`}
                        />
                    </ListItem>
                ))}
            </List>
        );
    } else {
        agentListContent = <Typography variant="body2" sx={{ p: 2, textAlign: 'center' }}>No agents found for this business.</Typography>;
    }

    return (
        <>
            <Card sx={{ mt: 2 }}>
                <CardContent>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                        <Typography variant="h6" gutterBottom component="div">
                            Agents
                        </Typography>
                        <Button
                            variant="contained"
                            size="small"
                            startIcon={<AddCircleOutlineIcon />}
                            onClick={openCreateDialog}
                        >
                            Create Agent
                        </Button>
                    </Box>
                    <Divider sx={{ mb: 1 }}/>
                    {agentListContent}
                </CardContent>
            </Card>

            {/* Create/Edit Dialog */}
            <Dialog open={openDialog} onClose={handleCloseDialog}>
                <DialogTitle>{dialogMode === 'create' ? 'Create New Agent' : 'Edit Agent'}</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="Agent Name"
                        fullWidth
                        variant="outlined"
                        value={agentData.agent_name}
                        onChange={(e) => setAgentData({ ...agentData, agent_name: e.target.value })}
                        disabled={isSubmitting}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseDialog} disabled={isSubmitting}>Cancel</Button>
                    <Button 
                        onClick={handleSubmit} 
                        variant="contained" 
                        disabled={isSubmitting}
                        startIcon={isSubmitting ? <CircularProgress size={20} /> : null}
                    >
                        {dialogMode === 'create' ? 'Create' : 'Save'}
                    </Button>
                </DialogActions>
            </Dialog>
        </>
    );
}

export default AgentSection;


================================================================================
File: ApiTester.js
Path: .\front-end\src\components\ApiTester.js
Size: 17908
Modified: 2025-04-06T13:29:03.229746
Created: 2025-04-06T12:17:19.244493
Hash: 07536f80c506ae39b3ff422f282a2345aca847866db62e045257fce224bccf01
Lines: 530
================================================================================
import React, { useState } from 'react';
import { 
  Box, 
  Button, 
  TextField, 
  Typography, 
  Paper, 
  Divider, 
  CircularProgress,
  Alert,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  List,
  ListItem,
  ListItemText,
  Chip
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import { runAllApiTests, testApiKeyAuth, testTemplateOperations } from '../utils/apiTest';
import { getStoredCredentials } from '../utils/fetchUtils';

const ApiTester = () => {
  // Get stored credentials
  const storedCredentials = getStoredCredentials();
  
  const [businessId, setBusinessId] = useState(storedCredentials.businessId || '');
  const [businessApiKey, setBusinessApiKey] = useState(storedCredentials.businessApiKey || '');
  const [isLoading, setIsLoading] = useState(false);
  const [testResults, setTestResults] = useState([]);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleRunTests = async () => {
    if (!businessId || !businessApiKey) {
      setError('Business ID and API Key are required');
      return;
    }
    
    setIsLoading(true);
    setError('');
    setSuccess('');
    setTestResults([]);
    
    try {
      // Test with different authentication methods
      const authMethods = [
        // Method 1: API key as query parameter
        {
          url: `/businesses/validate-credentials/?business_id=${businessId}&api_key=${businessApiKey}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        },
        // Method 2: API key in X-API-Key header
        {
          url: `/businesses/validate-credentials/?business_id=${businessId}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-API-Key': businessApiKey
          }
        },
        // Method 3: API key in Authorization header as Bearer token
        {
          url: `/businesses/validate-credentials/?business_id=${businessId}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${businessApiKey}`
          }
        }
      ];
      
      const results = [];
      
      for (const method of authMethods) {
        try {
          console.log(`Testing with URL: ${method.url} and headers:`, method.headers);
          
          const response = await fetch(method.url, {
            method: 'GET',
            headers: method.headers,
            credentials: 'include'
          });
          
          const status = response.status;
          const data = await response.json().catch(() => ({}));
          
          const result = {
            test: 'Authentication',
            method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
            status,
            data,
            success: response.ok
          };
          
          results.push(result);
          
          // If any method succeeds, we can stop testing
          if (response.ok) {
            setSuccess(`Authentication successful using ${result.method} method!`);
            break;
          }
        } catch (err) {
          console.error(`Error testing authentication with method:`, err);
          results.push({
            test: 'Authentication',
            method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
            error: err.message,
            success: false
          });
        }
      }
      
      // Check if any method succeeded
      const successfulResult = results.find(r => r.success);
      
      if (!successfulResult) {
        setError('All authentication methods failed. Check the results for details.');
      }
      
      // If authentication succeeded, test templates
      if (successfulResult) {
        await handleTestTemplates();
      }
      
      setTestResults(results);
    } catch (err) {
      console.error('Test error:', err);
      setError(`Test error: ${err.message}`);
      setTestResults([{
        test: 'Authentication',
        error: err.message,
        success: false
      }]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleTestAuth = async () => {
    if (!businessId || !businessApiKey) {
      setError('Business ID and API Key are required');
      return;
    }
    
    setIsLoading(true);
    setError('');
    setSuccess('');
    setTestResults([]);
    
    try {
      // Test with different authentication methods
      const authMethods = [
        // Method 1: API key as query parameter
        {
          url: `/businesses/validate-credentials?business_id=${businessId}&api_key=${businessApiKey}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        },
        // Method 2: API key in X-API-Key header
        {
          url: `/businesses/validate-credentials?business_id=${businessId}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-API-Key': businessApiKey
          }
        },
        // Method 3: API key in Authorization header as Bearer token
        {
          url: `/businesses/validate-credentials?business_id=${businessId}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${businessApiKey}`
          }
        }
      ];
      
      const results = [];
      
      for (const method of authMethods) {
        try {
          console.log(`Testing with URL: ${method.url} and headers:`, method.headers);
          
          const response = await fetch(method.url, {
            method: 'GET',
            headers: method.headers,
            credentials: 'include'
          });
          
          const status = response.status;
          const data = await response.json().catch(() => ({}));
          
          const result = {
            method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
            status,
            data,
            success: response.ok
          };
          
          results.push(result);
          
          // If any method succeeds, we can stop testing
          if (response.ok) {
            setSuccess(`Authentication successful using ${result.method} method!`);
            break;
          }
        } catch (err) {
          console.error(`Error testing authentication method:`, err);
          results.push({
            method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
            error: err.message,
            success: false
          });
        }
      }
      
      setTestResults(results);
      
      // Check if any method succeeded
      const successfulResult = results.find(r => r.success);
      
      if (!successfulResult) {
        setError('All authentication methods failed. Check the results for details.');
      }
    } catch (err) {
      console.error('Authentication test error:', err);
      setError(`Authentication test error: ${err.message}`);
      setTestResults([{
        test: 'Authentication',
        error: err.message,
        success: false
      }]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleTestTemplates = async () => {
    if (!businessId || !businessApiKey) {
      setError('Business ID and API Key are required');
      return;
    }
    
    setIsLoading(true);
    setError('');
    setSuccess('');
    setTestResults([]);
    
    try {
      // Test with different authentication methods
      const authMethods = [
        // Method 1: API key as query parameter
        {
          url: `/templates/?business_id=${businessId}&api_key=${businessApiKey}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        },
        // Method 2: API key in X-API-Key header
        {
          url: `/templates/?business_id=${businessId}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-API-Key': businessApiKey
          }
        },
        // Method 3: API key in Authorization header as Bearer token
        {
          url: `/templates/?business_id=${businessId}`,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${businessApiKey}`
          }
        }
      ];
      
      const results = [];
      
      for (const method of authMethods) {
        try {
          console.log(`Testing with URL: ${method.url} and headers:`, method.headers);
          
          const response = await fetch(method.url, {
            method: 'GET',
            headers: method.headers,
            credentials: 'include'
          });
          
          const status = response.status;
          const data = await response.json().catch(() => ({}));
          
          const result = {
            method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
            status,
            data,
            success: response.ok
          };
          
          results.push(result);
          
          // If any method succeeds, we can stop testing
          if (response.ok) {
            setSuccess(`Templates fetched successfully using ${result.method} method!`);
            break;
          }
        } catch (err) {
          console.error(`Error testing templates with method:`, err);
          results.push({
            method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
            error: err.message,
            success: false
          });
        }
      }
      
      setTestResults(results);
      
      // Check if any method succeeded
      const successfulResult = results.find(r => r.success);
      
      if (!successfulResult) {
        setError('All template fetch methods failed. Check the results for details.');
      }
    } catch (err) {
      console.error('Templates test error:', err);
      setError(`Templates test error: ${err.message}`);
      setTestResults([{
        test: 'Templates',
        error: err.message,
        success: false
      }]);
    } finally {
      setIsLoading(false);
    }
  };

  const renderTestResults = () => {
    if (!testResults) return null;

    return (
      <Box sx={{ mt: 3 }}>
        <Typography variant="h6" gutterBottom>Test Results</Typography>
        
        {testResults.authResult && (
          <Accordion defaultExpanded>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography>Authentication Test Results</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <List>
                {testResults.authResult.results.map((result, index) => (
                  <ListItem key={index} divider>
                    <ListItemText
                      primary={
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                          <Typography variant="subtitle1">
                            {Object.keys(result.headers)[0]}
                          </Typography>
                          <Chip 
                            label={result.success ? 'Success' : 'Failed'} 
                            color={result.success ? 'success' : 'error'} 
                            size="small" 
                          />
                        </Box>
                      }
                      secondary={
                        <Box>
                          <Typography variant="body2">
                            Status: {result.status || 'N/A'}
                          </Typography>
                          {result.data && (
                            <Typography variant="body2">
                              Response: {JSON.stringify(result.data)}
                            </Typography>
                          )}
                          {result.error && (
                            <Typography variant="body2" color="error">
                              Error: {result.error}
                            </Typography>
                          )}
                        </Box>
                      }
                    />
                  </ListItem>
                ))}
              </List>
            </AccordionDetails>
          </Accordion>
        )}
        
        {testResults.templateResult && (
          <Accordion defaultExpanded>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography>Template Operations Test Results</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography variant="subtitle1" gutterBottom>Fetch Templates</Typography>
              <Box sx={{ mb: 2 }}>
                <Typography variant="body2">
                  Status: {testResults.templateResult.fetchResult.status || 'N/A'}
                </Typography>
                <Chip 
                  label={testResults.templateResult.fetchResult.success ? 'Success' : 'Failed'} 
                  color={testResults.templateResult.fetchResult.success ? 'success' : 'error'} 
                  size="small" 
                  sx={{ mt: 1 }}
                />
                {testResults.templateResult.fetchResult.data && (
                  <Typography variant="body2" sx={{ mt: 1 }}>
                    Response: {JSON.stringify(testResults.templateResult.fetchResult.data)}
                  </Typography>
                )}
                {testResults.templateResult.fetchResult.error && (
                  <Typography variant="body2" color="error" sx={{ mt: 1 }}>
                    Error: {testResults.templateResult.fetchResult.error}
                  </Typography>
                )}
              </Box>
              
              <Divider sx={{ my: 2 }} />
              
              <Typography variant="subtitle1" gutterBottom>Create Template</Typography>
              <Box>
                <Typography variant="body2">
                  Status: {testResults.templateResult.createResult.status || 'N/A'}
                </Typography>
                <Chip 
                  label={testResults.templateResult.createResult.success ? 'Success' : 'Failed'} 
                  color={testResults.templateResult.createResult.success ? 'success' : 'error'} 
                  size="small" 
                  sx={{ mt: 1 }}
                />
                {testResults.templateResult.createResult.data && (
                  <Typography variant="body2" sx={{ mt: 1 }}>
                    Response: {JSON.stringify(testResults.templateResult.createResult.data)}
                  </Typography>
                )}
                {testResults.templateResult.createResult.error && (
                  <Typography variant="body2" color="error" sx={{ mt: 1 }}>
                    Error: {testResults.templateResult.createResult.error}
                  </Typography>
                )}
              </Box>
            </AccordionDetails>
          </Accordion>
        )}
      </Box>
    );
  };

  return (
    <Paper sx={{ p: 3, maxWidth: 800, mx: 'auto', mt: 4 }}>
      <Typography variant="h5" gutterBottom>API Tester</Typography>
      <Typography variant="body1" paragraph>
        Use this tool to test API connectivity and authentication. Enter your Business ID and API Key below.
      </Typography>
      
      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError('')}>
          {error}
        </Alert>
      )}
      
      {success && (
        <Alert severity="success" sx={{ mb: 2 }} onClose={() => setSuccess('')}>
          {success}
        </Alert>
      )}
      
      <Box sx={{ mb: 3 }}>
        <TextField
          fullWidth
          label="Business ID"
          value={businessId}
          onChange={(e) => setBusinessId(e.target.value)}
          margin="normal"
          required
        />
        <TextField
          fullWidth
          label="API Key"
          value={businessApiKey}
          onChange={(e) => setBusinessApiKey(e.target.value)}
          margin="normal"
          required
          type="password"
        />
      </Box>
      
      <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
        <Button 
          variant="contained" 
          onClick={handleRunTests} 
          disabled={isLoading}
          startIcon={isLoading ? <CircularProgress size={20} /> : null}
        >
          Run All Tests
        </Button>
        <Button 
          variant="outlined" 
          onClick={handleTestAuth} 
          disabled={isLoading}
        >
          Test Authentication
        </Button>
        <Button 
          variant="outlined" 
          onClick={handleTestTemplates} 
          disabled={isLoading}
        >
          Test Templates
        </Button>
      </Box>
      
      {renderTestResults()}
    </Paper>
  );
};

export default ApiTester; 

================================================================================
File: Business.js
Path: .\front-end\src\components\Business.js
Size: 2634
Modified: 2025-04-02T23:10:00.647600
Created: 2025-04-01T22:33:33.261519
Hash: 8309d2c45007dcd3249f31e98a6916eb9c818e3caf628517cf8fb4693be66ad3
Lines: 105
================================================================================
import React, { useState } from 'react';
import {
  Box,
  Paper,
  Typography,
  Button,
  List,
  ListItem,
  ListItemText,
  Divider,
  CircularProgress,
  Alert,
  Snackbar,
  Tabs,
  Tab
} from '@mui/material';
import LogoutIcon from '@mui/icons-material/Logout';
import StageManager from './StageManager';

const Business = ({ 
  handleLogout, 
  userId, 
  businessId, 
  businessApiKey 
}) => {
  const [activeTab, setActiveTab] = useState(0);

  const handleLogoutClick = () => {
    handleLogout();
  };

  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };

  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4">Business Dashboard</Typography>
        <Button
          startIcon={<LogoutIcon />}
          onClick={handleLogoutClick}
          variant="outlined"
          color="error"
        >
          Logout
        </Button>
      </Box>

      <Paper sx={{ mb: 3 }}>
        <Tabs value={activeTab} onChange={handleTabChange}>
          <Tab label="Configuration" />
          <Tab label="Stages" />
          <Tab label="Analytics" />
        </Tabs>
      </Paper>

      {activeTab === 0 && (
        <Paper sx={{ p: 2 }}>
          <Typography variant="h6" gutterBottom>
            Current Configuration
          </Typography>
          <Divider sx={{ my: 1 }} />
          <List>
            <ListItem>
              <ListItemText
                primary="User ID"
                secondary={userId || 'Not set'}
              />
            </ListItem>
            <ListItem>
              <ListItemText
                primary="Business ID"
                secondary={businessId || 'Not set'}
              />
            </ListItem>
            <ListItem>
              <ListItemText
                primary="Business API Key"
                secondary={businessApiKey ? `${businessApiKey.slice(0, 8)}...` : 'Not set'}
              />
            </ListItem>
          </List>
        </Paper>
      )}

      {activeTab === 1 && (
        <StageManager businessId={businessId} />
      )}

      {activeTab === 2 && (
        <Paper sx={{ p: 2 }}>
          <Typography variant="h6" gutterBottom>
            Analytics Dashboard
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Analytics features coming soon...
          </Typography>
        </Paper>
      )}
    </Box>
  );
};

export default Business; 

================================================================================
File: BusinessDetailsView.js
Path: .\front-end\src\components\BusinessDetailsView.js
Size: 7774
Modified: 2025-04-08T17:09:48.870537
Created: 2025-04-08T15:04:02.499761
Hash: b8cfd40fc1a12d502012107cc522506b171e4eef11a4a67ea9e7e67bff0f0a46
Lines: 210
================================================================================
import React, { useEffect, useState, useCallback } from 'react';
import { API_BASE_URL } from '../config';
import { 
    Box, Typography, TextField, Button, CircularProgress, Alert, 
    Select, MenuItem, FormControl, InputLabel 
} from '@mui/material';
import { businessService } from '../services/businessService';
import { stageService } from '../services/stageService';

const BusinessDetailsView = () => {
  const [businessId, setBusinessId] = useState(localStorage.getItem('businessId'));
  const [businessData, setBusinessData] = useState(null);
  const [editFormData, setEditFormData] = useState(null);
  const [availableStages, setAvailableStages] = useState([]);
  const [selectedStageId, setSelectedStageId] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState(null);

  const handleSnackbarOpen = (message, variant) => { console.log(`${variant}: ${message}`); };

  const fetchData = useCallback(async () => {
      if (!businessId) {
          setError("Please login and configure your business to view details.");
          setIsLoading(false);
          return;
      }
      setIsLoading(true);
      setError(null);
      console.log(`Fetching data for business ID: ${businessId}`);

      try {
          const fetchedBusinessData = await businessService.getBusiness(businessId);
          console.log('Fetched business data:', fetchedBusinessData);
          setBusinessData(fetchedBusinessData);
          setEditFormData(fetchedBusinessData); 
          setSelectedStageId(fetchedBusinessData.first_stage_id || '');
          
          const fetchedStages = await stageService.getStages(businessId);
          console.log('Fetched stages:', fetchedStages);
          setAvailableStages(fetchedStages || []);
          
      } catch (err) {
          console.error('Error fetching data:', err);
          setError(err.message);
      } finally {
          setIsLoading(false);
      }
  }, [businessId]);

  useEffect(() => {
      fetchData();
  }, [fetchData]);

  const handleStageSelectChange = (event) => {
      setSelectedStageId(event.target.value);
  };

  const handleSaveDefaultStage = async () => {
      if (!businessId) return;
      setIsSaving(true);
      setError(null);
      try {
          const stageIdToSave = selectedStageId === '' ? null : selectedStageId;
          await businessService.setDefaultStage(businessId, stageIdToSave);
          handleSnackbarOpen('Default starting stage updated successfully!', 'success');
      } catch (err) {
          console.error('Error saving default stage:', err);
          setError(err.message);
          handleSnackbarOpen(`Error saving default stage: ${err.message}`, 'error');
      } finally {
          setIsSaving(false);
      }
  };

  const handleInputChange = (event) => {
      const { name, value } = event.target;
      setEditFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSaveDetails = async () => {
      if (!businessId || !editFormData) return;
      setIsSaving(true);
      setError(null);
      try {
          const dataToUpdate = { 
              business_name: editFormData.business_name, 
              business_description: editFormData.business_description,
              address: editFormData.address,
              phone_number: editFormData.phone_number,
              website: editFormData.website
          }; 
          await businessService.updateBusiness(businessId, dataToUpdate);
          handleSnackbarOpen('Business details updated successfully!', 'success');
          setBusinessData(prev => ({ ...prev, ...dataToUpdate })); 
      } catch (err) {
          console.error('Error updating business details:', err);
          setError(err.message);
          handleSnackbarOpen(`Error updating details: ${err.message}`, 'error');
      } finally {
          setIsSaving(false);
      }
  };

  if (isLoading) {
    return <Box display="flex" justifyContent="center" mt={4}><CircularProgress /></Box>;
  }

  if (error) {
    return <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>;
  }

  if (!businessData || !editFormData) {
    return <Alert severity="warning" sx={{ mt: 2 }}>No business data found. Please configure first.</Alert>;
  }

  return (
    <Box sx={{ p: 3 }}>
        <Typography variant="h4" gutterBottom>Business Details</Typography>
        
        <Box component="form" noValidate autoComplete="off" sx={{ mb: 4 }}>
            <TextField 
                label="Business Name"
                name="business_name"
                value={editFormData.business_name || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
                required
            />
            <TextField 
                label="Description"
                name="business_description"
                value={editFormData.business_description || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
                multiline
                rows={3}
            />
             <TextField 
                label="Address"
                name="address"
                value={editFormData.address || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
            />
             <TextField 
                label="Phone Number"
                name="phone_number"
                value={editFormData.phone_number || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
            />
             <TextField 
                label="Website"
                name="website"
                value={editFormData.website || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
            />
            <Button 
                variant="contained" 
                onClick={handleSaveDetails}
                disabled={isSaving}
                sx={{ mt: 2 }}
            >
                {isSaving ? <CircularProgress size={24} /> : 'Save Details'}
            </Button>
        </Box>

        <hr />

        <Box sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h6" gutterBottom>Conversation Settings</Typography>
            <FormControl fullWidth margin="normal">
                <InputLabel id="default-stage-label">Default Starting Stage</InputLabel>
                <Select
                    labelId="default-stage-label"
                    id="default-stage-select"
                    value={selectedStageId}
                    label="Default Starting Stage"
                    onChange={handleStageSelectChange}
                >
                    <MenuItem value=""><em>None (System Default)</em></MenuItem>
                    {availableStages.map((stage) => (
                        <MenuItem key={stage.stage_id} value={stage.stage_id}>
                            {stage.stage_name} ({stage.stage_id.substring(0, 8)}...)
                        </MenuItem>
                    ))}
                </Select>
            </FormControl>
            <Button 
                variant="contained" 
                onClick={handleSaveDefaultStage}
                disabled={isSaving}
                sx={{ mt: 2 }}
            >
                {isSaving ? <CircularProgress size={24} /> : 'Save Default Stage'}
            </Button>
        </Box>

    </Box>
  );
};

export default BusinessDetailsView; 

================================================================================
File: BusinessManagement.js
Path: .\front-end\src\components\BusinessManagement.js
Size: 1425
Modified: 2025-03-31T00:10:02.479605
Created: 2025-03-28T21:40:09.408126
Hash: e9aeb523b4c2652be9d9a18887160d108e9868fab10d6517c13380f0946e4c0e
Lines: 39
================================================================================
// src/components/BusinessManagement.js
import React from 'react';
import { TextField, Button, Typography, Card, CardContent, Box } from '@mui/material';

function BusinessManagement({
    businessName,
    setBusinessName,
    businessOutput,
    setBusinessOutput,
     fetchBusinessDetails,
    handleSnackbarOpen,
    apiKey,
    businessId,
}) {
    return (
        <Card sx={{ mt: 2 }}>
            <CardContent>
                <Typography variant="h6" gutterBottom>Business Management</Typography>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
                    <TextField
                        label="Business Name"
                        variant="outlined"
                        value={businessName}
                        onChange={(e) => setBusinessName(e.target.value)}
                    />
                    <Button variant="contained" onClick={() => console.log("Create Business not yet implemented")}>
                        Create Business
                    </Button>
                    <Button variant="contained" onClick={fetchBusinessDetails}>
                        Fetch Business Details
                    </Button>
                    <Typography variant="body1">{businessOutput}</Typography>
                </Box>
            </CardContent>
        </Card>
    );
}

export default BusinessManagement;

================================================================================
File: BusinessSection.js
Path: .\front-end\src\components\BusinessSection.js
Size: 2086
Modified: 2025-04-02T02:24:28.211129
Created: 2025-04-01T07:22:22.839236
Hash: a965409e3b6cc1070814319a0289bbcb5a8ddd1fb7aa35887ac35e5e3dbf832e
Lines: 60
================================================================================
import React from 'react';
import {
    Typography,
    Card,
    CardContent,
    List,
    ListItem,
    ListItemText,
    CircularProgress,
    Alert,
    Box
} from '@mui/material';
import useBusiness from '../hooks/useBusiness';

function BusinessSection({ handleSnackbarOpen }) {
    const { businessDetails, isLoading, error } = useBusiness(handleSnackbarOpen);

    let content;

    if (isLoading) {
        content = (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '100px' }} data-testid="loading-state">
                <CircularProgress />
                <Typography sx={{ ml: 1 }}>Loading Business Details...</Typography>
            </Box>
        );
    } else if (error) {
        content = <Alert severity="error" data-testid="error-state">Error loading business details: {error}</Alert>;
    } else if (businessDetails) {
        content = (
            <List dense>
                <ListItem>
                    <ListItemText primary="Business Name" secondary={businessDetails.business_name || 'N/A'} />
                </ListItem>
                <ListItem>
                    <ListItemText primary="Address" secondary={businessDetails.address || 'N/A'} />
                </ListItem>
                <ListItem>
                    <ListItemText primary="Phone" secondary={businessDetails.phone || 'N/A'} />
                </ListItem>
                <ListItem>
                    <ListItemText primary="Email" secondary={businessDetails.email || 'N/A'} />
                </ListItem>
            </List>
        );
    } else {
        content = <Typography variant="body2" data-testid="empty-state">Business details will load here.</Typography>;
    }

    return (
        <Card sx={{ mt: 2 }} data-testid="business-details">
            <CardContent>
                <Typography variant="h6" gutterBottom>Business Details</Typography>
                {content}
            </CardContent>
        </Card>
    );
}

export default BusinessSection;

================================================================================
File: Configuration.js
Path: .\front-end\src\components\Configuration.js
Size: 3759
Modified: 2025-04-02T12:43:48.819792
Created: 2025-03-28T21:47:07.228445
Hash: 7f9b61c2ba832888288551c6524c66d51306f071c117cd03fd06dc95523f1bb5
Lines: 103
================================================================================
import React from 'react';
import { TextField, Button, Typography, Card, CardContent, Box } from '@mui/material';
import { useNavigate } from 'react-router-dom';

const Configuration = ({
    userId,
    setUserId,
    businessId,
    setBusinessId,
    businessApiKey,
    setBusinessApiKey,
    handleSnackbarOpen,
    handleLogout
}) => {
    const navigate = useNavigate();

    const handleSave = async () => {
        if (!userId || !businessId || !businessApiKey) {
            handleSnackbarOpen('Please enter all the configuration values', 'warning');
            return;
        }

        try {
            const response = await fetch('/api/save-config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                },
                credentials: 'include',
                body: JSON.stringify({
                    userId,
                    businessId,
                    businessApiKey
                })
            });

            if (!response.ok) {
                const data = await response.json();
                handleSnackbarOpen(data.message || 'Invalid credentials', 'error');
                return;
            }

            handleSnackbarOpen('Configuration saved successfully', 'success');
            navigate('/business');
        } catch (error) {
            handleSnackbarOpen('Error saving configuration', 'error');
        }
    };

    const onLogout = () => {
        handleLogout();
        navigate('/login');
    };

    return (
        <Card>
            <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                    <Typography variant="h6">Configuration</Typography>
                    <Button variant="outlined" color="secondary" onClick={onLogout}>
                        Logout
                    </Button>
                </Box>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    <TextField
                        label="Business API Key"
                        type="password"
                        value={businessApiKey}
                        onChange={(e) => setBusinessApiKey(e.target.value)}
                        required
                        error={!businessApiKey}
                        helperText={!businessApiKey ? 'Business API Key is required' : ''}
                        data-testid="business-api-key-input"
                    />
                    <TextField
                        label="User ID"
                        value={userId}
                        onChange={(e) => setUserId(e.target.value)}
                        required
                        error={!userId}
                        helperText={!userId ? 'User ID is required' : ''}
                        data-testid="user-id-input"
                    />
                    <TextField
                        label="Business ID"
                        value={businessId}
                        onChange={(e) => setBusinessId(e.target.value)}
                        required
                        error={!businessId}
                        helperText={!businessId ? 'Business ID is required' : ''}
                        data-testid="business-id-input"
                    />
                    <Button variant="contained" color="primary" onClick={handleSave}>
                        Save Config
                    </Button>
                </Box>
            </CardContent>
        </Card>
    );
};

export default Configuration;

================================================================================
File: ErrorDisplay.js
Path: .\front-end\src\components\ErrorDisplay.js
Size: 268
Modified: 2025-03-30T16:54:46.194448
Created: 2025-03-28T19:06:28.494064
Hash: d100be5cb76e7cbc06be0b510809123166ba6f567111e82f081c1f6e0dab0cc4
Lines: 12
================================================================================
// File: src/components/ErrorDisplay.js
import React from 'react';

function ErrorDisplay({ message }) {
    return (
        <div className="error-message">
            <strong>Error:</strong> {message}
        </div>
    );
}

export default ErrorDisplay;

================================================================================
File: Footer.js
Path: .\front-end\src\components\Footer.js
Size: 586
Modified: 2025-04-06T12:17:50.996670
Created: 2025-04-06T12:17:48.132487
Hash: a75fab1eecd536754fc6e52d5cf1db6c079d234ca0038d8c4863fc4e3741a543
Lines: 24
================================================================================
import React from 'react';
import { Box, Typography, Container } from '@mui/material';

const Footer = () => {
  return (
    <Box
      component="footer"
      sx={{
        py: 3,
        px: 2,
        mt: 'auto',
        backgroundColor: (theme) => theme.palette.grey[200],
      }}
    >
      <Container maxWidth="lg">
        <Typography variant="body2" color="text.secondary" align="center">
           {new Date().getFullYear()} ICMP Events API. All rights reserved.
        </Typography>
      </Container>
    </Box>
  );
};

export default Footer; 

================================================================================
File: Header.js
Path: .\front-end\src\components\Header.js
Size: 865
Modified: 2025-04-08T14:39:42.317946
Created: 2025-04-06T12:17:40.740059
Hash: c1022c421027a155ae17255221640f86943e2fb8dde578431f796038240ffd7b
Lines: 31
================================================================================
import React from 'react';
import { AppBar, Toolbar, Typography, Button, Box } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';

const Header = () => {
  const menuItems = [
    { text: 'Home', path: '/' },
    { text: 'Business', path: '/business' },
    { text: 'Templates', path: '/templates' },
    { text: 'Stages', path: '/stages' }
  ];

  return (
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          ICMP Events API
        </Typography>
        <Box>
          {menuItems.map((item, index) => (
            <Button key={index} color="inherit" component={RouterLink} to={item.path}>
              {item.text}
            </Button>
          ))}
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Header; 

================================================================================
File: HealthCheck.js
Path: .\front-end\src\components\HealthCheck.js
Size: 1622
Modified: 2025-03-30T16:54:31.644729
Created: 2025-03-28T19:06:04.366290
Hash: cbe65624772604ab4a2529fc4a1cf2f79592d9b3373f4f4ab615d47e67efc21c
Lines: 53
================================================================================
// File: src/components/HealthCheck.js
import React, { useState, useEffect } from 'react';
import { getHealthCheck } from './healthCheckService';
import ErrorDisplay from './ErrorDisplay';
import LoadingIndicator from './LoadingIndicator';
import './HealthCheck.css';

function HealthCheck() {
    const [healthData, setHealthData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchHealthData = async () => {
            setLoading(true);
            setError(null);
            try {
                const data = await getHealthCheck();
                setHealthData(data);
            } catch (e) {
                setError(e.message);
            } finally {
                setLoading(false);
            }
        };

        fetchHealthData();
    }, []);

    if (loading) {
        return <LoadingIndicator />;
    }

    if (error) {
        return <ErrorDisplay message={error} />;
    }

    return (
        <div className="health-check-container">
            <h2>Health Check</h2>
            {healthData && (
                <div className="health-data">
                    <p><strong>Status:</strong> {healthData.status}</p>
                    <p><strong>Date:</strong> {healthData.date}</p>
                    <p><strong>Database:</strong> {healthData.database}</p>
                    <p><strong>Schemas Loaded:</strong> {healthData.schemas_loaded}</p>
                </div>
            )}
        </div>
    );
}

export default HealthCheck;

================================================================================
File: healthCheckService.js
Path: .\front-end\src\components\healthCheckService.js
Size: 1055
Modified: 2025-03-30T16:54:11.783983
Created: 2025-03-28T19:05:26.051262
Hash: 8e2cb5d64b217498830814b495aacab2ebf4b6cb420dc1b13d95ebafc2daee7a
Lines: 32
================================================================================
// File: src/components/healthCheckService.js
const API_ENDPOINT = '/health';

export const getHealthCheck = async () => {
    try {
        const apiKey = process.env.REACT_APP_API_KEY; // Access the API key from environment variables

        if (!apiKey) {
            throw new Error("ICMP API Key is missing. Ensure REACT_APP_API_KEY is set in your environment.");
        }

        const response = await fetch(API_ENDPOINT, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json();
            const errorMessage = errorData.message || `HTTP error! Status: ${response.status}`;
            throw new Error(errorMessage);
        }

        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching health check:", error);
        throw error;
    }
};

================================================================================
File: Home.js
Path: .\front-end\src\components\Home.js
Size: 1891
Modified: 2025-04-08T14:40:38.203249
Created: 2025-04-06T12:17:57.734053
Hash: 3fa95c48fe06267932b0b7d30820262b46f5585451020e2f63f527c6aa116567
Lines: 60
================================================================================
import React from 'react';
import { Typography, Box, Paper, Grid, Button } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';

const Home = () => {
  return (
    <Box sx={{ flexGrow: 1 }}>
      <Paper sx={{ p: 4, mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Welcome to ICMP Events API
        </Typography>
        <Typography variant="body1" paragraph>
          This application helps you manage stages and templates for your ICMP events.
        </Typography>
      </Paper>

      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 3, height: '100%' }}>
            <Typography variant="h5" component="h2" gutterBottom>
              Business Details
            </Typography>
            <Typography variant="body1" paragraph>
              View and manage your business configuration.
            </Typography>
            <Button
              variant="contained"
              color="primary"
              component={RouterLink}
              to="/business"
            >
              Go to Business Details
            </Button>
          </Paper>
        </Grid>

        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 3, height: '100%' }}>
            <Typography variant="h5" component="h2" gutterBottom>
              Stage Management
            </Typography>
            <Typography variant="body1" paragraph>
              Create, edit, and manage your stages for ICMP events.
            </Typography>
            <Button
              variant="contained"
              color="primary"
              component={RouterLink}
              to="/stages"
            >
              Go to Stages
            </Button>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default Home; 

================================================================================
File: LoadingIndicator.js
Path: .\front-end\src\components\LoadingIndicator.js
Size: 250
Modified: 2025-03-30T16:53:47.590486
Created: 2025-03-28T19:05:01.779583
Hash: f4ce1bc8416c1257020598856080bfc2a4981ba693e1ba88c64d7619392cd7ee
Lines: 12
================================================================================
// File: src/components/LoadingIndicator.js
import React from 'react';

function LoadingIndicator() {
    return (
        <div className="loading-indicator">
            Loading...
        </div>
    );
}

export default LoadingIndicator;

================================================================================
File: Login.js
Path: .\front-end\src\components\Login.js
Size: 4469
Modified: 2025-04-15T15:50:48.184105
Created: 2025-04-01T18:05:15.377653
Hash: 477049b80cf3d7f276fa0c537f322fafeb16f0c67378d180228182f15d073ce0
Lines: 110
================================================================================
import React, { useState } from 'react';
import { TextField, Button, Typography, Card, CardContent, Box, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { login } from '../services/authService';
import { API_CONFIG } from '../config';

function Login({ 
    setIsAuthenticated, 
    handleSnackbarOpen,
    setUserId: setParentUserId,
    setBusinessId: setParentBusinessId,
    setBusinessApiKey: setParentBusinessApiKey
}) {
    const [isLoading, setIsLoading] = useState(false);
    const [userId, setUserId] = useState('');
    const [businessId, setBusinessId] = useState(API_CONFIG.DEFAULTS.BUSINESS_ID);
    const [businessApiKey, setBusinessApiKey] = useState(API_CONFIG.DEFAULTS.API_KEY);
    const navigate = useNavigate();

    const handleSubmit = async (event) => {
        event.preventDefault();
        setIsLoading(true);

        try {
            // Validate and save credentials using the authService
            const data = await login(userId, businessId, businessApiKey);

            if (data.success) {
                // Update parent state
                setParentUserId(userId.trim());
                setParentBusinessId(businessId.trim());
                setParentBusinessApiKey(businessApiKey.trim());

                // Set authentication state
                setIsAuthenticated(true);
                
                // Show success message and redirect
                handleSnackbarOpen(data.message || 'Login successful', 'success');
                navigate('/business');
            } else {
                // Show error message
                handleSnackbarOpen(data.message || 'Login failed', 'error');
                setIsAuthenticated(false);
            }
        } catch (error) {
            console.error('Login error:', error);
            handleSnackbarOpen(error.message || 'Login failed', 'error');
            setIsAuthenticated(false);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Card sx={{ mt: 4, maxWidth: 400, mx: 'auto' }}>
            <CardContent>
                <Typography variant="h5" gutterBottom align="center">
                    Login
                </Typography>
                <Box component="form" onSubmit={handleSubmit} sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
                    <TextField
                        label="Business ID" 
                        variant="outlined" 
                        value={businessId}
                        onChange={(e) => setBusinessId(e.target.value)}
                        disabled={isLoading}
                        required
                        error={!businessId}
                        helperText={!businessId ? "Business ID is required" : ""}
                        fullWidth
                    />
                    <TextField
                        label="Business API Key"
                        variant="outlined"
                        value={businessApiKey}
                        onChange={(e) => setBusinessApiKey(e.target.value)}
                        disabled={isLoading}
                        type="password"
                        required
                        error={!businessApiKey}
                        helperText={!businessApiKey ? "Business API Key is required" : ""}
                        fullWidth
                    />
                    <TextField 
                        label="User ID" 
                        variant="outlined" 
                        value={userId}
                        onChange={(e) => setUserId(e.target.value)}
                        disabled={isLoading}
                        required
                        error={!userId}
                        helperText={!userId ? "User ID is required" : ""}
                        fullWidth
                    />

                    <Button 
                        type="submit"
                        variant="contained" 
                        disabled={isLoading || !userId || !businessId || !businessApiKey}
                        fullWidth
                    >
                        {isLoading ? <CircularProgress size={24} /> : 'Login'}
                    </Button>
                </Box>
            </CardContent>
        </Card>
    );
}

export default Login; 

================================================================================
File: MyInterface.js
Path: .\front-end\src\components\MyInterface.js
Size: 10098
Modified: 2025-04-01T16:35:54.547548
Created: 2025-03-28T18:52:14.478188
Hash: df39b05e6141ae0b7f7e7def5a38a47b1c9e32be2fd577b048530be4c583f887
Lines: 262
================================================================================
// File: src/components/MyInterface.js
// Last Modified: 2026-03-30
import React, { useState } from 'react';
import './MyInterface.css';
import { Typography, Snackbar, Alert } from '@mui/material';
import Configuration from './Configuration';
import BusinessSection from './BusinessSection';
import UserSection from './UserSection';
import SendMessage from './SendMessage';
import StageManagement from './StageManagement';
import useTemplateManagement from '../hooks/useTemplateManagement';
import useStageManagement from '../hooks/useStageManagement';
import useConfig from '../hooks/useConfig';
import useUser from '../hooks/useUser';
import { createUser as createUserApi, createTemplate as createTemplateApi } from '../services/testService';
import AgentSection from './AgentSection';
import StageSection from './StageSection';
import StageDetailView from './StageDetailView';
import TemplateSection from './TemplateSection';

// Main MyInterface component
function MyInterface() {
    const [snackbarOpen, setSnackbarOpen] = useState(false);
    const [snackbarMessage, setSnackbarMessage] = useState('');
    const [snackbarSeverity, setSnackbarSeverity] = useState('success'); // or 'error'
    const [selectedAgentId, setSelectedAgentId] = useState(null);
    const [selectedStageId, setSelectedStageId] = useState(null);

    const handleSnackbarOpen = (message, severity) => {
        setSnackbarMessage(message);
        setSnackbarSeverity(severity);
        setSnackbarOpen(true);
    };

    const handleSnackbarClose = (event, reason) => {
        if (reason === 'clickaway') {
            return;
        }
        setSnackbarOpen(false);
    };

   const {
        apiKey,
        setApiKey,
        userId,
        setUserId,
        businessId,
        setBusinessId,
        businessApiKey,
        setBusinessApiKey,
    } = useConfig();

    const {
        firstName,
        setFirstName,
        lastName,
        setLastName,
        email,
        setEmail,
        userOutput,
        setUserOutput
    } = useUser();

    const {
        templateID,
        setTemplateID,
        templateName,
        setTemplateName,
        templateText,
        setTemplateText,
        templateOutput,
        setTemplateOutput,
    } = useTemplateManagement(apiKey, handleSnackbarOpen);

    const {
        stageId,
        setStageId,
        stageName,
        setStageName,
        stageDescription,
        setStageDescription,
        stageType,
        setStageType,
        selectionTemplateId,
        setSelectionTemplateId,
        selectionCustomPrompt,
        setSelectionCustomPrompt,
         extractionTemplateId,
        setExtractionTemplateId,
        extractionCustomPrompt,
        setExtractionCustomPrompt,
        responseTemplateId,
        setResponseTemplateId,
        responseCustomPrompt,
        setResponseCustomPrompt,
        stageOutput,
        setStageOutput,
        fetchStages,
        createStage
    } = useStageManagement(apiKey, businessId, handleSnackbarOpen);

    //user section
    const createUser = async () => {
        try {
            await createUserApi(firstName, lastName, email)
            setUserOutput("User Created (dummy)");
            handleSnackbarOpen("User Created!", "success")

        } catch (error) {
            setUserOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")

        }
    };

    const createTemplate = async () => {
        const templateData = {
            template_name: templateName,
            template_text: templateText
        };
        try {
            const data = await createTemplateApi(templateData, apiKey)
            setTemplateOutput(`Template Created: ${data.template_id}`);
            handleSnackbarOpen(`Template Created: ${data.template_id}`, "success")
        } catch (error) {
            setTemplateOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")

        }
    };

    // Define placeholder processMessage function
    const processMessage = async (message) => {
        console.log("Processing message (TODO):", message);
        // TODO: Implement actual message processing logic, likely calling an API
        handleSnackbarOpen("Message processing not yet implemented.", "info");
    };

    // Handler for when an agent is selected in AgentSection
    const handleAgentSelect = (agentId) => {
        console.log("Agent selected in MyInterface:", agentId);
        setSelectedAgentId(agentId);
        // Clear stage selection when agent changes
        setSelectedStageId(null); 
    };

    // Handler for when a stage is selected in StageSection
    const handleStageSelect = (stageId) => {
        console.log("Stage selected in MyInterface:", stageId);
        setSelectedStageId(stageId);
    };

    // Determine if configuration is complete (we check for businessId as a proxy)
    const isConfigComplete = !!businessId && !!userId; // Check both IDs are present

    return (
        <div className="container">
            <Typography variant="h4" align="center" gutterBottom>ICMP Proof of Concept</Typography>

            {!isConfigComplete ? (
                <Configuration
                    apiKey={apiKey}
                    setApiKey={setApiKey}
                    userId={userId}
                    setUserId={setUserId}
                    businessId={businessId}
                    setBusinessId={setBusinessId}
                    businessApiKey={businessApiKey}
                    setBusinessApiKey={setBusinessApiKey}
                    handleSnackbarOpen={handleSnackbarOpen}
                />
            ) : (
                // Render dashboard content only if config is complete
                <>
                    <BusinessSection handleSnackbarOpen={handleSnackbarOpen} />

                    <AgentSection 
                        handleSnackbarOpen={handleSnackbarOpen} 
                        onAgentSelect={handleAgentSelect} 
                    />

                    <UserSection
                        firstName={firstName}
                        setFirstName={setFirstName}
                        lastName={lastName}
                        setLastName={setLastName}
                        email={email}
                        setEmail={setEmail}
                        createUser={createUser}
                        userOutput={userOutput}
                    />

                    <TemplateSection
                        templateID={templateID}
                        setTemplateID={setTemplateID}
                        templateName={templateName}
                        setTemplateName={setTemplateName}
                        templateText={templateText}
                        setTemplateText={setTemplateText}
                        createTemplate={createTemplate}
                        templateOutput={templateOutput}
                    />

                    <StageManagement
                        stageId={stageId}
                        setStageId={setStageId}
                        stageName={stageName}
                        setStageName={setStageName}
                        stageDescription={stageDescription}
                        setStageDescription={setStageDescription}
                        stageType={stageType}
                        setStageType={setStageType}
                        selectionTemplateId={selectionTemplateId}
                        setSelectionTemplateId={setSelectionTemplateId}
                        selectionCustomPrompt={selectionCustomPrompt}
                        setSelectionCustomPrompt={setSelectionCustomPrompt}
                         extractionTemplateId={extractionTemplateId}
                        setExtractionTemplateId={setExtractionTemplateId}
                        extractionCustomPrompt={extractionCustomPrompt}
                        setExtractionCustomPrompt={setExtractionCustomPrompt}
                        responseTemplateId={responseTemplateId}
                        setResponseTemplateId={setResponseTemplateId}
                        responseCustomPrompt={responseCustomPrompt}
                        setResponseCustomPrompt={setResponseCustomPrompt}
                        stageOutput={stageOutput}
                        setStageOutput={setStageOutput}
                        fetchStages={fetchStages}
                        createStage={createStage}
                        handleSnackbarOpen={handleSnackbarOpen}
                        apiKey={apiKey}
                        businessId={businessId} />

                    {/* Render StageSection, passing selectedAgentId and selection handler */}
                    <StageSection 
                        selectedAgentId={selectedAgentId} 
                        handleSnackbarOpen={handleSnackbarOpen}
                        onStageSelect={handleStageSelect}
                    />

                    {/* Conditionally render StageDetailView only when a stage is selected */}
                    {selectedStageId && (
                        <StageDetailView 
                            selectedStageId={selectedStageId} 
                            handleSnackbarOpen={handleSnackbarOpen} 
                        />
                    )}

                    <SendMessage processMessage={processMessage} handleSnackbarOpen={handleSnackbarOpen} />
                </>
            )}

            {/* Snackbar for notifications */}
            <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={handleSnackbarClose}>
                <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
                    {snackbarMessage}
                </Alert>
            </Snackbar>
        </div>
    );
}

export default MyInterface;

================================================================================
File: SendMessage.js
Path: .\front-end\src\components\SendMessage.js
Size: 1294
Modified: 2025-03-31T00:17:22.144152
Created: 2025-03-28T21:49:38.501143
Hash: 2f85e46b75c46465e6411ca3643a1ad0509519771ae446e83731f454cc89154d
Lines: 35
================================================================================
// File: src/components/SendMessage.js
// Last Modified: 2026-03-29

import React, { useState } from 'react';
import { TextareaAutosize, Button, Typography, Card, CardContent, Box } from '@mui/material';

function SendMessage({handleSnackbarOpen }) {
     const [messageInput, setMessageInput] = useState('');
     const [messageOutput, setMessageOutput] = useState('');

    const processMessage = async () => {
        //TODO
    };

    return (
        <Card sx={{ mt: 2 }}>
            <CardContent>
                <Typography variant="h6" gutterBottom>Send Message</Typography>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
                    <TextareaAutosize
                        minRows={3}
                        placeholder="Message"
                        style={{ width: 300, padding: 8 }}
                        value={messageInput}
                        onChange={(e) => setMessageInput(e.target.value)}
                    />
                    <Button variant="contained" onClick={processMessage}>Send</Button>
                    <Typography variant="body1">{messageOutput}</Typography>
                </Box>
            </CardContent>
        </Card>
    );
}

export default SendMessage;

================================================================================
File: StageDetailView.js
Path: .\front-end\src\components\StageDetailView.js
Size: 5894
Modified: 2025-04-01T16:20:33.925969
Created: 2025-04-01T16:20:20.927159
Hash: 50197b209d5d56c50726b6f09e498d23a30615658971e55bbda0c7fd4ab3d78d
Lines: 147
================================================================================
import React from 'react';
import {
    Typography,
    Card,
    CardContent,
    Box,
    TextField, // Use TextField for consistent layout, make read-only for now
    CircularProgress,
    Alert,
    Grid, // For layout
    Divider
} from '@mui/material';
import useStageDetails from '../hooks/useStageDetails'; // Import the hook

function StageDetailView({ selectedStageId, handleSnackbarOpen }) {
    // Use the hook to get details for the selected stage
    const { stageDetails, isLoading, error } = useStageDetails(selectedStageId, handleSnackbarOpen);

    // Define common TextField props for read-only view
    const textFieldProps = {
        variant: "outlined",
        fullWidth: true,
        InputProps: {
            readOnly: true, // Make fields read-only for now
        },
        size: "small",
        margin: "dense" // Adjust spacing
    };

    // Content to render based on loading/error/data state
    let content;
    if (!selectedStageId) {
        // This component should ideally not be rendered if no stage is selected,
        // but handle the case defensively.
        content = null; // Or a placeholder like <Typography>Select a stage</Typography>
    } else if (isLoading) {
        content = (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', p: 3 }}>
                <CircularProgress />
                <Typography sx={{ ml: 2 }}>Loading Stage Details...</Typography>
            </Box>
        );
    } else if (error) {
        content = <Alert severity="error" sx={{ m: 1 }}>Error loading stage details: {error}</Alert>;
    } else if (stageDetails) {
        // Assuming stageDetails object structure from typical API response
        content = (
            <Box>
                <Grid container spacing={1}>
                     {/* Basic Stage Info */}
                     <Grid item xs={12} sm={6}>
                        <TextField
                            label="Stage ID"
                            value={stageDetails.stage_id || ''}
                            {...textFieldProps}
                        />
                    </Grid>
                     <Grid item xs={12} sm={6}>
                        <TextField
                            label="Stage Name"
                            value={stageDetails.stage_name || ''}
                            {...textFieldProps}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6}>
                        <TextField
                            label="Stage Type"
                            value={stageDetails.stage_type || ''}
                            {...textFieldProps}
                            // Potentially map type ID/code to a user-friendly name later
                        />
                    </Grid>
                    <Grid item xs={12}>
                         <TextField
                            label="Description"
                            value={stageDetails.description || ''}
                            multiline
                            rows={2} // Adjust as needed
                            {...textFieldProps}
                        />
                    </Grid>
                </Grid>

                <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle1" gutterBottom>Associated Templates</Typography>
                <Grid container spacing={1}>
                    {/* Template IDs */}
                    <Grid item xs={12} sm={4}>
                        <TextField
                            label="Selection Template ID"
                            value={stageDetails.selection_template_id || 'None'}
                            {...textFieldProps}
                        />
                    </Grid>
                    <Grid item xs={12} sm={4}>
                        <TextField
                            label="Extraction Template ID"
                            value={stageDetails.extraction_template_id || 'None'}
                            {...textFieldProps}
                        />
                    </Grid>
                    <Grid item xs={12} sm={4}>
                        <TextField
                            label="Response Template ID"
                            value={stageDetails.response_template_id || 'None'}
                            {...textFieldProps}
                        />
                    </Grid>
                </Grid>

                {/* Placeholder for Template Management Windows */}
                {/* <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle1">Template Editors (Coming Soon)</Typography>
                {/* ... */}

                {/* Placeholder for Prompt Preview */}
                {/* <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle1">Prompt Preview (Coming Soon)</Typography>
                {/* ... */}
            </Box>
        );
    } else {
        // Should not happen if selectedStageId is valid but data is null after loading without error
        content = <Typography variant="body2" sx={{ p: 2 }}>No details available for this stage.</Typography>;
    }

    // Only render the card if a stage is selected
    if (!selectedStageId) {
        return null;
    }

    return (
        <Card sx={{ mt: 2 }}>
            <CardContent>
                 {/* Add Edit button later */}
                <Typography variant="h6" gutterBottom>
                    Stage Details {stageDetails ? `(${stageDetails.stage_name || selectedStageId})` : ''}
                </Typography>
                 <Divider sx={{ mb: 2 }} />
                {content}
            </CardContent>
        </Card>
    );
}

export default StageDetailView;


================================================================================
File: StageDetailView.jsx
Path: .\front-end\src\components\StageDetailView.jsx
Size: 3583
Modified: 2025-04-12T15:17:53.081668
Created: 2025-04-08T13:14:54.730426
Hash: 8d2effc0b42775381e4330fca13356e34bdcc963befd3b59025f54d1bc2fe918
Lines: 88
================================================================================
import React from 'react';
import {
    Card,
    CardContent,
    Typography,
    Grid,
    Divider,
    Box,
    CircularProgress,
    Button
} from '@mui/material';
import { useStageDetails } from '../hooks/useStageDetails';

function StageDetailView({ selectedStageId, handleSnackbarOpen }) {
    const { stageDetails, isLoading, error } = useStageDetails(selectedStageId, handleSnackbarOpen);

    let content;
    if (isLoading) {
        content = (
            <Box display="flex" justifyContent="center" alignItems="center" minHeight={200}>
                <CircularProgress />
            </Box>
        );
    } else if (error) {
        content = (
            <Typography color="error" variant="body1">
                {error}
            </Typography>
        );
    } else if (!stageDetails) {
        content = (
            <Typography variant="body1">
                No stage selected. Please select a stage to view its details.
            </Typography>
        );
    } else {
        content = (
            <Grid container spacing={2}>
                <Grid item xs={12}>
                    <Typography variant="subtitle1" color="primary">Basic Information</Typography>
                    <Typography variant="body1"><strong>Stage ID:</strong> {stageDetails.stage_id}</Typography>
                    <Typography variant="body1"><strong>Name:</strong> {stageDetails.stage_name}</Typography>
                    <Typography variant="body1"><strong>Type:</strong> {stageDetails.stage_type}</Typography>
                    <Typography variant="body1"><strong>Description:</strong> {stageDetails.stage_description}</Typography>
                </Grid>
                
                <Grid item xs={12}>
                    <Divider sx={{ my: 2 }} />
                    <Typography variant="subtitle1" color="primary">Template IDs</Typography>
                    <Typography variant="body1">
                        <strong>Stage Selection Template:</strong> {stageDetails.stage_selection_template_id || 'Not configured'}
                    </Typography>
                    <Typography variant="body1">
                        <strong>Data Extraction Template:</strong> {stageDetails.data_extraction_template_id || 'Not configured'}
                    </Typography>
                    <Typography variant="body1">
                        <strong>Response Generation Template:</strong> {stageDetails.response_generation_template_id || 'Not configured'}
                    </Typography>
                </Grid>

                {stageDetails.created_at && (
                    <Grid item xs={12}>
                        <Divider sx={{ my: 2 }} />
                        <Typography variant="body2" color="textSecondary">
                            Created: {new Date(stageDetails.created_at).toLocaleString()}
                        </Typography>
                    </Grid>
                )}
            </Grid>
        );
    }

    return (
        <Card sx={{ mt: 2 }}>
            <CardContent>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                    <Typography variant="h6">
                        Stage Details {stageDetails ? `(${stageDetails.stage_name || selectedStageId})` : ''}
                    </Typography>
                </Box>
                <Divider sx={{ mb: 2 }} />
                {content}
            </CardContent>
        </Card>
    );
}

export default StageDetailView; 

================================================================================
File: StageEditor.js
Path: .\front-end\src\components\StageEditor.js
Size: 5740
Modified: 2025-04-12T15:06:50.848407
Created: 2025-04-05T00:44:47.326555
Hash: edb114238680312c0b7af7fc53992a990dc4bccfea865947cfb7bff177ba2450
Lines: 213
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  Button,
  Alert,
  CircularProgress,
  Grid,
  Card,
  CardContent,
  CardHeader
} from '@mui/material';
import AddEditStageForm from './AddEditStageForm/AddEditStageForm';

const StageEditor = ({ stageId }) => {
  const navigate = useNavigate();
  
  // State variables
  const [stage, setStage] = useState(null);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  // Get stored credentials
  const getStoredCredentials = () => {
    return {
      businessId: localStorage.getItem('businessId') || '',
      businessApiKey: localStorage.getItem('businessApiKey') || ''
    };
  };

  // Track if component is mounted
  const isMounted = useRef(true);
  
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  // Fetch stage data on component mount
  useEffect(() => {
    const { businessId, businessApiKey } = getStoredCredentials();
    
    if (!businessId || !businessApiKey) {
      setError('Authentication required. Please log in.');
      return;
    }
    
    if (stageId && stageId !== 'new') {
      fetchStage(stageId, businessId, businessApiKey);
    }
  }, [stageId]);
  
  // Fetch specific stage data
  const fetchStage = async (id, businessId, businessApiKey) => {
    if (!isMounted.current || !businessId || !businessApiKey) {
      console.error('Missing required parameters:', { id, businessId, hasApiKey: !!businessApiKey });
      setIsLoading(false);
      return;
    }
    
    setIsLoading(true);
    setError('');
    try {
      const params = new URLSearchParams();
      params.append('business_id', businessId);
      
      const url = `/stages/${id}?${params.toString()}`;
      console.log('Fetching stage from URL:', url);
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${businessApiKey}`
        },
        credentials: 'include'
      });
      
      console.log('Response status:', response.status);
      
      // Log the raw response text first
      const responseText = await response.text();
      console.log('Raw response text:', responseText);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch stage: ${response.status} ${responseText || ''}`);
      }
      
      // Try to parse the response text as JSON
      let data;
      try {
        data = JSON.parse(responseText);
        console.log('Parsed stage data:', data);
      } catch (parseError) {
        console.error('Failed to parse response as JSON:', parseError);
        throw new Error('Invalid JSON response from server');
      }
      
      if (!data) {
        throw new Error('Empty response from server');
      }

      // Validate required fields
      const requiredFields = ['stage_name', 'stage_description', 'stage_type'];
      const missingFields = requiredFields.filter(field => !data[field]);
      if (missingFields.length > 0) {
        console.error('Missing required fields:', missingFields);
        console.log('Available fields:', Object.keys(data));
        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
      }
      
      if (isMounted.current) {
        setStage(data);
        setError('');
        console.log('Stage state set to:', data);
      }
    } catch (err) {
      console.error('Error in fetchStage:', err);
      if (isMounted.current) {
        setError(`Error: ${err.message}`);
        setStage(null);
      }
    } finally {
      if (isMounted.current) {
        setIsLoading(false);
      }
    }
  };
  
  // Handle return to stage management
  const handleReturn = () => {
    navigate('/stage-management');
  };
  
  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '200px' }}>
        <CircularProgress />
      </Box>
    );
  }
  
  if (error) {
    return (
      <Box>
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
        <Button
          variant="outlined"
          onClick={handleReturn}
          sx={{ mt: 2 }}
        >
          Return to Stage Management
        </Button>
      </Box>
    );
  }
  
  if (!stage) {
    return (
      <Box>
        <Alert severity="info" sx={{ mb: 2 }}>
          No stage data available. This could mean either:
          <ul>
            <li>The stage doesn't exist</li>
            <li>The data format is invalid</li>
            <li>There was an error fetching the data</li>
          </ul>
          {error && <Typography color="error">Error details: {error}</Typography>}
        </Alert>
        <Button 
          variant="outlined"
          onClick={handleReturn}
          sx={{ mt: 2 }}
        >
          Return to Stage Management
        </Button>
      </Box>
    );
  }
  
  // Add debug output before render
  console.log('Rendering stage:', stage);

  return (
    <Box>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h5" gutterBottom>
          {stageId === 'new' ? 'Create New Stage' : 'Edit Stage'}
        </Typography>
        
        <AddEditStageForm stageId={stageId} />
        
        <Box sx={{ mt: 3, display: 'flex', justifyContent: 'flex-start' }}>
          <Button
            variant="outlined"
            onClick={handleReturn}
            sx={{ mr: 2 }}
          >
            Return to Stage Management
          </Button>
        </Box>
      </Paper>
    </Box>
  );
};

export default StageEditor;

================================================================================
File: StageFlow.js
Path: .\front-end\src\components\StageFlow.js
Size: 9520
Modified: 2025-04-03T18:50:42.744990
Created: 2025-04-01T23:35:37.997434
Hash: 37aa6937330f15fa2fcdc47dc57a5f33776c8dd24f178557db3b0a6a185637a6
Lines: 314
================================================================================
import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Alert,
  Snackbar,
  IconButton,
  Tooltip,
  CircularProgress
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';

const StageFlow = ({ stages, businessId, agentId }) => {
  const [transitions, setTransitions] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [openDialog, setOpenDialog] = useState(false);
  const [selectedTransition, setSelectedTransition] = useState(null);
  const [newTransition, setNewTransition] = useState({
    from_stage_id: '',
    to_stage_id: '',
    condition: '',
    priority: 1
  });
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const fetchTransitions = useCallback(async () => {
    if (!businessId) {
      setError('Business ID is required');
      return;
    }

    setIsLoading(true);
    setError('');
    try {
      // Include agent_id in the query params if it exists
      const queryParams = new URLSearchParams({
        business_id: businessId
      });
      
      if (agentId) {
        queryParams.append('agent_id', agentId);
      }

      const response = await fetch(`/transitions?${queryParams.toString()}`, {
        credentials: 'include',
      });
      
      if (!response.ok) throw new Error('Failed to fetch transitions');
      const data = await response.json();
      setTransitions(data);
    } catch (err) {
      setError(err.message || 'Failed to fetch transitions');
    } finally {
      setIsLoading(false);
    }
  }, [businessId, agentId]);

  useEffect(() => {
    fetchTransitions();
  }, [fetchTransitions]);

  const handleCreateTransition = async () => {
    if (!newTransition.from_stage_id || !newTransition.to_stage_id) {
      setError('From stage and To stage are required');
      return;
    }

    setIsLoading(true);
    try {
      // Include agent_id in the transition data if it exists
      const transitionData = {
        ...newTransition,
        business_id: businessId,
        ...(agentId && { agent_id: agentId })
      };

      const response = await fetch('/transitions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(transitionData),
      });
      
      if (!response.ok) throw new Error('Failed to create transition');
      const data = await response.json();
      setTransitions([...transitions, data]);
      setOpenDialog(false);
      setNewTransition({
        from_stage_id: '',
        to_stage_id: '',
        condition: '',
        priority: 1
      });
      setSuccess('Transition created successfully');
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteTransition = async (transitionId) => {
    if (!window.confirm('Are you sure you want to delete this transition?')) {
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch(`/transitions/${transitionId}`, {
        method: 'DELETE',
        credentials: 'include',
      });
      
      if (!response.ok) throw new Error('Failed to delete transition');
      setTransitions(transitions.filter(t => t.transition_id !== transitionId));
      setSuccess('Transition deleted successfully');
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  const getStageNameById = (stageId) => {
    const stage = stages.find(s => s.stage_id === stageId);
    return stage ? stage.stage_name : 'Unknown Stage';
  };

  // Filter stages by agent_id if needed
  const filteredStages = agentId 
    ? stages.filter(stage => !stage.agent_id || stage.agent_id === agentId)
    : stages;

  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h5">
          Stage Transitions {agentId ? 'for Selected Agent' : ''}
        </Typography>
        <Button
          variant="contained"
          onClick={() => {
            setSelectedTransition(null);
            setNewTransition({
              from_stage_id: '',
              to_stage_id: '',
              condition: '',
              priority: 1
            });
            setOpenDialog(true);
          }}
          disabled={filteredStages.length < 2}
        >
          Add Transition
        </Button>
      </Box>

      {filteredStages.length < 2 && (
        <Alert severity="info" sx={{ mb: 3 }}>
          You need at least two stages to create transitions.
        </Alert>
      )}

      {isLoading && (
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 3 }}>
          <CircularProgress />
        </Box>
      )}
      
      {error && (
        <Alert severity="error" sx={{ my: 2 }}>
          {error}
        </Alert>
      )}

      {!isLoading && !error && transitions.length === 0 && (
        <Paper sx={{ p: 3, textAlign: 'center' }}>
          <Typography>No transitions defined yet.</Typography>
        </Paper>
      )}

      {!isLoading && !error && transitions.length > 0 && (
        <Grid container spacing={2}>
          {transitions.map((transition) => (
            <Grid item xs={12} md={6} key={transition.transition_id}>
              <Paper sx={{ p: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                  <Typography variant="subtitle1">
                    {getStageNameById(transition.from_stage_id)}  {getStageNameById(transition.to_stage_id)}
                  </Typography>
                  <Button 
                    variant="outlined" 
                    color="error" 
                    size="small"
                    onClick={() => handleDeleteTransition(transition.transition_id)}
                  >
                    Delete
                  </Button>
                </Box>
                <Typography variant="body2">
                  <strong>Condition:</strong> {transition.condition || 'Unconditional'}
                </Typography>
                <Typography variant="body2">
                  <strong>Priority:</strong> {transition.priority}
                </Typography>
              </Paper>
            </Grid>
          ))}
        </Grid>
      )}

      <Dialog open={openDialog} onClose={() => setOpenDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>
          {selectedTransition ? 'Edit Transition' : 'Create New Transition'}
        </DialogTitle>
        <DialogContent>
          <FormControl fullWidth sx={{ mt: 2 }}>
            <InputLabel>From Stage</InputLabel>
            <Select
              value={newTransition.from_stage_id}
              onChange={(e) => setNewTransition({ ...newTransition, from_stage_id: e.target.value })}
              label="From Stage"
            >
              {filteredStages.map((stage) => (
                <MenuItem key={stage.stage_id} value={stage.stage_id}>
                  {stage.stage_name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>

          <FormControl fullWidth sx={{ mt: 2 }}>
            <InputLabel>To Stage</InputLabel>
            <Select
              value={newTransition.to_stage_id}
              onChange={(e) => setNewTransition({ ...newTransition, to_stage_id: e.target.value })}
              label="To Stage"
            >
              {filteredStages.map((stage) => (
                <MenuItem key={stage.stage_id} value={stage.stage_id}>
                  {stage.stage_name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>

          <TextField
            fullWidth
            label="Condition"
            value={newTransition.condition}
            onChange={(e) => setNewTransition({ ...newTransition, condition: e.target.value })}
            sx={{ mt: 2 }}
            helperText="Enter the condition that triggers this transition (e.g., 'user_agreed', 'payment_completed')"
          />

          <TextField
            margin="dense"
            label="Priority"
            type="number"
            fullWidth
            value={newTransition.priority}
            onChange={(e) => setNewTransition({ ...newTransition, priority: parseInt(e.target.value) || 1 })}
            sx={{ mt: 1 }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenDialog(false)}>Cancel</Button>
          <Button onClick={handleCreateTransition} variant="contained">
            {selectedTransition ? 'Update' : 'Create'}
          </Button>
        </DialogActions>
      </Dialog>

      <Snackbar
        open={!!error}
        autoHideDuration={6000}
        onClose={() => setError('')}
      >
        <Alert severity="error" onClose={() => setError('')}>
          {error}
        </Alert>
      </Snackbar>

      <Snackbar
        open={!!success}
        autoHideDuration={6000}
        onClose={() => setSuccess('')}
      >
        <Alert severity="success" onClose={() => setSuccess('')}>
          {success}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default StageFlow; 

================================================================================
File: StageManagement.js
Path: .\front-end\src\components\StageManagement.js
Size: 2991
Modified: 2025-04-02T23:16:17.412997
Created: 2025-03-28T21:49:10.331438
Hash: 7ff34d20e1f4aad5d7913617bc66db8527f51fb78760e256d5fff736fe48eddd
Lines: 59
================================================================================
import React from 'react';
import {
    TextField, Button, Typography, Card, CardContent, Box,
} from '@mui/material';

function StageManagement({
    stageId,
    setStageId,
    stageName,
    setStageName,
    stageDescription,
    setStageDescription,
    stageType,
    setStageType,
    selectionTemplateId,
    setSelectionTemplateId,
    selectionCustomPrompt,
    setSelectionCustomPrompt,
    extractionTemplateId,
    setExtractionTemplateId,
    extractionCustomPrompt,
    setExtractionCustomPrompt,
    responseTemplateId,
    setResponseTemplateId,
    responseCustomPrompt,
    setResponseCustomPrompt,
    stageOutput,
    setStageOutput,
    fetchStages,
    createStage,
    handleSnackbarOpen,
    businessId
}) {

    return (
        <Card sx={{ mt: 2 }}>
            <CardContent>
                <Typography variant="h6" gutterBottom>Stage Management</Typography>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
                    <TextField label="Stage ID" variant="outlined" value={stageId} onChange={(e) => setStageId(e.target.value)} />
                    <TextField label="Stage Name" variant="outlined" value={stageName} onChange={(e) => setStageName(e.target.value)} />
                    <TextField label="Stage Description" variant="outlined" value={stageDescription} onChange={(e) => setStageDescription(e.target.value)} />
                    <TextField label="Stage Type" variant="outlined" value={stageType} onChange={(e) => setStageType(e.target.value)} />
                    <TextField label="Selection Template ID" variant="outlined" value={selectionTemplateId} onChange={(e) => setSelectionTemplateId(e.target.value)} />
                    <TextField label="Selection Custom Prompt" variant="outlined" value={selectionCustomPrompt} onChange={(e) => setSelectionCustomPrompt(e.target.value)} />
                     <TextField label="Extraction Template ID" variant="outlined" value={extractionTemplateId} onChange={(e) => setExtractionTemplateId(e.target.value)} />
                     <TextField label="Extraction Custom Prompt" variant="outlined" value={extractionCustomPrompt} onChange={(e) => setExtractionCustomPrompt(e.target.value)} />
                    <TextField label="Response Template ID" variant="outlined" value={responseTemplateId} onChange={(e) => setResponseTemplateId(e.target.value)} />
                     <TextField label="Response Custom Prompt" variant="outlined" value={responseCustomPrompt} onChange={(e) => setResponseCustomPrompt(e.target.value)} />
                    <Button variant="contained" onClick={fetchStages}>Fetch Stages</Button>
                    <Button variant="contained" onClick={createStage}>Create Stage</Button>
                    <Typography variant="body1">{stageOutput}</Typography>
                </Box>
            </CardContent>
        </Card>
    );
}

export default StageManagement;

================================================================================
File: StageManager.js
Path: .\front-end\src\components\StageManager.js
Size: 29929
Modified: 2025-04-12T17:16:47.452383
Created: 2025-04-01T23:31:12.449774
Hash: 5d836ff3fdc02fe4ac9ea6c730414713e818b6311810610c392e7b70629ce272
Lines: 861
================================================================================
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import {
  Container,
  Typography,
  Paper,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  CircularProgress,
  Grid,
  Box,
  IconButton,
  Divider,
  Alert,
  Snackbar,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Tooltip,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  Card,
  CardContent,
  FormHelperText,
  ListSubheader
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import ArrowUpwardIcon from '@mui/icons-material/ArrowUpward';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import SaveIcon from '@mui/icons-material/Save';
import DescriptionIcon from '@mui/icons-material/Description';
import VisibilityIcon from '@mui/icons-material/Visibility';
import StarIcon from '@mui/icons-material/Star';
import { fetchStages, createStage, updateStage, deleteStage } from '../services/stageService';
import { getAuthHeaders } from '../services/authService';
import useAgents from '../hooks/useAgents';

const StageManager = () => {
  // Get parameters from URL and location
  const { businessId: paramBusinessId, agentId: paramAgentId } = useParams();
  const location = useLocation();
  const navigate = useNavigate();
  
  // Extract query parameters if not using path params
  const queryParams = new URLSearchParams(location.search);
  const queryBusinessId = queryParams.get('business_id');
  const queryAgentId = queryParams.get('agent_id');
  
  // Use params or query params, then fallback to localStorage
  const businessId = paramBusinessId || queryBusinessId || localStorage.getItem('businessId');
  const agentId = paramAgentId || queryAgentId || localStorage.getItem('agentId');
  
  // States for stages and templates
  const [stages, setStages] = useState([]);
  const [selectedStage, setSelectedStage] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [openDialog, setOpenDialog] = useState(false);
  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
  const [stageToDelete, setStageToDelete] = useState(null);
  const [newStageName, setNewStageName] = useState('');
  const [stageDescription, setStageDescription] = useState('');
  const [stageType, setStageType] = useState('conversation');
  const [availableTemplates, setAvailableTemplates] = useState({
    stage_selection: [],
    data_extraction: [],
    response_generation: []
  });
  const [selectedTemplates, setSelectedTemplates] = useState({
    stage_selection: '',
    data_extraction: '',
    response_generation: ''
  });
  const [defaultTemplates, setDefaultTemplates] = useState({
    stage_selection: '',
    data_extraction: '',
    response_generation: ''
  });
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });
  const [agentName, setAgentName] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { agents, isLoading: agentsLoading, error: agentsError, refreshAgents } = useAgents();
  const [selectedAgentId, setSelectedAgentId] = useState('');

  // Store current values in localStorage for persistence
  useEffect(() => {
    if (businessId) {
      localStorage.setItem('businessId', businessId);
    }
    if (agentId) {
      localStorage.setItem('agentId', agentId);
    }
  }, [businessId, agentId]);

  // Logging for debugging
  useEffect(() => {
    console.log("StageManager - Current params:", { 
      paramBusinessId, 
      paramAgentId,
      queryBusinessId,
      queryAgentId,
      resolvedBusinessId: businessId,
      resolvedAgentId: agentId
    });
  }, [
    paramBusinessId, 
    paramAgentId, 
    queryBusinessId, 
    queryAgentId, 
    businessId, 
    agentId
  ]);

  // Fetch templates for this business
  const fetchTemplates = async () => {
    try {
      const headers = getAuthHeaders();
      
      // Add business_id to the URL as a query parameter
      const response = await fetch(`/api/templates/?business_id=${businessId}`, { 
        headers,
        credentials: 'include'
      });
      
      if (!response.ok) {
        console.error('Template fetch error:', response.status, response.statusText);
        throw new Error('Failed to fetch templates');
      }
      
      const templates = await response.json();
      console.log('Fetched templates:', templates);
      
      // Initialize template categories
      const templatesByType = {
        stage_selection: [],
        data_extraction: [],
        response_generation: []
      };

      // Process and categorize templates
      templates.forEach(template => {
        // Add isDefault flag to identify default templates
        const normalizedTemplate = {
          ...template,
          isDefault: template.template_type.startsWith('default_')
        };

        // Map template types to categories
        const typeMapping = {
          'stage_selection': 'stage_selection',
          'default_stage_selection': 'stage_selection',
          'data_extraction': 'data_extraction',
          'default_data_extraction': 'data_extraction',
          'response_generation': 'response_generation',
          'default_response_generation': 'response_generation'
        };

        const category = typeMapping[template.template_type];
        if (category) {
          templatesByType[category].push(normalizedTemplate);
        }
      });

      // Sort templates within each category
      Object.keys(templatesByType).forEach(category => {
        templatesByType[category].sort((a, b) => {
          // Sort by isDefault first (default templates first)
          if (a.isDefault !== b.isDefault) {
            return a.isDefault ? -1 : 1;
          }
          // Then sort by name
          return a.template_name.localeCompare(b.template_name);
        });
      });

      setAvailableTemplates(templatesByType);
      
      // Set default templates if available
      const defaultTemplates = {
        stage_selection: '',
        data_extraction: '',
        response_generation: ''
      };
      
      // Find default templates in each category
      Object.keys(templatesByType).forEach(category => {
        const defaultTemplate = templatesByType[category].find(t => t.isDefault);
        if (defaultTemplate) {
          defaultTemplates[category] = defaultTemplate.template_id;
        }
      });
      
      setDefaultTemplates(defaultTemplates);
      
      // If we're opening the dialog, pre-select default templates
      if (openDialog) {
        setSelectedTemplates(defaultTemplates);
      }
      
    } catch (error) {
      console.error('Error fetching templates:', error);
      setError('Failed to load templates. Please try again.');
    }
  };

  // Handle template selection change
  const handleTemplateChange = (event, templateType) => {
    const templateId = event.target.value;
    console.log(`Template changed for ${templateType}: ${templateId}`);
    
    setSelectedTemplates(prev => ({
      ...prev,
      [templateType]: templateId
    }));
  };

  // Fetch stages based on business ID and agent ID
  const fetchStagesData = useCallback(async () => {
    if (!businessId) {
      console.error("No business ID available for fetching stages");
      setIsLoading(false);
      return;
    }
    
    setIsLoading(true);
    try {
      console.log("Fetching stages for business:", businessId);
      const stagesData = await fetchStages(businessId);
      console.log("Fetched stages:", stagesData);
      setStages(stagesData);
    } catch (err) {
      console.error("Error fetching stages:", err);
      showSnackbar(err.message, 'error');
    } finally {
      setIsLoading(false);
    }
  }, [businessId]);

  // Fetch agent details
  const fetchAgentDetails = useCallback(async () => {
    if (!businessId || !agentId) {
      return;
    }

    try {
      const response = await fetch(`/agents/${agentId}?business_id=${businessId}`, {
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error('Failed to fetch agent details');
      }
      
      const agentData = await response.json();
      setAgentName(agentData.agent_name || `Agent ${agentId}`);
    } catch (err) {
      console.error("Error fetching agent details:", err);
      setAgentName(`Agent ${agentId}`); // Fallback
    }
  }, [businessId, agentId]);

  // Initial data fetch
  useEffect(() => {
    if (businessId) {
      const loadData = async () => {
        setIsLoading(true);
        setError('');
        
        try {
          // Load templates first
          await fetchTemplates();
          // Then load stages
          await fetchStagesData();
          
          // Set the selected agent ID if it exists in the stage data
          if (selectedStage && selectedStage.agent_id) {
            setSelectedAgentId(selectedStage.agent_id);
          } else {
            setSelectedAgentId('');
          }
        } catch (err) {
          console.error("Error in initial data load:", err);
          showSnackbar("Failed to load initial data: " + err.message, 'error');
        } finally {
          setIsLoading(false);
        }
      };
      
      loadData();
    }
  }, [businessId]);

  // Update useEffect to fetch agent details
  useEffect(() => {
    if (agentId) {
      fetchAgentDetails();
    }
  }, [agentId, fetchAgentDetails]);

  // Helper function for showing snackbar messages
  const showSnackbar = (message, severity = 'success') => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };

  const handleCloseSnackbar = () => {
    setSnackbar({
      ...snackbar,
      open: false
    });
  };

  const handleNavigateToHome = () => {
    navigate('/business');
  };

  const handleOpenNewStageDialog = () => {
    setNewStageName('');
    setStageDescription('');
    setStageType('conversation');
    
    // Set default templates if available
    setSelectedTemplates(defaultTemplates);
    
    setSelectedAgentId(agentId || ''); // Set the selected agent ID to the current agent ID
    setOpenDialog(true);
  };

  const handleCreateStage = async () => {
    if (!newStageName.trim()) {
      setError('Stage name is required');
      return;
    }
    
    setIsSubmitting(true);
    setError('');
    
    try {
      const stageData = {
        business_id: businessId,
        agent_id: selectedAgentId, // Include the selected agent ID
        stage_name: newStageName.trim(),
        stage_description: stageDescription.trim(),
        stage_type: stageType,
        stage_selection_template_id: selectedTemplates.stage_selection || null,
        data_extraction_template_id: selectedTemplates.data_extraction || null,
        response_generation_template_id: selectedTemplates.response_generation || null
      };
      
      console.log('Creating stage with data:', stageData);

      // Create the stage
      const response = await fetch('/stages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('businessApiKey')}`
        },
        credentials: 'include',
        body: JSON.stringify(stageData)
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create stage');
      }

      const result = await response.json();
      console.log('Stage created successfully:', result);
      
      showSnackbar('Stage created successfully', 'success');
      
      // Reset form
      setNewStageName('');
      
      // Refresh stages
      fetchStagesData();
      
      // Close dialog
      setOpenDialog(false);
    } catch (error) {
      console.error('Error creating stage:', error);
      showSnackbar(error.message, 'error');
    } finally {
      setIsSubmitting(false);
    }
  };

  const navigateToStageView = (stageId) => {
    // Construct the URL with query parameters
    let url = `/stages/${stageId}?business_id=${businessId}`;
    if (agentId) {
      url += `&agent_id=${agentId}`;
    }
    navigate(url);
  };

  const handleDeleteStage = async () => {
    if (!stageToDelete || !businessId) return;

    try {
      await deleteStage(stageToDelete.stage_id, businessId);
      await fetchStagesData();
      setOpenDeleteDialog(false);
      showSnackbar('Stage deleted successfully', 'success');
    } catch (err) {
      console.error("Error deleting stage:", err);
      showSnackbar(err.message, 'error');
    }
  };

  const handleMoveStage = async (stageId, direction) => {
    try {
      const currentIndex = stages.findIndex(s => s.stage_id === stageId);
      if (currentIndex === -1) return;
      
      // If trying to move first item up or last item down, do nothing
      if ((currentIndex === 0 && direction === 'up') || 
          (currentIndex === stages.length - 1 && direction === 'down')) {
        return;
      }
      
      const targetIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
      
      // Swap the order values in the stage_config
      const updatedStages = [...stages];
      const currentStage = { ...updatedStages[currentIndex] };
      const targetStage = { ...updatedStages[targetIndex] };
      
      // Update stage_config.order values
      currentStage.stage_config = { ...currentStage.stage_config, order: targetIndex + 1 };
      targetStage.stage_config = { ...targetStage.stage_config, order: currentIndex + 1 };
      
      // Update both stages in the database
      const currentUpdate = fetch(`/stages/${currentStage.stage_id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(currentStage),
      });
      
      const targetUpdate = fetch(`/stages/${targetStage.stage_id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(targetStage),
      });
      
      await Promise.all([currentUpdate, targetUpdate]);
      
      // Refresh stages
      await fetchStagesData();
      showSnackbar('Stage order updated', 'success');
    } catch (err) {
      showSnackbar(err.message, 'error');
    }
  };

  // Add a handler for agent selection
  const handleAgentChange = (event) => {
    setSelectedAgentId(event.target.value);
  };

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Paper sx={{ p: 3, mb: 4 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <IconButton onClick={handleNavigateToHome} sx={{ mr: 1 }}>
            <ArrowBackIcon />
          </IconButton>
          <Typography variant="h5" component="h1" gutterBottom sx={{ flexGrow: 1 }}>
            Stage Manager
            {businessId && <Typography variant="subtitle1" component="span" color="text.secondary">
              {` - Business ID: ${businessId}`}
              {agentId && ` - Agent: ${agentName || agentId}`}
            </Typography>}
          </Typography>
          <Button
            variant="contained"
            color="primary"
            startIcon={<AddIcon />}
            onClick={handleOpenNewStageDialog}
            sx={{ mr: 1 }}
          >
            Create Stage
          </Button>
          <Button
            variant="outlined"
            color="secondary"
            startIcon={<DescriptionIcon />}
            onClick={() => navigate('/templates')}
          >
            Manage Templates
          </Button>
        </Box>
        
        <Divider sx={{ mb: 3 }} />
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError('')}>
            {error}
          </Alert>
        )}
        
        {success && (
          <Alert severity="success" sx={{ mb: 2 }} onClose={() => setSuccess('')}>
            {success}
          </Alert>
        )}
        
        {isLoading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
            <CircularProgress />
          </Box>
        ) : (
          <>
            {stages.length === 0 ? (
              <Alert severity="info">
                No stages found. Create your first stage to get started.
              </Alert>
            ) : (
              <List sx={{ bgcolor: 'background.paper' }}>
                {[...stages].sort((a, b) => 
                  (a.stage_config?.order || Infinity) - (b.stage_config?.order || Infinity)
                ).map((stage) => (
                  <ListItem 
                    key={stage.stage_id}
                    sx={{ 
                      mb: 1,
                      bgcolor: 'background.paper'
                    }}
                  >
                    <ListItemText
                      primary={stage.stage_name}
                      secondary={
                        <>
                          <Typography component="span" variant="body2" color="text.primary">
                            {stage.stage_description || 'No description'}
                          </Typography>
                          {stage.stage_config && stage.stage_config.order && 
                            `  Order: ${stage.stage_config.order}`}
                        </>
                      }
                    />
                    <ListItemSecondaryAction>
                      <Tooltip title="Move Up">
                        <IconButton 
                          edge="end" 
                          aria-label="move-up"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleMoveStage(stage.stage_id, 'up');
                          }}
                          disabled={stages.indexOf(stage) === 0}
                        >
                          <ArrowUpwardIcon />
                        </IconButton>
                      </Tooltip>
                      <Tooltip title="Move Down">
                        <IconButton 
                          edge="end" 
                          aria-label="move-down"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleMoveStage(stage.stage_id, 'down');
                          }}
                          disabled={stages.indexOf(stage) === stages.length - 1}
                        >
                          <ArrowDownwardIcon />
                        </IconButton>
                      </Tooltip>
                      <Tooltip title="View Stage">
                        <IconButton 
                          edge="end" 
                          aria-label="view"
                          onClick={(e) => {
                            e.stopPropagation();
                            navigateToStageView(stage.stage_id);
                          }}
                        >
                          <VisibilityIcon />
                        </IconButton>
                      </Tooltip>
                      <Tooltip title="Delete Stage">
                        <IconButton 
                          edge="end" 
                          aria-label="delete"
                          onClick={(e) => {
                            e.stopPropagation();
                            setStageToDelete(stage);
                            setOpenDeleteDialog(true);
                          }}
                        >
                          <DeleteIcon />
                        </IconButton>
                      </Tooltip>
                    </ListItemSecondaryAction>
                  </ListItem>
                ))}
              </List>
            )}
          </>
        )}
      </Paper>
      
      {/* Create Stage Dialog */}
      <Dialog 
        open={openDialog} 
        onClose={() => !isSubmitting && setOpenDialog(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {selectedStage ? 'Edit Stage' : 'Create New Stage'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2}>
            {/* Add console logs to help debug */}
            {console.log("Dialog rendering with state:", {
              selectedTemplates,
              availableTemplates,
              defaultTemplates,
              templatesInfo: {
                stageSelectionCount: availableTemplates.stage_selection.length,
                dataExtractionCount: availableTemplates.data_extraction.length,
                responseGenerationCount: availableTemplates.response_generation.length,
              }
            })}
            
            {/* Stage Name */}
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Stage Name"
                value={newStageName}
                onChange={(e) => setNewStageName(e.target.value)}
                required
              />
            </Grid>
            
            {/* Stage Description */}
            <Grid item xs={12}>
              <TextField
                fullWidth
                multiline
                rows={2}
                label="Stage Description"
                value={stageDescription}
                onChange={(e) => setStageDescription(e.target.value)}
              />
            </Grid>
            
            {/* Template Selection Dropdown - Stage Selection */}
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Stage Selection Template</InputLabel>
                <Select
                  fullWidth
                  value={selectedTemplates.stage_selection}
                  onChange={(e) => handleTemplateChange(e, 'stage_selection')}
                >
                  <MenuItem value="">
                    <em>None</em>
                  </MenuItem>
                  {availableTemplates.stage_selection.map((template) => (
                    <MenuItem 
                      key={template.template_id} 
                      value={template.template_id}
                      sx={template.isDefault ? { 
                        backgroundColor: 'rgba(245, 0, 87, 0.04)',
                        '&:hover': {
                          backgroundColor: 'rgba(245, 0, 87, 0.08)'
                        }
                      } : {}}
                    >
                      {template.isDefault ? (
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <StarIcon sx={{ mr: 1, color: 'secondary.main', fontSize: '1rem' }} />
                          {template.template_name}
                        </Box>
                      ) : template.template_name}
                    </MenuItem>
                  ))}
                </Select>
                <FormHelperText>Template for determining if this stage should handle the message</FormHelperText>
              </FormControl>
            </Grid>
            
            {/* Template Selection Dropdown - Data Extraction */}
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Data Extraction Template</InputLabel>
                <Select
                  fullWidth
                  value={selectedTemplates.data_extraction}
                  onChange={(e) => handleTemplateChange(e, 'data_extraction')}
                >
                  <MenuItem value="">
                    <em>None</em>
                  </MenuItem>
                  {availableTemplates.data_extraction.map((template) => (
                    <MenuItem 
                      key={template.template_id} 
                      value={template.template_id}
                      sx={template.isDefault ? { 
                        backgroundColor: 'rgba(245, 0, 87, 0.04)',
                        '&:hover': {
                          backgroundColor: 'rgba(245, 0, 87, 0.08)'
                        }
                      } : {}}
                    >
                      {template.isDefault ? (
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <StarIcon sx={{ mr: 1, color: 'secondary.main', fontSize: '1rem' }} />
                          {template.template_name}
                        </Box>
                      ) : template.template_name}
                    </MenuItem>
                  ))}
                </Select>
                <FormHelperText>Template for extracting data from the message</FormHelperText>
              </FormControl>
            </Grid>
            
            {/* Template Selection Dropdown - Response Generation */}
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Response Generation Template</InputLabel>
                <Select
                  fullWidth
                  value={selectedTemplates.response_generation}
                  onChange={(e) => handleTemplateChange(e, 'response_generation')}
                >
                  <MenuItem value="">
                    <em>None</em>
                  </MenuItem>
                  {availableTemplates.response_generation.map((template) => (
                    <MenuItem 
                      key={template.template_id} 
                      value={template.template_id}
                      sx={template.isDefault ? { 
                        backgroundColor: 'rgba(245, 0, 87, 0.04)',
                        '&:hover': {
                          backgroundColor: 'rgba(245, 0, 87, 0.08)'
                        }
                      } : {}}
                    >
                      {template.isDefault ? (
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <StarIcon sx={{ mr: 1, color: 'secondary.main', fontSize: '1rem' }} />
                          {template.template_name}
                        </Box>
                      ) : template.template_name}
                    </MenuItem>
                  ))}
                </Select>
                <FormHelperText>Template for generating responses</FormHelperText>
              </FormControl>
            </Grid>
            
            {/* Add Agent Selection Dropdown */}
            <FormControl fullWidth margin="normal">
              <InputLabel id="agent-select-label">Agent</InputLabel>
              <Select
                labelId="agent-select-label"
                id="agent-select"
                value={selectedAgentId}
                label="Agent"
                onChange={handleAgentChange}
                disabled={isSubmitting}
              >
                <MenuItem value="">
                  <em>None</em>
                </MenuItem>
                {agents.map((agent) => (
                  <MenuItem key={agent.agent_id} value={agent.agent_id}>
                    {agent.agent_name}
                  </MenuItem>
                ))}
              </Select>
              <FormHelperText>
                Select an agent to associate with this stage
              </FormHelperText>
            </FormControl>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => !isSubmitting && setOpenDialog(false)}>Cancel</Button>
          <Button 
            onClick={handleCreateStage} 
            variant="contained" 
            color="primary"
            disabled={!newStageName.trim()}
            startIcon={<SaveIcon />}
          >
            Create & Save
          </Button>
        </DialogActions>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <Dialog
        open={openDeleteDialog}
        onClose={() => setOpenDeleteDialog(false)}
      >
        <DialogTitle>Confirm Delete</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete the stage "{stageToDelete?.stage_name}"?
            This action cannot be undone.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenDeleteDialog(false)}>Cancel</Button>
          <Button 
            onClick={handleDeleteStage} 
            variant="contained" 
            color="error"
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
      >
        <Alert severity={snackbar.severity} onClose={handleCloseSnackbar}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default StageManager; 

================================================================================
File: StageSection.js
Path: .\front-end\src\components\StageSection.js
Size: 5174
Modified: 2025-04-01T16:16:33.367519
Created: 2025-04-01T16:16:18.326624
Hash: 01bf3e77028be0172c63e7b32715a2a9087af072ae2168c3b86c50a410c81a18
Lines: 124
================================================================================
import React, { useState } from 'react';
import {
    Typography,
    Card,
    CardContent,
    List,
    ListItem,
    ListItemText,
    CircularProgress,
    Alert,
    Button,
    Box,
    Divider,
    IconButton // For potential Edit button
} from '@mui/material';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import EditIcon from '@mui/icons-material/Edit'; // Example icon for Edit
import useStages from '../hooks/useStages'; // Import the hook we just created

// Define the StageSection component
function StageSection({ selectedAgentId, handleSnackbarOpen, onStageSelect }) {
    // Use the hook to get stages for the selected agent
    const { stages, isLoading, error, refreshStages } = useStages(selectedAgentId, handleSnackbarOpen);
    const [selectedStageId, setSelectedStageId] = useState(null);

    // Handler for selecting a stage
    const handleStageClick = (stageId) => {
        console.log("Selected Stage ID:", stageId);
        setSelectedStageId(stageId);
        if (onStageSelect) {
            onStageSelect(stageId); // Notify parent component
        }
    };

     // Handler for the Create New Stage button click
     const handleCreateStage = () => {
        // TODO: Implement logic to open a modal or form for creating a new stage
        console.log("Create New Stage clicked");
        handleSnackbarOpen("Create stage functionality not yet implemented.", "info");
    };

    // Handler for the Edit Stage button click
    const handleEditStage = (stageId, event) => {
        event.stopPropagation(); // Prevent triggering handleStageClick
        // TODO: Implement logic to open a modal or form for editing the stage
        console.log("Edit Stage clicked:", stageId);
        handleSnackbarOpen(`Edit stage (${stageId}) functionality not yet implemented.`, "info");
    };


    // Determine the content based on whether an agent is selected and loading/error states
    let content;
    if (!selectedAgentId) {
        content = <Typography variant="body2" sx={{ p: 2, textAlign: 'center', color: 'text.secondary' }}>Please select an agent to view stages.</Typography>;
    } else if (isLoading) {
        content = (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', p: 2 }}>
                <CircularProgress size={24} />
                <Typography sx={{ ml: 1 }} variant="body2">Loading Stages...</Typography>
            </Box>
        );
    } else if (error) {
        content = <Alert severity="error">Error loading stages: {error}</Alert>;
    } else if (stages.length > 0) {
        content = (
            <List dense>
                {stages.map((stage) => (
                    <ListItem
                        key={stage.stage_id} // Assuming stage object has stage_id
                        button
                        selected={selectedStageId === stage.stage_id}
                        onClick={() => handleStageClick(stage.stage_id)}
                        secondaryAction={
                            <IconButton
                                edge="end"
                                aria-label="edit"
                                onClick={(e) => handleEditStage(stage.stage_id, e)}
                            >
                                <EditIcon />
                            </IconButton>
                        }
                    >
                        {/* Assuming stage object has stage_name and description */}
                        <ListItemText
                            primary={stage.stage_name || 'Unnamed Stage'}
                            secondary={stage.description || 'No description'}
                        />
                    </ListItem>
                ))}
            </List>
        );
    } else {
        content = <Typography variant="body2" sx={{ p: 2, textAlign: 'center' }}>No stages found for this agent.</Typography>;
    }

    return (
        <Card sx={{ mt: 2 }}>
             <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                    <Typography variant="h6" gutterBottom component="div">
                        Stages
                    </Typography>
                     {/* Conditionally render Create button only if an agent is selected */}
                     {selectedAgentId && (
                        <Button
                            variant="contained"
                            size="small"
                            startIcon={<AddCircleOutlineIcon />}
                            onClick={handleCreateStage}
                            disabled={!selectedAgentId} // Disable if no agent selected (redundant due to outer check, but safe)
                        >
                            Create Stage
                        </Button>
                     )}
                </Box>
                <Divider sx={{ mb: 1 }}/>
                {content}
            </CardContent>
        </Card>
    );
}

export default StageSection;


================================================================================
File: StageView.jsx
Path: .\front-end\src\components\StageView.jsx
Size: 19316
Modified: 2025-04-12T16:10:26.917300
Created: 2025-04-08T13:23:04.954572
Hash: ae415aa8b85f2f0fd6ffe4ade563f1292730946340e2bb27982931d224e0051f
Lines: 472
================================================================================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
    Box,
    Paper,
    Typography,
    Divider,
    CircularProgress,
    Alert,
    Grid,
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    FormControl,
    InputLabel,
    Select,
    MenuItem
} from '@mui/material';
import { API_CONFIG } from '../config';
import EditIcon from '@mui/icons-material/Edit';
import useAgents from '../hooks/useAgents';

const StageView = () => {
    const { stageId } = useParams();
    const navigate = useNavigate();
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [stageData, setStageData] = useState(null);
    const [editDialogOpen, setEditDialogOpen] = useState(false);
    const [newStageName, setNewStageName] = useState('');
    const [newStageDescription, setNewStageDescription] = useState('');
    const [editLoading, setEditLoading] = useState(false);
    const [editError, setEditError] = useState(null);
    const [editType, setEditType] = useState(''); // 'name', 'description', or 'agent'
    const [selectedAgentId, setSelectedAgentId] = useState('');
    const [agents, setAgents] = useState([]);
    const [agentsLoading, setAgentsLoading] = useState(false);
    const [agentsError, setAgentsError] = useState(null);

    // Fetch agents
    useEffect(() => {
        const fetchAgents = async () => {
            setAgentsLoading(true);
            setAgentsError(null);
            
            try {
                const businessId = localStorage.getItem('businessId');
                const businessApiKey = localStorage.getItem('businessApiKey');

                if (!businessId || !businessApiKey) {
                    setAgentsError('Authentication required. Please log in.');
                    setAgentsLoading(false);
                    return;
                }

                const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.AGENTS}?business_id=${businessId}`, {
                    headers: {
                        'Accept': 'application/json',
                        'Authorization': `Bearer ${businessApiKey}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `HTTP error ${response.status}`);
                }

                const data = await response.json();
                setAgents(data);
            } catch (err) {
                console.error('Error fetching agents:', err);
                setAgentsError(err.message);
            } finally {
                setAgentsLoading(false);
            }
        };

        fetchAgents();
    }, []);

    useEffect(() => {
        const fetchStageData = async () => {
            if (!stageId) {
                setLoading(false);
                return;
            }

            try {
                const businessId = localStorage.getItem('businessId');
                const businessApiKey = localStorage.getItem('businessApiKey');

                if (!businessId || !businessApiKey) {
                    setError('Authentication required. Please log in.');
                    setLoading(false);
                    return;
                }

                const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.STAGES}/${stageId}?business_id=${businessId}`, {
                    headers: {
                        'Accept': 'application/json',
                        'Authorization': `Bearer ${businessApiKey}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `HTTP error ${response.status}`);
                }

                const data = await response.json();
                console.log('Stage data:', data);
                setStageData(data);
                setNewStageName(data.stage_name);
                setNewStageDescription(data.stage_description || '');
                setSelectedAgentId(data.agent_id || '');
            } catch (err) {
                console.error('Error fetching stage:', err);
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };

        fetchStageData();
    }, [stageId]);

    const handleEditClick = (type) => {
        setEditType(type);
        setEditDialogOpen(true);
    };

    const handleEditClose = () => {
        setEditDialogOpen(false);
        setEditError(null);
    };

    const handleSaveEdit = async () => {
        if (editType === 'name' && !newStageName.trim()) {
            setEditError('Stage name cannot be empty');
            return;
        }

        if (editType === 'description' && !newStageDescription.trim()) {
            setEditError('Stage description cannot be empty');
            return;
        }

        setEditLoading(true);
        setEditError(null);

        try {
            const businessId = localStorage.getItem('businessId')?.trim();
            const businessApiKey = localStorage.getItem('businessApiKey');

            const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.STAGES}/${stageId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${businessApiKey}`
                },
                body: JSON.stringify({
                    business_id: businessId,
                    stage_name: editType === 'name' ? newStageName.trim() : stageData.stage_name,
                    stage_description: editType === 'description' ? newStageDescription.trim() : stageData.stage_description,
                    stage_type: stageData.stage_type,
                    stage_selection_template_id: stageData.stage_selection_template_id,
                    data_extraction_template_id: stageData.data_extraction_template_id,
                    response_generation_template_id: stageData.response_generation_template_id,
                    agent_id: editType === 'agent' ? selectedAgentId : stageData.agent_id
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.message || `HTTP error ${response.status}`);
            }

            // Fetch the updated stage data
            const updatedResponse = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.STAGES}/${stageId}?business_id=${businessId}`, {
                headers: {
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${businessApiKey}`
                }
            });

            if (!updatedResponse.ok) {
                throw new Error('Failed to fetch updated stage data');
            }

            const updatedData = await updatedResponse.json();
            setStageData(updatedData);
            setEditDialogOpen(false);
        } catch (err) {
            console.error('Error updating stage:', err);
            setEditError(err.message);
        } finally {
            setEditLoading(false);
        }
    };

    const handleAgentChange = (event) => {
        setSelectedAgentId(event.target.value);
    };

    const TemplateField = ({ label, templateId }) => (
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
            <Typography variant="body1" component="span">
                <strong>{label}:</strong> {templateId || 'Not set'}
            </Typography>
        </Box>
    );

    if (loading) {
        return (
            <Box display="flex" justifyContent="center" p={3}>
                <CircularProgress />
            </Box>
        );
    }

    if (error) {
        return (
            <Alert severity="error" sx={{ mt: 2 }}>
                {error}
            </Alert>
        );
    }

    if (!stageData) {
        return (
            <Alert severity="info" sx={{ mt: 2 }}>
                No stage data available
            </Alert>
        );
    }

    return (
        <Paper sx={{ p: 3, mt: 2 }}>
            {/* Basic Information Section */}
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                <Typography variant="h6">
                    Basic Information
                </Typography>
            </Box>
            <Divider sx={{ mb: 2 }} />
            
            <Grid container spacing={2}>
                <Grid item xs={12}>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                        <Box>
                            <Typography variant="subtitle2" color="primary">Name</Typography>
                            <Typography>{stageData.stage_name}</Typography>
                        </Box>
                        <Button
                            startIcon={<EditIcon />}
                            variant="outlined"
                            onClick={() => handleEditClick('name')}
                        >
                            Edit Stage Name
                        </Button>
                    </Box>
                </Grid>

                <Grid item xs={12}>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                        <Box>
                            <Typography variant="subtitle2" color="primary">Description</Typography>
                            <Typography>{stageData.stage_description || 'No description'}</Typography>
                        </Box>
                        <Button
                            startIcon={<EditIcon />}
                            variant="outlined"
                            onClick={() => handleEditClick('description')}
                        >
                            Edit Description
                        </Button>
                    </Box>
                </Grid>

                <Grid item xs={12}>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                        <Box>
                            <Typography variant="subtitle2" color="primary">Agent</Typography>
                            <Typography>
                                {stageData.agent_id 
                                    ? agents.find(a => a.agent_id === stageData.agent_id)?.agent_name || 'Unknown Agent' 
                                    : 'No agent assigned'}
                            </Typography>
                        </Box>
                        <Button
                            startIcon={<EditIcon />}
                            variant="outlined"
                            onClick={() => handleEditClick('agent')}
                        >
                            Assign Agent
                        </Button>
                    </Box>
                </Grid>

                <Grid item xs={12}>
                    <Typography variant="subtitle2" color="primary">Type</Typography>
                    <Typography>{stageData.stage_type}</Typography>
                </Grid>

                <Grid item xs={12} sm={6}>
                    <Typography variant="subtitle2" color="primary">Stage ID</Typography>
                    <Typography component="code">{stageData.stage_id}</Typography>
                </Grid>

                <Grid item xs={12} sm={6}>
                    <Typography variant="subtitle2" color="primary">Business ID</Typography>
                    <Typography component="code">{stageData.business_id}</Typography>
                </Grid>

                {stageData.agent_id && (
                    <Grid item xs={12} sm={6}>
                        <Typography variant="subtitle2" color="primary">Agent ID</Typography>
                        <Typography component="code">{stageData.agent_id}</Typography>
                    </Grid>
                )}
            </Grid>

            {/* Template Configuration Section */}
            <Typography variant="h6" sx={{ mt: 4, mb: 2 }}>
                Template Configuration
            </Typography>
            <Divider sx={{ mb: 2 }} />
            
            <Grid container spacing={2}>
                <Grid item xs={12}>
                    <Typography variant="subtitle2" color="primary">Stage Selection Template</Typography>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                        <TemplateField 
                            label="Stage Selection Template"
                            templateId={stageData.stage_selection_template_id}
                        />
                        <Button
                            variant="outlined"
                            size="small"
                            onClick={() => navigate(`/template-editor/${stageData.stage_selection_template_id}`)}
                        >
                            Edit Template
                        </Button>
                    </Box>
                </Grid>

                <Grid item xs={12}>
                    <Typography variant="subtitle2" color="primary">Data Extraction Template</Typography>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                        <TemplateField 
                            label="Data Extraction Template"
                            templateId={stageData.data_extraction_template_id}
                        />
                        <Button
                            variant="outlined"
                            size="small"
                            onClick={() => navigate(`/template-editor/${stageData.data_extraction_template_id}`)}
                        >
                            Edit Template
                        </Button>
                    </Box>
                </Grid>

                <Grid item xs={12}>
                    <Typography variant="subtitle2" color="primary">Response Generation Template</Typography>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                        <TemplateField 
                            label="Response Generation Template"
                            templateId={stageData.response_generation_template_id}
                        />
                        <Button
                            variant="outlined"
                            size="small"
                            onClick={() => navigate(`/template-editor/${stageData.response_generation_template_id}`)}
                        >
                            Edit Template
                        </Button>
                    </Box>
                </Grid>
            </Grid>

            {/* Creation Date */}
            {stageData.created_at && (
                <Box mt={4}>
                    <Divider />
                    <Typography variant="caption" color="text.secondary" sx={{ mt: 2, display: 'block' }}>
                        Created: {new Date(stageData.created_at).toLocaleString()}
                    </Typography>
                </Box>
            )}

            {/* Edit Dialog */}
            <Dialog open={editDialogOpen} onClose={handleEditClose}>
                <DialogTitle>
                    {editType === 'name' ? 'Edit Stage Name' : 
                     editType === 'description' ? 'Edit Stage Description' : 
                     'Assign Agent'}
                </DialogTitle>
                <DialogContent>
                    {editType === 'name' ? (
                        <TextField
                            autoFocus
                            margin="dense"
                            label="Stage Name"
                            type="text"
                            fullWidth
                            value={newStageName}
                            onChange={(e) => setNewStageName(e.target.value)}
                            error={!!editError}
                            helperText={editError}
                        />
                    ) : editType === 'description' ? (
                        <TextField
                            autoFocus
                            margin="dense"
                            label="Stage Description"
                            type="text"
                            fullWidth
                            multiline
                            rows={4}
                            value={newStageDescription}
                            onChange={(e) => setNewStageDescription(e.target.value)}
                            error={!!editError}
                            helperText={editError}
                        />
                    ) : (
                        <FormControl fullWidth margin="dense">
                            <InputLabel id="agent-select-label">Select Agent</InputLabel>
                            <Select
                                labelId="agent-select-label"
                                id="agent-select"
                                value={selectedAgentId}
                                label="Select Agent"
                                onChange={handleAgentChange}
                            >
                                <MenuItem value="">
                                    <em>None</em>
                                </MenuItem>
                                {agents.map((agent) => (
                                    <MenuItem key={agent.agent_id} value={agent.agent_id}>
                                        {agent.agent_name}
                                    </MenuItem>
                                ))}
                            </Select>
                            {editError && (
                                <Typography color="error" variant="caption">
                                    {editError}
                                </Typography>
                            )}
                        </FormControl>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleEditClose}>Cancel</Button>
                    <Button 
                        onClick={handleSaveEdit} 
                        variant="contained" 
                        disabled={editLoading}
                    >
                        {editLoading ? <CircularProgress size={24} /> : 'Save'}
                    </Button>
                </DialogActions>
            </Dialog>
        </Paper>
    );
}

export default StageView; 

================================================================================
File: TemplateEditor.js
Path: .\front-end\src\components\TemplateEditor.js
Size: 26028
Modified: 2025-04-12T12:12:18.912484
Created: 2025-04-01T23:30:45.145332
Hash: 552a0f55fa3a20a76b85eb25e264b4775251c469a0226b6a9d52d7340cc387f1
Lines: 756
================================================================================
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  CircularProgress,
  Grid,
  Alert,
  Divider,
  Chip,
  IconButton,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Snackbar,
  ListSubheader
} from '@mui/material';
import SaveIcon from '@mui/icons-material/Save';
import PreviewIcon from '@mui/icons-material/Preview';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import VisibilityIcon from '@mui/icons-material/Visibility';
import { API_CONFIG } from '../config';
import { normalizeUUID } from '../hooks/useConfig';

const TemplateEditor = () => {
  const { templateId } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  
  // Parse query parameters
  const queryParams = new URLSearchParams(location.search);
  const queryBusinessId = queryParams.get('business_id');
  const queryAgentId = queryParams.get('agent_id');
  
  // Get stored business ID and API key from localStorage
  const storedBusinessId = localStorage.getItem('businessId');
  const storedApiKey = localStorage.getItem('businessApiKey');
  const storedAgentId = localStorage.getItem('agentId');
  
  // State for template data
  const [template, setTemplate] = useState({
    template_id: templateId === 'new' ? '' : templateId,
    template_name: '',
    content: '',
    system_prompt: '',
    template_type: 'stage_selection',
    variables: [],
    agent_id: ''
  });
  
  // State for UI
  const [businessId, setBusinessId] = useState(queryBusinessId || storedBusinessId || '');
  const [businessApiKey, setBusinessApiKey] = useState(storedApiKey || '');
  const [agentId, setAgentId] = useState(queryAgentId || storedAgentId || '');
  const [showBusinessIdInput, setShowBusinessIdInput] = useState(!businessId || !businessApiKey);
  const [showAgentIdInput, setShowAgentIdInput] = useState(!agentId);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [previewData, setPreviewData] = useState(null);
  const [showPreview, setShowPreview] = useState(false);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });
  
  // Add state for template types array
  const templateTypes = [
    { value: 'stage_selection', label: 'Stage Selection', group: 'Regular' },
    { value: 'data_extraction', label: 'Data Extraction', group: 'Regular' },
    { value: 'response_generation', label: 'Response Generation', group: 'Regular' },
    { value: 'default_stage_selection', label: 'Default Stage Selection', group: 'Default' },
    { value: 'default_data_extraction', label: 'Default Data Extraction', group: 'Default' },
    { value: 'default_response_generation', label: 'Default Response Generation', group: 'Default' }
  ];
  
  // Extract variables from template content
  const extractVariables = (text) => {
    if (!text) return [];
    const matches = text.match(/\{([^}]+)\}/g) || [];
    return matches.map(match => match.slice(1, -1));
  };
  
  // Update variables whenever template content changes
  useEffect(() => {
    const variables = extractVariables(template.content);
    setTemplate(prev => ({
      ...prev,
      variables
    }));
  }, [template.content]);
  
  // Update template's agent_id when agentId changes
  useEffect(() => {
    if (agentId) {
      setTemplate(prev => ({
        ...prev,
        agent_id: agentId
      }));
    }
  }, [agentId]);
  
  // Fetch template data if editing an existing template
  useEffect(() => {
    const fetchTemplateData = async () => {
      // Skip fetching for new templates
      if (templateId === 'new') return;
      
      // Skip fetching if templateId is invalid/undefined
      if (!templateId || templateId === 'undefined') {
        console.error('Invalid template ID:', templateId);
        showSnackbar('Invalid template ID', 'error');
        // Redirect to template creation
        navigate('/template-editor/new');
        return;
      }
      
      if (!businessId) {
        showSnackbar('Business ID is required to fetch template', 'error');
        setShowBusinessIdInput(true);
        return;
      }
      
      if (!businessApiKey) {
        showSnackbar('Business API Key is required', 'error');
        setShowBusinessIdInput(true);
        return;
      }
      
      setIsLoading(true);
      try {
        console.log(`Fetching template with ID: ${templateId}`);
        const response = await fetch(`/templates/${templateId}?business_id=${businessId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${businessApiKey}`
          },
          credentials: 'include'
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || errorData.message || 'Failed to fetch template');
        }
        
        const data = await response.json();
        console.log('Fetched template:', data);
        
        // Don't modify the template_type, preserve its original value
        setTemplate({
          template_id: data.template_id,
          template_name: data.template_name || '',
          content: data.content || '',
          system_prompt: data.system_prompt || '',
          template_type: data.template_type || 'stage_selection',
          variables: extractVariables(data.content),
          agent_id: data.agent_id || ''
        });
      } catch (err) {
        console.error('Error fetching template:', err);
        showSnackbar(err.message, 'error');
        // Redirect to template list on error
        navigate('/templates');
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchTemplateData();
  }, [templateId, businessId, businessApiKey, navigate]);
  
  // Validate credentials
  const validateCredentials = async () => {
    if (!businessId || !businessApiKey) {
      setSnackbar({
        open: true,
        message: 'Business ID and API Key are required',
        severity: 'error'
      });
      setShowBusinessIdInput(true);
      return false;
    }
    
    try {
      // Use the correct endpoint and method
      const response = await fetch(`/businesses/validate-credentials?business_id=${businessId}&api_key=${businessApiKey}`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Authorization': `Bearer ${businessApiKey}`
        },
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error('Invalid business ID or API key');
      }
      
      const data = await response.json();
      if (!data.valid) {
        throw new Error(data.message || 'Credential validation failed');
      }
      
      return true;
    } catch (err) {
      console.error('Credential validation error:', err);
      setSnackbar({
        open: true,
        message: 'Failed to validate credentials: ' + err.message,
        severity: 'error'
      });
      setShowBusinessIdInput(true);
      return false;
    }
  };
  
  // Save credentials
  const saveCredentials = async () => {
    if (!businessId || !businessApiKey) {
      showSnackbar('Please enter both Business ID and API Key', 'error');
      return;
    }
    
    const isValid = await validateCredentials();
    if (isValid) {
      // Save to both localStorage and cookies
      localStorage.setItem('businessId', businessId);
      localStorage.setItem('businessApiKey', businessApiKey);
      document.cookie = `businessId=${businessId}; path=/; max-age=86400`;
      document.cookie = `businessApiKey=${businessApiKey}; path=/; max-age=86400`;
      
      setShowBusinessIdInput(false);
      showSnackbar('Business credentials validated and saved', 'success');
    }
  };
  
  // Handle template preview
  const handlePreview = async () => {
    if (!template.content.trim()) {
      showSnackbar('Template content is empty', 'error');
      return;
    }
    
    setIsLoading(true);
    try {
      // Prepare preview request
      const previewRequest = {
        template_type: template.template_type,
        template_text: template.content,
        business_id: businessId,
        agent_id: agentId,
        context: {
          conversation_history: [
            { role: "user", content: "I'm interested in your products" },
            { role: "assistant", content: "I'd be happy to tell you about our products. What type are you interested in?" }
          ],
          extracted_data: {
            customer_name: "John Doe",
            product_interest: "shoes",
            budget: "$100"
          }
        }
      };
      
      let previewSuccess = false;
      let errorMessage = '';
      
      // Try multiple possible endpoints (for compatibility)
      const endpoints = [
        '/templates/preview',
        '/templates/render',
        '/render_template',
        '/api/templates/preview'
      ];
      
      let response = null;
      for (const endpoint of endpoints) {
        try {
          console.log(`Trying to preview template with endpoint: ${endpoint}`);
          
          response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'Authorization': `Bearer ${businessApiKey}`
            },
            credentials: 'include',
            body: JSON.stringify(previewRequest),
          });
          
          if (response.ok) {
            const data = await response.json();
            console.log('Preview response:', data);
            setPreviewData(data);
            setShowPreview(true);
            previewSuccess = true;
            break;
          } else {
            const errData = await response.json().catch(() => ({}));
            errorMessage = errData.message || errData.error || `Failed with status ${response.status}`;
            console.warn(`Endpoint ${endpoint} failed: ${errorMessage}`);
          }
        } catch (endpointErr) {
          console.warn(`Endpoint ${endpoint} failed:`, endpointErr);
          errorMessage = endpointErr.message;
        }
      }
      
      // If no endpoint worked, use fallback preview
      if (!previewSuccess) {
        console.log('All endpoint attempts failed, using local preview');
        
        // Simple variable replacement for demonstration
        let previewText = template.content;
        
        // Replace variables with sample values
        template.variables.forEach(variable => {
          const sampleValue = `[Sample ${variable}]`;
          previewText = previewText.replace(new RegExp(`{${variable}}`, 'g'), sampleValue);
        });
        
        setPreviewData({ 
          rendered_text: previewText,
          message: "Using client-side preview (API endpoints not available)",
          is_fallback: true
        });
        setShowPreview(true);
        
        // Show notification
        showSnackbar(`Using fallback preview. Server error: ${errorMessage}`, 'warning');
      }
    } catch (err) {
      console.error('Error generating preview:', err);
      showSnackbar(`Failed to generate preview: ${err.message}`, 'error');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Handle template save
  const handleSaveTemplate = async () => {
    if (!template.template_name || !template.content || !template.template_type) {
      showSnackbar('Template name, content, and type are required', 'error');
      return;
    }
    
    // Validate credentials if needed
    if (!businessId || !businessApiKey) {
      showSnackbar('Business ID and API Key are required', 'error');
      setShowBusinessIdInput(true);
      return;
    }
    
    setIsLoading(true);
    try {
      // Check if we're creating a new template or editing an existing one
      const isNewTemplate = templateId === 'new' || !template.template_id;
      
      // Use the API_CONFIG for consistent endpoints
      const endpoint = isNewTemplate 
        ? API_CONFIG.ENDPOINTS.TEMPLATES 
        : `${API_CONFIG.ENDPOINTS.TEMPLATES}/${template.template_id}`;
      
      const url = `${API_CONFIG.BASE_URL}${endpoint}`;
      
      console.log(`Saving template to URL: ${url}, method: ${isNewTemplate ? 'POST' : 'PUT'}`);
      
      const method = isNewTemplate ? 'POST' : 'PUT';
      
      // Prepare the request payload with the correct field names
      const payload = {
        template_name: template.template_name,
        content: template.content,
        system_prompt: template.system_prompt || '',
        template_type: template.template_type,
        business_id: normalizeUUID(businessId),
      };
      
      // Only include template_id for existing templates
      if (!isNewTemplate && template.template_id) {
        payload.template_id = template.template_id;
      }
      
      // Add agent_id if available
      if (agentId) {
        payload.agent_id = normalizeUUID(agentId);
      }
      
      console.log('Payload with normalized IDs:', payload);
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': `Bearer ${businessApiKey}`
        },
        credentials: 'include',
        body: JSON.stringify(payload)
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || errorData.message || `Failed to ${isNewTemplate ? 'create' : 'update'} template`);
      }
      
      const data = await response.json();
      showSnackbar(`Template ${isNewTemplate ? 'created' : 'updated'} successfully`, 'success');
      
      // If creating a new template, update the URL to edit mode
      if (isNewTemplate && data.template_id) {
        // Set a flag in localStorage to trigger a refresh on the templates list
        localStorage.setItem('template_updated', 'true');
        
        // Update the browser URL without navigating away
        window.history.replaceState(
          null, 
          '', 
          `/template-editor/${data.template_id}?business_id=${businessId}${agentId ? `&agent_id=${agentId}` : ''}`
        );
        
        // Update the template with the new ID
        setTemplate(prev => ({
          ...prev,
          template_id: data.template_id
        }));
        
        // Update the templateId state
        setTemplateId(data.template_id);
      }
    } catch (err) {
      console.error('Error saving template:', err);
      showSnackbar(err.message, 'error');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Navigate back to templates list
  const handleCancel = () => {
    navigate('/templates');
  };
  
  // Handle template type change
  const handleTemplateTypeChange = (e) => {
    const newType = e.target.value;
    console.log('Template type changed to:', newType);
    setTemplate(prev => {
      const updated = { 
        ...prev, 
        template_type: newType
      };
      console.log('Updated template state:', updated);
      return updated;
    });
  };
  
  // Snackbar functions
  const showSnackbar = (message, severity = 'success') => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };
  
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({
      ...prev,
      open: false
    }));
  };
  
  return (
    <Paper sx={{ p: 3, mb: 3, maxWidth: 1200, mx: 'auto' }}>
      {/* Back button and title */}
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
        <IconButton onClick={handleCancel} sx={{ mr: 1 }}>
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h5">
          {template.template_id && template.template_id !== 'new' ? 'Edit Template' : 'Create New Template'}
        </Typography>
        <Box sx={{ flexGrow: 1 }} />
        <Button
          variant="contained"
          color="primary"
          onClick={handleSaveTemplate}
          disabled={isLoading || !template.template_name.trim() || !template.content.trim()}
          startIcon={isLoading ? <CircularProgress size={24} /> : <SaveIcon />}
        >
          Save Template
        </Button>
      </Box>
      
      {/* Business ID input section */}
      {(showBusinessIdInput || !businessId || !businessApiKey) && (
        <Box sx={{ mb: 3, p: 2, border: '1px dashed', borderColor: 'warning.main', borderRadius: 1 }}>
          <Typography variant="subtitle1" color="warning.main" gutterBottom>
            Business Credentials Required
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={12} md={5}>
              <TextField
                fullWidth
                label="Business ID"
                value={businessId}
                onChange={(e) => setBusinessId(e.target.value)}
                placeholder="Enter your business ID"
                helperText="Required for saving templates"
                required
              />
            </Grid>
            <Grid item xs={12} md={5}>
              <TextField
                fullWidth
                label="Business API Key"
                value={businessApiKey}
                onChange={(e) => setBusinessApiKey(e.target.value)}
                placeholder="Enter your business API key"
                helperText="Required for authentication"
                type="password"
                required
              />
            </Grid>
            <Grid item xs={12} md={2}>
              <Button 
                variant="contained" 
                color="primary"
                onClick={saveCredentials}
                fullWidth
                sx={{ height: '56px' }}
              >
                Validate & Save
              </Button>
            </Grid>
          </Grid>
        </Box>
      )}
      
      {/* Agent ID input section */}
      {(showAgentIdInput || !agentId) && (
        <Box sx={{ mb: 3, p: 2, border: '1px dashed', borderColor: 'warning.main', borderRadius: 1 }}>
          <Typography variant="subtitle1" color="warning.main" gutterBottom>
            Agent ID Required
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={12} md={5}>
              <TextField
                fullWidth
                label="Agent ID"
                value={agentId}
                onChange={(e) => setAgentId(e.target.value)}
                placeholder="Enter your agent ID"
                helperText="Required for saving templates"
                required
              />
            </Grid>
          </Grid>
        </Box>
      )}
      
      {/* Template information section */}
      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <TextField
            fullWidth
            label="Template Name"
            value={template.template_name}
            onChange={(e) => setTemplate(prev => ({ ...prev, template_name: e.target.value }))}
            required
            error={!template.template_name.trim()}
            helperText={!template.template_name.trim() ? "Template name is required" : ""}
            sx={{ mb: 2 }}
          />
          
          <FormControl fullWidth sx={{ mb: 2 }}>
            <InputLabel id="template-type-label">Template Type</InputLabel>
            <Select
              labelId="template-type-label"
              value={template.template_type}
              label="Template Type"
              onChange={handleTemplateTypeChange}
            >
              <ListSubheader>Regular Templates</ListSubheader>
              {templateTypes
                .filter(type => type.group === 'Regular')
                .map((type) => (
                  <MenuItem key={type.value} value={type.value}>
                    {type.label}
                  </MenuItem>
                ))
              }
              <ListSubheader>Default Templates</ListSubheader>
              {templateTypes
                .filter(type => type.group === 'Default')
                .map((type) => (
                  <MenuItem key={type.value} value={type.value}>
                    {type.label}
                  </MenuItem>
                ))
              }
            </Select>
          </FormControl>
          
          <TextField
            fullWidth
            label="Template Description"
            value={template.template_description}
            onChange={(e) => setTemplate(prev => ({ ...prev, template_description: e.target.value }))}
            multiline
            rows={2}
            sx={{ mb: 2 }}
          />
          
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <Typography variant="subtitle1" sx={{ mr: 2 }}>
              Detected Variables:
            </Typography>
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
              {template.variables.length > 0 ? (
                template.variables.map((variable, index) => (
                  <Chip 
                    key={index} 
                    label={variable} 
                    color="primary" 
                    variant="outlined" 
                  />
                ))
              ) : (
                <Typography variant="body2" color="text.secondary">
                  No variables detected. Use {"{variable_name}"} syntax.
                </Typography>
              )}
            </Box>
          </Box>
          
          <Button
            variant="outlined"
            color="primary"
            onClick={handlePreview}
            disabled={!template.content.trim()}
            startIcon={<VisibilityIcon />}
            sx={{ mt: 2 }}
          >
            Preview Template
          </Button>
        </Grid>
        
        <Grid item xs={12} md={6}>
          <Typography variant="subtitle1" gutterBottom>
            Template Content
            <Tooltip title="Use {variable_name} syntax to create variables in your template">
              <IconButton size="small">
                <HelpOutlineIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          </Typography>
          <TextField
            fullWidth
            multiline
            rows={10}
            value={template.content}
            onChange={(e) => setTemplate({ ...template, content: e.target.value })}
            placeholder="Enter your template content here with variables in {curly_braces}..."
            sx={{ 
              mb: 2, 
              fontFamily: 'monospace',
              '& .MuiInputBase-input': {
                fontFamily: 'monospace',
              }
            }}
          />
          
          <Grid item xs={12}>
            <TextField
              label="System Prompt (Optional)"
              value={template.system_prompt}
              onChange={(e) => setTemplate({ ...template, system_prompt: e.target.value })}
              fullWidth
              multiline
              rows={4}
              margin="normal"
              variant="outlined"
              placeholder="Enter optional system prompt for the model..."
            />
          </Grid>
        </Grid>
      </Grid>
      
      {/* Preview Dialog */}
      <Dialog 
        open={showPreview} 
        onClose={() => setShowPreview(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Template Preview</DialogTitle>
        <DialogContent>
          <Typography variant="subtitle1" gutterBottom>
            Template: {template.template_name}
          </Typography>
          <Typography variant="subtitle2" color="text.secondary" gutterBottom>
            Type: {template.template_type}
          </Typography>
          <Divider sx={{ my: 2 }} />
          <Box sx={{ 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            border: '1px solid',
            borderColor: 'divider',
            maxHeight: '500px',
            overflow: 'auto',
            fontFamily: 'monospace',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-word'
          }}>
            {previewData?.rendered_text || previewData?.content || 'No preview data available'}
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowPreview(false)}>Close</Button>
        </DialogActions>
      </Dialog>
      
      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
      >
        <Alert onClose={handleCloseSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Paper>
  );
};

export default TemplateEditor; 

================================================================================
File: TemplateManagement.js
Path: .\front-end\src\components\TemplateManagement.js
Size: 43885
Modified: 2025-04-11T21:54:31.057801
Created: 2025-03-28T21:48:41.261517
Hash: 01540b4092654c09d9296bae6335fec85ed29fe76a4c74100d2904c60c01ddb4
Lines: 904
================================================================================
import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import {
    TextField, Button, Typography, Card, CardContent, Box, TextareaAutosize,
    Select, MenuItem, InputLabel, FormControl, Grid, Paper, Divider, Tab, Tabs, Alert, List, ListItem, ListItemText, ListItemSecondaryAction, IconButton, Chip, Dialog, DialogTitle, DialogContent, DialogActions, CircularProgress, Snackbar, Container, Tooltip, ListSubheader
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import SaveIcon from '@mui/icons-material/Save';
import RefreshIcon from '@mui/icons-material/Refresh';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import TemplateSection from './TemplateSection';
import AddIcon from '@mui/icons-material/Add';
import FilterListIcon from '@mui/icons-material/FilterList';
import StarIcon from '@mui/icons-material/Star';
import { normalizeUUID } from '../hooks/useConfig';
import { createTemplate, updateTemplate, deleteTemplate, fetchTemplates as fetchTemplatesService, duplicateTemplate } from '../services/templateService';

function TemplateManagement({ templateID, setTemplateID, availableVariable = [], setAvailableVariable, selectedVariable, setSelectedVariable, handleTemplateSelection, handleVariableSelection, addVariableToTemplate, templateName, setTemplateName, templateContent, setTemplateContent, templateSystemPrompt, setTemplateSystemPrompt, templateOutput, createTemplate, fetchTemplates, handleSnackbarOpen, handleSaveDefaultTemplate, apiKey, setTemplateOutput }) {
    const navigate = useNavigate();
    const location = useLocation();
    const [templates, setTemplates] = useState([]);
    const [selectedTemplate, setSelectedTemplate] = useState(null);
    const [templateType, setTemplateType] = useState('');
    const [errorMessage, setErrorMessage] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const [activeTab, setActiveTab] = useState(0);
    const [isLoading, setIsLoading] = useState(false);
    const [editDialogOpen, setEditDialogOpen] = useState(false);
    const [editingTemplate, setEditingTemplate] = useState({
        template_id: '',
        template_name: '',
        content: '',
        system_prompt: '',
        template_type: '',
        variables: []
    });
    const [filterType, setFilterType] = useState('all');
    const [showBusinessIdInput, setShowBusinessIdInput] = useState(!apiKey || !templateID);
    const [businessId, setBusinessId] = useState(templateID || '');
    const [businessApiKey, setBusinessApiKey] = useState(apiKey || '');
    const [agentId, setAgentId] = useState('');
    const [filteredTemplates, setFilteredTemplates] = useState([]);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success'
    });
    const [showAgentIdInput, setShowAgentIdInput] = useState(!agentId);

    // Define template types array for dropdowns and filtering
    const templateTypes = [
        { value: 'stage_selection', label: 'Stage Selection', group: 'Regular' },
        { value: 'data_extraction', label: 'Data Extraction', group: 'Regular' },
        { value: 'response_generation', label: 'Response Generation', group: 'Regular' },
        { value: 'default_stage_selection', label: 'Default Stage Selection', group: 'Default' },
        { value: 'default_data_extraction', label: 'Default Data Extraction', group: 'Default' },
        { value: 'default_response_generation', label: 'Default Response Generation', group: 'Default' }
    ];

    // Parse query parameters if any
    const queryParams = new URLSearchParams(window.location.search);
    const queryBusinessId = queryParams.get('business_id');
    const queryAgentId = queryParams.get('agent_id');
    
    // Get stored credentials from localStorage
    const storedBusinessId = localStorage.getItem('businessId');
    const storedApiKey = localStorage.getItem('businessApiKey');
    const storedAgentId = localStorage.getItem('agentId');
    
    // Update state with query params and localStorage values
    useEffect(() => {
        // Update businessId if query param or localStorage has a value
        if (queryBusinessId || storedBusinessId) {
            setBusinessId(queryBusinessId || storedBusinessId);
        }
        
        // Update businessApiKey if localStorage has a value
        if (storedApiKey) {
            setBusinessApiKey(storedApiKey);
        }
        
        // Update agentId if query param or localStorage has a value
        if (queryAgentId || storedAgentId) {
            setAgentId(queryAgentId || storedAgentId);
        }
        
        // Update visibility of input fields
        setShowBusinessIdInput(!businessId || !businessApiKey);
        setShowAgentIdInput(!agentId);
    }, [queryBusinessId, storedBusinessId, storedApiKey, queryAgentId, storedAgentId]);
    
    // Initialize filteredTemplates when templates change
    useEffect(() => {
        setFilteredTemplates(templates);
    }, [templates]);
    
    // Effect to fetch templates on mount
    useEffect(() => {
        if (businessId && agentId) {
            console.log("TemplateManagement.js - Fetching templates with:", { businessId, agentId });
            if (typeof fetchTemplates === 'function') {
                fetchTemplates();
            } else {
                // If fetchTemplates is not a prop, use the internal implementation
                fetchTemplatesInternal();
            }
        }
    }, [businessId, agentId, fetchTemplates]);
    
    // Internal implementation of fetchTemplates
    const fetchTemplatesInternal = async () => {
        if (!businessId) {
            showSnackbar('Business ID is required to fetch templates', 'error');
            setShowBusinessIdInput(true);
            setIsLoading(false);
            return;
        }
        
        if (!agentId) {
            showSnackbar('Agent ID is required to fetch templates', 'error');
            setShowAgentIdInput(true);
            setIsLoading(false);
            return;
        }
        
        if (!businessApiKey) {
            showSnackbar('Business API Key is required to fetch templates', 'error');
            setShowBusinessIdInput(true);
            setIsLoading(false);
            return;
        }
        
        setIsLoading(true);
        try {
            // Use the template service instead of direct fetch
            const data = await fetchTemplatesService(businessId, agentId);
            console.log('Fetched templates (raw):', data);
            
            // Normalize the templates data to ensure all needed fields exist
            const normalizedTemplates = Array.isArray(data) ? data.map(template => ({
                template_id: template.template_id || template.id || `temp-${Math.random().toString(36).substring(2, 9)}`,
                template_name: template.template_name || 'Unnamed Template',
                content: template.content || '',
                system_prompt: template.system_prompt || '',
                template_type: template.template_type || 'Unknown Type',
                variables: extractVariablesFromContent(template.content || '')
            })) : [];
            
            console.log('Normalized templates:', normalizedTemplates);
            
            setTemplates(normalizedTemplates);
            setFilteredTemplates(normalizedTemplates);
            
            // Show message about number of templates loaded
            showSnackbar(`${normalizedTemplates.length} templates loaded successfully`, 'success');
        } catch (err) {
            console.error('Error fetching templates:', err);
            showSnackbar(err.message, 'error');
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        // TODO: Implement API endpoint to retrieve available variables
        const mockVariables = ['variable1', 'variable2', 'variable3'];
        if (typeof setAvailableVariable === 'function') {
            setAvailableVariable(mockVariables);
        }
    }, [setAvailableVariable]);

    const handleCreateTemplate = async () => {
        try {
            if (!templateName || !templateContent || !templateType) {
                setErrorMessage('Template name, content, and type are required');
                return;
            }
            
            // Use the template service instead of direct fetch
            const templateData = {
                template_name: templateName,
                content: templateContent,
                system_prompt: templateSystemPrompt || '',
                template_type: templateType,
                business_id: businessId,
                agent_id: agentId
            };
            
            await createTemplate(templateData);
            
            // Reset form
            setTemplateName('');
            setTemplateContent('');
            setTemplateType('');
            
            // Refresh templates
            fetchTemplates();
            
            setSuccessMessage('Template created successfully');
            
            // Clear success message after 3 seconds
            setTimeout(() => {
                setSuccessMessage('');
            }, 3000);
        } catch (error) {
            setErrorMessage(error.message);
        }
    };

    const handleUpdateTemplate = async () => {
        try {
            if (!editingTemplate) return;
            
            // Use the template service instead of direct fetch
            const templateData = {
                template_name: editingTemplate.template_name,
                content: editingTemplate.content,
                system_prompt: editingTemplate.system_prompt || '',
                template_type: editingTemplate.template_type,
                business_id: businessId,
                agent_id: agentId
            };
            
            await updateTemplate(editingTemplate.template_id, templateData);
            
            // Close dialog and refresh
            setEditDialogOpen(false);
            fetchTemplates();
            
            // Show success message
            showSnackbar('Template updated successfully', 'success');
        } catch (error) {
            console.error('Error updating template:', error);
            showSnackbar(`Failed to update template: ${error.message}`, 'error');
        }
    };

    const handleDeleteTemplate = async (templateId) => {
        if (!window.confirm('Are you sure you want to delete this template?')) {
            return;
        }
        
        try {
            // Use the template service instead of direct fetch
            await deleteTemplate(templateId, businessId);
            
            // Refresh templates
            fetchTemplates();
            
            // Show success message
            showSnackbar('Template deleted successfully', 'success');
        } catch (error) {
            console.error('Error deleting template:', error);
            showSnackbar(`Failed to delete template: ${error.message}`, 'error');
        }
    };

    const handleDuplicateTemplate = async (template) => {
        try {
            setIsLoading(true);
            
            // Use the template service instead of direct fetch
            const templateData = {
                template_name: template.template_name,
                content: template.content,
                system_prompt: template.system_prompt || '',
                template_type: template.template_type,
                business_id: businessId,
                agent_id: agentId
            };
            
            await duplicateTemplate(templateData);
            
            // Refresh templates
            fetchTemplates();
            
            // Show success message
            showSnackbar(`Template "${template.template_name} (Copy)" created successfully`, 'success');
        } catch (error) {
            console.error('Error duplicating template:', error);
            showSnackbar(`Failed to duplicate template: ${error.message}`, 'error');
        } finally {
            setIsLoading(false);
        }
    };

    const handleEditTemplate = (template) => {
        setEditingTemplate(template);
        setEditDialogOpen(true);
    };

    const handleAddVariable = (variable) => {
        setTemplateContent((prev) => `${prev} {${variable}}`);
    };

    const handleTabChange = (event, newValue) => {
        setActiveTab(newValue);
    };

    const getFilteredTemplates = () => {
        // If searching by text instead of filtering by type
        if (typeof filterType === 'string' && filterType.length > 0 && !templateTypes.some(t => t.value === filterType)) {
            // This is a text search, not a type filter
            const searchTerm = filterType.toLowerCase();
            return templates.filter(template => 
                (template.template_name && template.template_name.toLowerCase().includes(searchTerm)) ||
                (template.template_description && template.template_description.toLowerCase().includes(searchTerm)) ||
                (template.template_id && template.template_id.toLowerCase().includes(searchTerm)) ||
                (template.template_type && template.template_type.toLowerCase().includes(searchTerm))
            );
        }
        
        // Regular type filtering
        if (filterType === 'all') {
            return templates;
        }
        
        return templates.filter(template => {
            const type = template.template_type;
            // Handle the case where type might be undefined or not a string
            if (!type || typeof type !== 'string') return false;
            return type === filterType;
        });
    };

    const isDefaultTemplate = (type) => {
        return type && typeof type === 'string' && type.startsWith('default_');
    };

    const getTemplateTypeLabel = (type) => {
        if (!type) return 'Unknown Type';
        const found = templateTypes.find(t => t.value === type);
        return found ? found.label : type;
    };

    const handleNavigateToHome = () => {
        navigate('/business');
    };

    const validateCredentials = async () => {
        if (!businessId || !businessApiKey) {
            showSnackbar('Business ID and API Key are required', 'error');
            setShowBusinessIdInput(true);
            return false;
        }
        
        try {
            // Use the correct endpoint and method
            const response = await fetch(`/businesses/validate-credentials?business_id=${businessId}&api_key=${businessApiKey}`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${businessApiKey}`
                },
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('Invalid business ID or API key');
            }
            
            const data = await response.json();
            if (!data.valid) {
                throw new Error(data.message || 'Credential validation failed');
            }
            
            return true;
        } catch (err) {
            console.error('Credential validation error:', err);
            showSnackbar('Failed to validate credentials: ' + err.message, 'error');
            setShowBusinessIdInput(true);
            return false;
        }
    };

    const saveCredentials = async () => {
        if (!businessId || !businessApiKey) {
            showSnackbar('Please enter both Business ID and API Key', 'error');
            return;
        }
        
        const isValid = await validateCredentials();
        if (isValid) {
            // Save to both localStorage and cookies
            localStorage.setItem('businessId', businessId);
            localStorage.setItem('businessApiKey', businessApiKey);
            document.cookie = `businessId=${businessId}; path=/; max-age=86400`;
            document.cookie = `businessApiKey=${businessApiKey}; path=/; max-age=86400`;
            
            setShowBusinessIdInput(false);
            showSnackbar('Business credentials validated and saved', 'success');
            
            // Refresh templates
            fetchTemplatesInternal();
        }
    };

    const showSnackbar = (message, severity = 'success') => {
        setSnackbar({
            open: true,
            message,
            severity
        });
    };

    const handleCloseSnackbar = () => {
        setSnackbar(prev => ({
            ...prev,
            open: false
        }));
    };

    const handleCreateNewTemplate = () => {
        let url = `/template-editor/new?business_id=${businessId}`;
        if (agentId) {
            url += `&agent_id=${agentId}`;
        }
        navigate(url);
    };
    
    const handleEditExistingTemplate = (templateId) => {
        // Check for invalid template ID
        if (!templateId || templateId === 'undefined') {
            console.error('Invalid template ID:', templateId);
            showSnackbar('Cannot edit template: Invalid template ID', 'error');
            return;
        }
        
        let url = `/template-editor/${templateId}?business_id=${businessId}`;
        if (agentId) {
            url += `&agent_id=${agentId}`;
        }
        console.log(`Navigating to edit template: ${url}`);
        navigate(url);
    };

    // Effect to check if we need to refresh templates (coming from template editor)
    useEffect(() => {
        const templateUpdated = localStorage.getItem('template_updated');
        const refreshParam = queryParams.get('refresh');
        
        if (templateUpdated === 'true' || refreshParam) {
            // Clear the flag
            localStorage.removeItem('template_updated');
            
            // If we have both business ID and agent ID, fetch templates
            if (businessId && agentId && businessApiKey) {
                console.log("Template was just updated, refreshing templates list");
                setTimeout(() => {
                    fetchTemplatesInternal();
                }, 500); // Small delay to ensure backend has processed
            }
        }
    }, [location, businessId, agentId, businessApiKey]);

    // Effect to extract variables from template text
    useEffect(() => {
        if (editingTemplate.content) {
            const matches = editingTemplate.content.match(/\{([^}]+)\}/g) || [];
            const extractedVariables = matches.map(match => match.substring(1, match.length - 1));
            setEditingTemplate(prev => ({
                ...prev,
                variables: Array.from(new Set(extractedVariables))
            }));
        }
    }, [editingTemplate.content]);

    // Helper to extract variables from content
    const extractVariablesFromContent = (content) => {
        if (!content) return [];
        const matches = content.match(/\{([^}]+)\}/g) || [];
        return matches.map(match => match.slice(1, -1));
    };

    // Handle template selection for variable insertion
    const handleChooseTemplate = (template) => {
        if (setTemplateName && typeof setTemplateName === 'function') {
            setTemplateName(template.template_name);
        }
        if (setTemplateContent && typeof setTemplateContent === 'function') {
            setTemplateContent(template.content);
        }
        if (setTemplateSystemPrompt && typeof setTemplateSystemPrompt === 'function') {
            setTemplateSystemPrompt(template.system_prompt || '');
        }
        if (templateID !== undefined && setTemplateID && typeof setTemplateID === 'function') {
            setTemplateID(template.template_id);
        }
        // Fire template selection handler if provided
        if (handleTemplateSelection && typeof handleTemplateSelection === 'function') {
            handleTemplateSelection(template);
        }
        showSnackbar(`Template "${template.template_name}" selected`, 'success');
    };

    // Function to open the Edit Dialog for template editing
    const openEditDialog = (template) => {
        setEditingTemplate({
            template_id: template.template_id,
            template_name: template.template_name,
            content: template.content,
            system_prompt: template.system_prompt || '',
            template_type: template.template_type,
            variables: extractVariablesFromContent(template.content)
        });
        setEditDialogOpen(true);
    };

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper sx={{ p: 3, mb: 4 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                    <IconButton onClick={handleNavigateToHome} sx={{ mr: 1 }}>
                        <ArrowBackIcon />
                    </IconButton>
                    <Typography variant="h5" component="h1" gutterBottom sx={{ flexGrow: 1 }}>
                        Template Management
                    </Typography>
                    <Button
                        variant="outlined"
                        color="primary"
                        onClick={() => fetchTemplatesInternal()}
                        startIcon={<RefreshIcon />}
                        sx={{ mr: 2 }}
                    >
                        Refresh Templates
                    </Button>
                    <Button
                        variant="contained"
                        color="primary"
                        onClick={handleCreateNewTemplate}
                        startIcon={<AddIcon />}
                    >
                        Create Template
                    </Button>
                </Box>
                
                <Divider sx={{ mb: 3 }} />
                
                {/* Business ID input section */}
                {(showBusinessIdInput || !businessId || !businessApiKey) && (
                    <Box sx={{ mb: 3, p: 2, border: '1px dashed', borderColor: 'warning.main', borderRadius: 1 }}>
                        <Typography variant="subtitle1" color="warning.main" gutterBottom>
                            Business Credentials Required
                        </Typography>
                        <Grid container spacing={2}>
                            <Grid item xs={12} md={5}>
                                <TextField
                                    fullWidth
                                    label="Business ID"
                                    value={businessId}
                                    onChange={(e) => setBusinessId(e.target.value)}
                                    placeholder="Enter your business ID"
                                    helperText="Required for managing templates"
                                    required
                                />
                            </Grid>
                            <Grid item xs={12} md={5}>
                                <TextField
                                    fullWidth
                                    label="Business API Key"
                                    value={businessApiKey}
                                    onChange={(e) => setBusinessApiKey(e.target.value)}
                                    placeholder="Enter your business API key"
                                    helperText="Required for authentication"
                                    type="password"
                                    required
                                />
                            </Grid>
                            <Grid item xs={12} md={2}>
                                <Button 
                                    variant="contained" 
                                    color="primary"
                                    onClick={saveCredentials}
                                    fullWidth
                                    sx={{ height: '56px' }}
                                >
                                    Validate & Save
                                </Button>
                            </Grid>
                        </Grid>
                    </Box>
                )}
                
                {/* Agent ID input section */}
                {(showAgentIdInput || !agentId) && (
                    <Box sx={{ mb: 3, p: 2, border: '1px dashed', borderColor: 'warning.main', borderRadius: 1 }}>
                        <Typography variant="subtitle1" color="warning.main" gutterBottom>
                            Agent ID Required
                        </Typography>
                        <Grid container spacing={2}>
                            <Grid item xs={12} md={9}>
                                <TextField
                                    fullWidth
                                    label="Agent ID"
                                    value={agentId}
                                    onChange={(e) => setAgentId(e.target.value)}
                                    placeholder="Enter an agent ID"
                                    helperText="Required for managing templates"
                                    required
                                />
                            </Grid>
                            <Grid item xs={12} md={3}>
                                <Button 
                                    variant="contained" 
                                    color="primary"
                                    onClick={() => {
                                        if (agentId) {
                                            // Save to localStorage
                                            localStorage.setItem('agentId', agentId);
                                            setShowAgentIdInput(false);
                                            showSnackbar('Agent ID saved', 'success');
                                            // Fetch templates for this agent
                                            fetchTemplatesInternal();
                                        } else {
                                            showSnackbar('Please enter an Agent ID', 'error');
                                        }
                                    }}
                                    fullWidth
                                    sx={{ height: '56px' }}
                                >
                                    Save & Use
                                </Button>
                            </Grid>
                            <Grid item xs={12} mt={2}>
                                <Typography variant="body2" color="text.secondary">
                                    After saving or changing the agent ID, click the button below to load templates:
                                </Typography>
                                <Button 
                                    variant="outlined" 
                                    fullWidth
                                    onClick={fetchTemplatesInternal}
                                    startIcon={<RefreshIcon />}
                                    sx={{ mt: 1 }}
                                >
                                    Load Templates for this Agent
                                </Button>
                            </Grid>
                        </Grid>
                    </Box>
                )}
                
                {/* Template filter */}
                <Box sx={{ mb: 3 }}>
                    <Grid container spacing={2} alignItems="center">
                        <Grid item xs={12} md={4}>
                            <TextField
                                fullWidth
                                label="Search Templates"
                                value={filterType}
                                onChange={(e) => setFilterType(e.target.value)}
                                placeholder="Search by type"
                            />
                        </Grid>
                        <Grid item xs={12} md={3}>
                            <FormControl fullWidth>
                                <InputLabel id="filter-type-label">Filter by Type</InputLabel>
                                <Select
                                    labelId="filter-type-label"
                                    value={filterType}
                                    onChange={(e) => setFilterType(e.target.value)}
                                    label="Filter by Type"
                                >
                                    <MenuItem value="all">All Templates</MenuItem>
                                    <ListSubheader>Regular Templates</ListSubheader>
                                    {templateTypes
                                        .filter(type => type.group === 'Regular')
                                        .map((type) => (
                                            <MenuItem key={type.value} value={type.value}>
                                                {type.label}
                                            </MenuItem>
                                        ))
                                    }
                                    <ListSubheader>Default Templates</ListSubheader>
                                    {templateTypes
                                        .filter(type => type.group === 'Default')
                                        .map((type) => (
                                            <MenuItem key={type.value} value={type.value}>
                                                {type.label}
                                            </MenuItem>
                                        ))
                                    }
                                </Select>
                            </FormControl>
                        </Grid>
                        <Grid item xs={12} md={4}>
                            <Button
                                variant="outlined"
                                startIcon={<RefreshIcon />}
                                onClick={() => {
                                    // Use the internal implementation if fetchTemplates is not a function
                                    if (typeof fetchTemplates === 'function') {
                                        fetchTemplates();
                                    } else {
                                        fetchTemplatesInternal();
                                    }
                                }}
                            >
                                Refresh
                            </Button>
                        </Grid>
                    </Grid>
                </Box>
                
                {isLoading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                        <CircularProgress />
                    </Box>
                ) : (
                    <>
                        {filteredTemplates.length === 0 ? (
                            <Alert severity="info">
                                No templates found. Create your first template to get started.
                            </Alert>
                        ) : (
                            <List sx={{ bgcolor: 'background.paper' }}>
                                {filteredTemplates.map((template) => (
                                    <ListItem
                                        key={template.template_id}
                                        button
                                        onClick={() => handleEditExistingTemplate(template.template_id)}
                                        sx={{ 
                                            mb: 1,
                                            borderLeft: isDefaultTemplate(template.template_type) ? '4px solid #f50057' : 'none',
                                            bgcolor: isDefaultTemplate(template.template_type) ? 'rgba(245, 0, 87, 0.04)' : 'background.paper'
                                        }}
                                    >
                                        <ListItemText
                                            primary={
                                                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                                    {isDefaultTemplate(template.template_type) && (
                                                        <Tooltip title="Default Template">
                                                            <StarIcon sx={{ mr: 1, color: 'secondary.main', fontSize: '1rem' }} />
                                                        </Tooltip>
                                                    )}
                                                    <Typography variant="subtitle1">
                                                        {template.template_name || 'Unnamed Template'}
                                                    </Typography>
                                                    <Chip 
                                                        size="small" 
                                                        label={getTemplateTypeLabel(template.template_type)} 
                                                        sx={{ ml: 1 }}
                                                        color={isDefaultTemplate(template.template_type) ? 'secondary' : 'primary'}
                                                        variant={isDefaultTemplate(template.template_type) ? 'filled' : 'outlined'}
                                                    />
                                                </Box>
                                            }
                                            secondary={
                                                <>
                                                    <Typography component="span" variant="body2" color="text.secondary">
                                                        {template.template_description || 'No description'}
                                                    </Typography>
                                                    <Typography component="span" variant="caption" color="text.secondary" sx={{ display: 'block' }}>
                                                        ID: {template.template_id}
                                                    </Typography>
                                                </>
                                            }
                                        />
                                        <ListItemSecondaryAction>
                                            <Tooltip title="Edit Template">
                                                <IconButton 
                                                    edge="end" 
                                                    aria-label="edit"
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleEditExistingTemplate(template.template_id);
                                                    }}
                                                >
                                                    <EditIcon />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="Duplicate Template">
                                                <IconButton 
                                                    edge="end" 
                                                    aria-label="duplicate"
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleDuplicateTemplate(template);
                                                    }}
                                                >
                                                    <ContentCopyIcon />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="Delete Template">
                                                <IconButton 
                                                    edge="end" 
                                                    aria-label="delete"
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleDeleteTemplate(template.template_id);
                                                    }}
                                                >
                                                    <DeleteIcon />
                                                </IconButton>
                                            </Tooltip>
                                        </ListItemSecondaryAction>
                                    </ListItem>
                                ))}
                            </List>
                        )}
                    </>
                )}
                
                {/* Edit Template Dialog */}
                <Dialog open={editDialogOpen} onClose={() => setEditDialogOpen(false)} maxWidth="md" fullWidth>
                    <DialogTitle>Edit Template: {editingTemplate.template_name}</DialogTitle>
                    <DialogContent>
                        <Grid container spacing={2}>
                            <Grid item xs={12}>
                                <TextField
                                    label="Template Name" 
                                    value={editingTemplate.template_name}
                                    onChange={(e) => setEditingTemplate({...editingTemplate, template_name: e.target.value})}
                                    fullWidth
                                    margin="normal"
                                />
                            </Grid>
                            <Grid item xs={12}>
                                <FormControl fullWidth margin="normal">
                                    <InputLabel>Template Type</InputLabel>
                                    <Select
                                        value={editingTemplate.template_type}
                                        onChange={(e) => setEditingTemplate({...editingTemplate, template_type: e.target.value})}
                                        label="Template Type"
                                    >
                                        {templateTypes.map((type) => (
                                            <MenuItem key={type.value} value={type.value}>
                                                {type.label}
                                            </MenuItem>
                                        ))}
                                    </Select>
                                </FormControl>
                            </Grid>
                            <Grid item xs={12}>
                                <TextField
                                    label="Template Content"
                                    value={editingTemplate.content}
                                    onChange={(e) => setEditingTemplate({...editingTemplate, content: e.target.value})}
                                    fullWidth
                                    multiline
                                    rows={6}
                                    margin="normal"
                                />
                            </Grid>
                            <Grid item xs={12}>
                                <TextField
                                    label="System Prompt (Optional)"
                                    value={editingTemplate.system_prompt}
                                    onChange={(e) => setEditingTemplate({...editingTemplate, system_prompt: e.target.value})}
                                    fullWidth
                                    multiline
                                    rows={3}
                                    margin="normal"
                                />
                            </Grid>
                            <Grid item xs={12}>
                                <Box sx={{ mt: 1 }}>
                                    <Typography variant="subtitle2">Variables detected:</Typography>
                                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
                                        {editingTemplate.variables.map((variable, idx) => (
                                            <Chip key={idx} label={variable} size="small" />
                                        ))}
                                        {editingTemplate.variables.length === 0 && (
                                            <Typography variant="body2" color="text.secondary">
                                                No variables detected. Use {'{variable_name}'} syntax to create variables.
                                            </Typography>
                                        )}
                                    </Box>
                                </Box>
                            </Grid>
                        </Grid>
                    </DialogContent>
                    <DialogActions>
                        <Button onClick={() => setEditDialogOpen(false)}>Cancel</Button>
                        <Button 
                            onClick={handleUpdateTemplate}
                            color="primary" 
                            variant="contained"
                            disabled={!editingTemplate.template_name || !editingTemplate.content}
                        >
                            Save Changes
                        </Button>
                    </DialogActions>
                </Dialog>
                
                {/* Snackbar for notifications */}
                <Snackbar
                    open={snackbar.open}
                    autoHideDuration={6000}
                    onClose={handleCloseSnackbar}
                    anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
                >
                    <Alert onClose={handleCloseSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
                        {snackbar.message}
                    </Alert>
                </Snackbar>
            </Paper>
        </Container>
    );
}

export default TemplateManagement;

================================================================================
File: TemplateSection.js
Path: .\front-end\src\components\TemplateSection.js
Size: 4596
Modified: 2025-04-10T12:28:18.090007
Created: 2025-04-01T07:22:34.674449
Hash: dc33d38484649d668ad3fe52773d2a8d7a013726129fdbf07d6c35209765340b
Lines: 159
================================================================================
import React, { useState } from 'react';
import {
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  Box,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Grid,
  Alert
} from '@mui/material';

const TemplateSection = ({
  templateId,
  templateName,
  templateContent,
  templateSystemPrompt,
  templateType,
  setTemplateId,
  setTemplateName,
  setTemplateContent,
  setTemplateSystemPrompt,
  setTemplateType,
  createTemplate,
  errorMessage
}) => {
  const [isCreating, setIsCreating] = useState(false);

  const templateTypes = [
    { value: 'stage_selection', label: 'Stage Selection' },
    { value: 'data_extraction', label: 'Data Extraction' },
    { value: 'response_generation', label: 'Response Generation' },
    { value: 'default_stage_selection', label: 'Default Stage Selection' },
    { value: 'default_data_extraction', label: 'Default Data Extraction' },
    { value: 'default_response_generation', label: 'Default Response Generation' }
  ];

  const handleCreateTemplate = async () => {
    setIsCreating(true);
    try {
      await createTemplate();
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <Card>
      <CardContent>
        <Typography variant="h6" gutterBottom>
          Create Template
        </Typography>

        <Grid container spacing={2}>
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Template ID"
              value={templateId}
              onChange={(e) => setTemplateId(e.target.value)}
              margin="normal"
              disabled
              helperText="Template ID will be auto-generated"
            />
          </Grid>

          <Grid item xs={12}>
            <TextField
              fullWidth
              required
              label="Template Name"
              value={templateName}
              onChange={(e) => setTemplateName(e.target.value)}
              margin="normal"
              placeholder="Enter a descriptive name"
            />
          </Grid>

          <Grid item xs={12}>
            <FormControl fullWidth margin="normal">
              <InputLabel id="template-type-label">Template Type</InputLabel>
              <Select
                labelId="template-type-label"
                value={templateType}
                onChange={(e) => setTemplateType(e.target.value)}
                label="Template Type"
              >
                {templateTypes.map((type) => (
                  <MenuItem key={type.value} value={type.value}>
                    {type.label}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12}>
            <TextField
              fullWidth
              required
              label="Template Content"
              value={templateContent}
              onChange={(e) => setTemplateContent(e.target.value)}
              margin="normal"
              multiline
              rows={6}
              placeholder="Enter template content with variables in curly braces, e.g. {variable_name}"
            />
          </Grid>

          <Grid item xs={12}>
            <TextField
              fullWidth
              label="System Prompt (Optional)"
              value={templateSystemPrompt}
              onChange={(e) => setTemplateSystemPrompt(e.target.value)}
              margin="normal"
              multiline
              rows={3}
              placeholder="Enter optional system prompt for the model"
            />
          </Grid>

          {errorMessage && (
            <Grid item xs={12}>
              <Alert severity="error" sx={{ mt: 2 }}>
                {errorMessage}
              </Alert>
            </Grid>
          )}

          <Grid item xs={12}>
            <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end' }}>
              <Button
                variant="contained"
                color="primary"
                onClick={handleCreateTemplate}
                disabled={
                  isCreating || 
                  !templateName.trim() || 
                  !templateContent.trim() || 
                  !templateType
                }
              >
                {isCreating ? 'Creating...' : 'Create Template'}
              </Button>
            </Box>
          </Grid>
        </Grid>
      </CardContent>
    </Card>
  );
};

export default TemplateSection; 

================================================================================
File: useConfig.js
Path: .\front-end\src\components\useConfig.js
Size: 1539
Modified: 2025-03-31T00:14:31.794035
Created: 2025-03-31T00:14:31.239602
Hash: dee485e40e8b56412b2eb01edfcf2d53e533a9032bf5c21bf18b53677cc66719
Lines: 46
================================================================================
import { useState, useEffect, useCallback } from 'react';

const useConfig = () => {
    const [apiKey, setApiKey] = useState(localStorage.getItem('icmpApiKey') || '');
    const [userId, setUserId] = useState('');
    const [businessId, setBusinessId] = useState('');
    const [validationError, setValidationError] = useState('');
    const [configOutput, setConfigOutput] = useState('');
    const [businessApiKey, setBusinessApiKey] = useState('');
    const [validationStatus, setValidationStatus] = useState(null);
    const [displayUserId, setDisplayUserId] = useState('');
    const [displayBusinessId, setDisplayBusinessId] = useState('');
    const [displayApiKey, setDisplayApiKey] = useState('');
    const [displayBusinessApiKey, setDisplayBusinessApiKey] = useState('');

    const memoizedSetApiKey = useCallback((newApiKey) => {
        setApiKey(newApiKey);
    }, []);

    return {
        apiKey,
        setApiKey: memoizedSetApiKey,
        userId,
        setUserId,
        businessId,
        setBusinessId,
        validationError,
        setValidationError,
        configOutput,
        setConfigOutput,
        businessApiKey,
        setBusinessApiKey,
        validationStatus,
        setValidationStatus,
        displayUserId,
        setDisplayUserId,
        displayBusinessId,
        setDisplayBusinessId,
        displayApiKey,
        setDisplayApiKey,
        displayBusinessApiKey,
        setDisplayBusinessApiKey
    };
};

export default useConfig;

================================================================================
File: UserManagement.js
Path: .\front-end\src\components\UserManagement.js
Size: 1215
Modified: 2025-03-31T00:10:30.621692
Created: 2025-03-28T21:39:45.797558
Hash: 992e02a25d05c087dd6ea1f6b09cfe873533f43e7e8a6cb4726c19fb8e62f4c1
Lines: 22
================================================================================
// src/components/UserManagement.js
import React from 'react';
import { TextField, Button, Typography, Card, CardContent, Box } from '@mui/material';

function UserManagement({ firstName, setFirstName, lastName, setLastName, email, setEmail, userOutput, createUser, handleSnackbarOpen }) {
    return (
        <Card sx={{ mt: 2 }}>
            <CardContent>
                <Typography variant="h6" gutterBottom>User Management</Typography>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
                    <TextField label="First Name" variant="outlined" value={firstName} onChange={(e) => setFirstName(e.target.value)} />
                    <TextField label="Last Name" variant="outlined" value={lastName} onChange={(e) => setLastName(e.target.value)} />
                    <TextField label="Email" variant="outlined" value={email} onChange={(e) => setEmail(e.target.value)} />
                    <Button variant="contained" onClick={createUser}>Create User</Button>
                    <Typography variant="body1">{userOutput}</Typography>
                </Box>
            </CardContent>
        </Card>
    );
}

export default UserManagement;

================================================================================
File: UserSection.js
Path: .\front-end\src\components\UserSection.js
Size: 711
Modified: 2025-04-01T07:22:16.207094
Created: 2025-04-01T07:22:13.665206
Hash: b056811b06012122d02902e858643215584336690d3f1928f29734bbb26c80e2
Lines: 22
================================================================================
import React from 'react';
import { Typography } from '@mui/material';
import UserManagement from './UserManagement';

function UserSection({ firstName, setFirstName, lastName, setLastName, email, setEmail, createUser, userOutput }) {
    return (
        <div>
            <UserManagement
                firstName={firstName}
                setFirstName={setFirstName}
                lastName={lastName}
                setLastName={setLastName}
                email={email}
                setEmail={setEmail}
                createUser={createUser}
            />
            <Typography variant="body1">{userOutput}</Typography>
        </div>
    );
}

export default UserSection; 

================================================================================
File: useStageManagement.js
Path: .\front-end\src\components\useStageManagement.js
Size: 3332
Modified: 2025-03-31T00:15:22.851582
Created: 2025-03-31T00:15:22.352391
Hash: d4a5622cfcf944a22fdaadf59f94641b8566c257274913e90ec5e288d8d55d59
Lines: 87
================================================================================
// src/hooks/useStageManagement.js
import { useState } from 'react';
import { fetchStages as fetchStagesApi, createStage as createStageApi} from '../services/testService';

const useStageManagement = (apiKey, businessId, handleSnackbarOpen) => {
    const [stageId, setStageId] = useState('');
    const [stageName, setStageName] = useState('');
    const [stageDescription, setStageDescription] = useState('');
    const [stageType, setStageType] = useState('');
    const [selectionTemplateId, setSelectionTemplateId] = useState('');
    const [selectionCustomPrompt, setSelectionCustomPrompt] = useState('');
    const [extractionTemplateId, setExtractionTemplateId] = useState('');
    const [extractionCustomPrompt, setExtractionCustomPrompt] = useState('');
    const [responseTemplateId, setResponseTemplateId] = useState('');
    const [responseCustomPrompt, setResponseCustomPrompt] = useState('');
    const [stageOutput, setStageOutput] = useState('');

    const fetchStages = async () => {
        if (!businessId) {
            setStageOutput("Please enter a Business ID.");
            handleSnackbarOpen("Please enter a Business ID.", "warning");
            return;
        }
        try {
            const data = await fetchStagesApi(businessId, apiKey)
            setStageOutput(JSON.stringify(data, null, 2));
            handleSnackbarOpen("Stages Fetched!", "success")

        } catch (error) {
            setStageOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    const createStage = async () => {
        const stageData = {
            business_id: businessId,
            stage_name: stageName,
            stage_description: stageDescription,
            stage_type: stageType,
            selection_template_id: selectionTemplateId || null,
            selection_custom_prompt: selectionCustomPrompt || null,
            extraction_template_id: extractionTemplateId || null,
            extraction_custom_prompt: extractionCustomPrompt || null,
            response_template_id: responseTemplateId || null,
            response_custom_prompt: responseCustomPrompt || null
        };

        try {
            const data = await createStageApi(stageData, apiKey)
            setStageOutput(`Stage Created: ${data.stage_id}`);
            handleSnackbarOpen(`Stage Created: ${data.stage_id}`, "success")
        } catch (error) {
            setStageOutput(`Error: ${error.message}`);
            handleSnackbarOpen(error.message, "error")
        }
    };

    return {
        stageId,
        setStageId,
        stageName,
        setStageName,
        stageDescription,
        setStageDescription,
        stageType,
        setStageType,
        selectionTemplateId,
        setSelectionTemplateId,
        selectionCustomPrompt,
        setSelectionCustomPrompt,
        extractionTemplateId,
        setExtractionTemplateId,
        extractionCustomPrompt,
        setExtractionCustomPrompt,
        responseTemplateId,
        setResponseTemplateId,
        responseCustomPrompt,
        setResponseCustomPrompt,
        stageOutput,
        setStageOutput,
        fetchStages,
        createStage
    };
};

export default useStageManagement;

================================================================================
File: useTemplateManagement.js
Path: .\front-end\src\components\useTemplateManagement.js
Size: 2552
Modified: 2025-03-31T00:15:59.529739
Created: 2025-03-31T00:15:59.027115
Hash: bcdac65834c7be65be1b5b7924c8fa55a149e06469e95e87bd50296d1e3bbd68
Lines: 69
================================================================================
// src/hooks/useTemplateManagement.js
import { useState, useCallback } from 'react';
import { fetchTemplates as fetchTemplatesApi } from '../services/testService';

const useTemplateManagement = (apiKey, handleSnackbarOpen) => {
    const [templateID, setTemplateID] = useState('');
    const [templateName, setTemplateName] = useState('');
    const [templateText, setTemplateText] = useState('');
    const [templateOutput, setTemplateOutput] = useState('');
    const [availableVariable, setAvailableVariable] = useState([]);
    const [selectedVariable, setSelectedVariable] = useState('');
    const [defaultTemplates, setDefaultTemplates] = useState([]);

    const loadTemplates = useCallback(async () => {
        try {
            const templates = await fetchTemplatesApi(apiKey);
            setDefaultTemplates(templates);
            setTemplateOutput("Templates Fetched!");
            handleSnackbarOpen("Templates Fetched!", "success");
        } catch (error) {
            setTemplateOutput(`Error fetching templates: ${error.message}`);
            handleSnackbarOpen(`Error fetching templates: ${error.message}`, "error");
        }
    }, [apiKey, handleSnackbarOpen]);

    const handleTemplateSelection = (event) => {
        const selectedTemplateId = event.target.value;
        setTemplateID(selectedTemplateId);
        const selectedTemplate = defaultTemplates.find(template => template.template_id === selectedTemplateId);

        if (selectedTemplate) {
            setTemplateText(selectedTemplate.template_text);
        } else {
            setTemplateText('');
        }
    };

    const handleVariableSelection = (event) => {
        setSelectedVariable(event.target.value);
    };

    const addVariableToTemplate = () => {
        let newTemplateText = templateText + "{" + selectedVariable + "}";
        setTemplateText(newTemplateText);
    };

    // useEffect to load templates when the component mounts
    // Add logic createTemplate and saveDefaultTemplate
    return {
        templateID,
        setTemplateID,
        templateName,
        setTemplateName,
        templateText,
        setTemplateText,
        templateOutput,
        setTemplateOutput,
        availableVariable,
        setAvailableVariable,
        selectedVariable,
        setSelectedVariable,
        addVariableToTemplate,
        handleTemplateSelection,
        handleVariableSelection,
        loadTemplates
    };
};

export default useTemplateManagement;

================================================================================
File: useUser.js
Path: .\front-end\src\components\useUser.js
Size: 507
Modified: 2025-03-31T00:13:57.736277
Created: 2025-03-31T00:13:57.201933
Hash: ffe7a63d773406580e492f94e9d286a3649ed8a55a7fbd837ba3fdb363ad021d
Lines: 22
================================================================================
// src/hooks/useUser.js
import { useState } from 'react';

const useUser = () => {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [email, setEmail] = useState('');
    const [userOutput, setUserOutput] = useState('');

    return {
        firstName,
        setFirstName,
        lastName,
        setLastName,
        email,
        setEmail,
        userOutput,
        setUserOutput
    };
};

export default useUser;

================================================================================
File: AddEditStageForm.jsx
Path: .\front-end\src\components\AddEditStageForm\AddEditStageForm.jsx
Size: 18570
Modified: 2025-04-12T15:18:57.021036
Created: 2025-04-02T20:45:25.679523
Hash: a6be514af683d7a66158cbeeedf133da7ae31d8750e4e28c36767d7d6d99f499
Lines: 415
================================================================================
import React, { useState, useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { API_CONFIG } from '../../config';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Grid,
  Alert,
  CircularProgress,
  Divider
} from '@mui/material';

function AddStageForm() {
    // --- Routing & Context ---
    const location = useLocation();
    const queryParams = new URLSearchParams(location.search);
    const agentIdParam = queryParams.get('agent_id'); // Get agent context ('uuid' or 'null')
    const navigate = useNavigate();

    // --- State ---
    const [formData, setFormData] = useState({
        stage_name: '',
        stage_description: 'Default description',
        stage_type: 'conversation',
        stage_selection_template_id: '',
        data_extraction_template_id: '',
        response_generation_template_id: ''
    });
    const [availableTemplates, setAvailableTemplates] = useState({ selection: [], extraction: [], generation: [] });
    const [isLoading, setIsLoading] = useState(true);
    const [isSaving, setIsSaving] = useState(false);
    const [error, setError] = useState(null);
    const [contextAgentName, setContextAgentName] = useState('General');

    // Get stored credentials
    const getStoredCredentials = () => {
        return {
            businessId: localStorage.getItem('businessId') || '',
            businessApiKey: localStorage.getItem('businessApiKey') || ''
        };
    };

    // --- Effects ---
    // 1. Determine context agent name
    useEffect(() => {
        setContextAgentName(agentIdParam === 'null' ? 'General' : `Agent ${agentIdParam}`);
    }, [agentIdParam]);

    // 2. Fetch available templates
    useEffect(() => {
        const fetchTemplates = async () => {
            setError(null);
            setIsLoading(true);
            console.log("Fetching available templates...");
            
            const { businessId, businessApiKey } = getStoredCredentials();
            
            if (!businessId || !businessApiKey) {
                setError('Authentication required. Please log in.');
                setIsLoading(false);
                return;
            }
            
            // Organize templates by type for dropdowns
            const organized = { 
                selection: [], 
                extraction: [], 
                generation: [] 
            };
            
            try {
                // Step 1: Fetch regular templates first
                const regularResponse = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.TEMPLATES}?business_id=${businessId}`, {
                    method: 'GET',
                    headers: { 
                        'Accept': 'application/json',
                        'Authorization': `Bearer ${businessApiKey}`
                    }
                });
                
                if (!regularResponse.ok) {
                    const errorData = await regularResponse.json().catch(() => ({}));
                    throw new Error(`HTTP error ${regularResponse.status}: ${errorData.message || 'Failed to fetch templates'}`);
                }
                
                const regularTemplates = await regularResponse.json();
                console.log("Regular templates fetched:", regularTemplates);
                
                // Process regular templates
                regularTemplates.forEach(template => {
                    if (template.template_type === 'selection') {
                        organized.selection.push(template);
                    } else if (template.template_type === 'extraction') {
                        organized.extraction.push(template);
                    } else if (template.template_type === 'generation') {
                        organized.generation.push(template);
                    }
                });
                
                // Step 2: Now fetch default templates
                const defaultResponse = await fetch(`${API_CONFIG.BASE_URL}/api/templates/default-templates?business_id=${businessId}`, {
                    method: 'GET',
                    headers: { 
                        'Accept': 'application/json',
                        'Authorization': `Bearer ${businessApiKey}`
                    }
                });
                
                if (!defaultResponse.ok) {
                    const errorData = await defaultResponse.json().catch(() => ({}));
                    throw new Error(`HTTP error ${defaultResponse.status}: ${errorData.message || 'Failed to fetch default templates'}`);
                }
                
                const defaultTemplates = await defaultResponse.json();
                console.log("Default templates fetched:", defaultTemplates);
                
                // Process default templates
                defaultTemplates.forEach(template => {
                    if (template.template_type === 'selection') {
                        organized.selection.push(template);
                    } else if (template.template_type === 'extraction') {
                        organized.extraction.push(template);
                    } else if (template.template_type === 'generation') {
                        organized.generation.push(template);
                    }
                });
                
                // Sort templates by name
                organized.selection.sort((a, b) => a.template_name.localeCompare(b.template_name));
                organized.extraction.sort((a, b) => a.template_name.localeCompare(b.template_name));
                organized.generation.sort((a, b) => a.template_name.localeCompare(b.template_name));
                
                console.log("Organized templates:", organized);
                setAvailableTemplates(organized);
                
                // Set default templates if available
                const defaultSelection = organized.selection.find(t => t.template_name.toLowerCase().includes('default'));
                const defaultExtraction = organized.extraction.find(t => t.template_name.toLowerCase().includes('default'));
                const defaultGeneration = organized.generation.find(t => t.template_name.toLowerCase().includes('default'));
                
                if (defaultSelection || defaultExtraction || defaultGeneration) {
                    setFormData(prev => ({
                        ...prev,
                        stage_selection_template_id: defaultSelection ? defaultSelection.template_id : '',
                        data_extraction_template_id: defaultExtraction ? defaultExtraction.template_id : '',
                        response_generation_template_id: defaultGeneration ? defaultGeneration.template_id : ''
                    }));
                }
                
            } catch (err) {
                console.error("Error fetching templates:", err);
                setError(err.message || "Failed to load templates. Please try again later.");
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchTemplates();
    }, []);

    // --- Handlers ---
    const handleInputChange = (e) => {
        const { name, value } = e.target;
        console.log(`Field ${name} changed to: ${value}`);
        setFormData(prev => ({ ...prev, [name]: value }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsSaving(true);
        setError(null);
        
        const { businessId, businessApiKey } = getStoredCredentials();
        
        if (!businessId || !businessApiKey) {
            setError('Authentication required. Please log in.');
            setIsSaving(false);
            return;
        }
        
        // Log the form state to verify values
        console.log("Form state before submission:", formData);
        
        try {
            const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.STAGES}?business_id=${businessId}`;
            const method = 'POST';
            
            console.log(`Submitting stage data to ${url} using ${method}`);
            
            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${businessApiKey}`
                },
                body: JSON.stringify(formData)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`HTTP error ${response.status}: ${errorData.message || 'Failed to save stage'}`);
            }
            
            const result = await response.json();
            console.log(`Stage created successfully:`, result);
            
            // Navigate to the stage management page
            navigate('/stage-management');
            
        } catch (err) {
            console.error(`Error creating stage:`, err);
            setError(err.message || `An unexpected error occurred while creating the stage.`);
        } finally {
            setIsSaving(false);
        }
    };

    const handleCancel = () => {
        navigate('/stage-management');
    };

    // --- Render ---
    if (isLoading) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '200px' }}>
                <CircularProgress />
            </Box>
        );
    }

    return (
        <Box component="form" onSubmit={handleSubmit} noValidate>
            <Paper sx={{ p: 3, mb: 3 }}>
                <Typography variant="h6" gutterBottom>
                    Add New Stage
                </Typography>
                
                {error && (
                    <Alert severity="error" sx={{ mb: 2 }}>
                        {error}
                    </Alert>
                )}
                
                <Grid container spacing={3}>
                    {/* Basic Information */}
                    <Grid item xs={12}>
                        <Typography variant="subtitle1" gutterBottom>
                            Basic Information
                        </Typography>
                        <Divider sx={{ mb: 2 }} />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                        <TextField
                            required
                            fullWidth
                            id="stage_name"
                            name="stage_name"
                            label="Stage Name"
                            value={formData.stage_name}
                            onChange={handleInputChange}
                            error={!formData.stage_name}
                            helperText={!formData.stage_name ? "Stage name is required" : ""}
                        />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                        <FormControl fullWidth>
                            <InputLabel id="stage_type_label">Stage Type</InputLabel>
                            <Select
                                labelId="stage_type_label"
                                id="stage_type"
                                name="stage_type"
                                value={formData.stage_type}
                                onChange={handleInputChange}
                                label="Stage Type"
                            >
                                <MenuItem value="conversation">Conversation</MenuItem>
                                <MenuItem value="response">Response</MenuItem>
                                <MenuItem value="form">Form</MenuItem>
                            </Select>
                        </FormControl>
                    </Grid>
                    
                    <Grid item xs={12}>
                        <TextField
                            fullWidth
                            id="stage_description"
                            name="stage_description"
                            label="Stage Description"
                            multiline
                            rows={3}
                            value={formData.stage_description}
                            onChange={handleInputChange}
                        />
                    </Grid>
                    
                    {/* Template Selection */}
                    <Grid item xs={12}>
                        <Typography variant="subtitle1" gutterBottom>
                            Template Selection
                        </Typography>
                        <Divider sx={{ mb: 2 }} />
                    </Grid>
                    
                    <Grid item xs={12}>
                        <FormControl fullWidth>
                            <InputLabel id="stage_selection_template_label">Stage Selection Template</InputLabel>
                            <Select
                                labelId="stage_selection_template_label"
                                id="stage_selection_template_id"
                                name="stage_selection_template_id"
                                value={formData.stage_selection_template_id}
                                onChange={handleInputChange}
                                label="Stage Selection Template"
                            >
                                {availableTemplates.selection.length === 0 ? (
                                    <MenuItem value="">
                                        <em>No templates available</em>
                                    </MenuItem>
                                ) : (
                                    availableTemplates.selection.map(template => (
                                        <MenuItem key={template.template_id} value={template.template_id}>
                                            {template.template_name}
                                        </MenuItem>
                                    ))
                                )}
                            </Select>
                        </FormControl>
                    </Grid>
                    
                    <Grid item xs={12}>
                        <FormControl fullWidth>
                            <InputLabel id="data_extraction_template_label">Data Extraction Template</InputLabel>
                            <Select
                                labelId="data_extraction_template_label"
                                id="data_extraction_template_id"
                                name="data_extraction_template_id"
                                value={formData.data_extraction_template_id}
                                onChange={handleInputChange}
                                label="Data Extraction Template"
                            >
                                {availableTemplates.extraction.length === 0 ? (
                                    <MenuItem value="">
                                        <em>No templates available</em>
                                    </MenuItem>
                                ) : (
                                    availableTemplates.extraction.map(template => (
                                        <MenuItem key={template.template_id} value={template.template_id}>
                                            {template.template_name}
                                        </MenuItem>
                                    ))
                                )}
                            </Select>
                        </FormControl>
                    </Grid>
                    
                    <Grid item xs={12}>
                        <FormControl fullWidth>
                            <InputLabel id="response_generation_template_label">Response Generation Template</InputLabel>
                            <Select
                                labelId="response_generation_template_label"
                                id="response_generation_template_id"
                                name="response_generation_template_id"
                                value={formData.response_generation_template_id}
                                onChange={handleInputChange}
                                label="Response Generation Template"
                            >
                                {availableTemplates.generation.length === 0 ? (
                                    <MenuItem value="">
                                        <em>No templates available</em>
                                    </MenuItem>
                                ) : (
                                    availableTemplates.generation.map(template => (
                                        <MenuItem key={template.template_id} value={template.template_id}>
                                            {template.template_name}
                                        </MenuItem>
                                    ))
                                )}
                            </Select>
                        </FormControl>
                    </Grid>
                </Grid>
                
                <Box sx={{ mt: 3, display: 'flex', justifyContent: 'flex-end' }}>
                    <Button
                        variant="outlined"
                        onClick={handleCancel}
                        sx={{ mr: 2 }}
                    >
                        Cancel
                    </Button>
                    <Button
                        type="submit"
                        variant="contained"
                        color="primary"
                        disabled={isSaving || !formData.stage_name || !formData.stage_description}
                    >
                        {isSaving ? 'Saving...' : 'Create Stage'}
                    </Button>
                </Box>
            </Paper>
        </Box>
    );
}

export default AddStageForm;


================================================================================
File: AgentsListView.jsx
Path: .\front-end\src\components\AgentsListView\AgentsListView.jsx
Size: 5946
Modified: 2025-04-08T15:16:23.149169
Created: 2025-04-02T20:39:48.196776
Hash: f89117da31ee2b05c1e71c19c9848c80518036fa0675929ed36e2a75df2a6cd0
Lines: 150
================================================================================
import React, { useState, useEffect } from 'react';
// Import useNavigate from react-router-dom
import { useNavigate } from 'react-router-dom';

// Define your backend API base URL
const API_BASE_URL = 'http://localhost:5000';

function AgentsListView() {
    const [agents, setAgents] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    // Initialize useNavigate hook
    const navigate = useNavigate();

    // TODO: Replace with actual business ID from context/props/state management
    const businessId = '7ae167a0-d864-43b9-bdaf-fcba35b33f27'; // Replace with a REAL ID for testing

    useEffect(() => {
        const fetchAgents = async () => {
            if (!businessId || businessId === 'YOUR_BUSINESS_ID_HERE') {
                setError("Business ID not available.");
                setIsLoading(false);
                return;
            }
            setIsLoading(true);
            setError(null);
            console.log(`Fetching agents for business ID: ${businessId}`);

            try {
                const response = await fetch(`${API_BASE_URL}/agents?business_id=${businessId}`, {
                    method: 'GET',
                    credentials: 'include', // Send cookies
                    headers: {
                        'Accept': 'application/json',
                    },
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`HTTP error ${response.status}: ${errorData.message || 'Failed to fetch agents'}`);
                }

                const fetchedAgents = await response.json();
                setAgents(fetchedAgents);

            } catch (err) {
                console.error("Error fetching agents:", err);
                setError(err.message || "An unexpected error occurred while fetching agents.");
                setAgents([]);
            } finally {
                setIsLoading(false);
            }
        };

        fetchAgents();

    }, [businessId]);

    // Implement navigation to stages view with agent_id parameter
    const handleManageStages = (agentId) => {
        console.log(`Navigate to manage stages for agent: ${agentId === null ? 'General' : agentId}`);
        // Navigate to the StageManager with agent_id and business_id query parameters
        navigate(`/stages?business_id=${businessId}&agent_id=${agentId === null ? '' : agentId}`);
    };

    // Add function to delete an agent
    const handleDeleteAgent = async (agentId, agentName) => {
        if (!window.confirm(`Are you sure you want to delete agent "${agentName}"?`)) {
            return;
        }

        try {
            const response = await fetch(`${API_BASE_URL}/agents/${agentId}?business_id=${businessId}`, {
                method: 'DELETE',
                credentials: 'include',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ business_id: businessId })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`HTTP error ${response.status}: ${errorData.message || 'Failed to delete agent'}`);
            }

            // Success! Remove the agent from the list
            setAgents(prevAgents => prevAgents.filter(agent => agent.agent_id !== agentId));
            alert(`Agent "${agentName}" deleted successfully.`);
        } catch (err) {
            console.error("Error deleting agent:", err);
            alert(`Error deleting agent: ${err.message}`);
        }
    };

    if (isLoading) {
        return <div>Loading agents...</div>;
    }

    if (error) {
        return <div style={{ color: 'red' }}>Error: {error}</div>;
    }

    return (
        <div>
            <h2>Manage Agents & Stages</h2>
            <p>Select an agent or manage general stages.</p>
             {/* TODO: Add button/link to create new agents later */}

            {/* General Stages Option */}
            <div style={{ border: '1px solid #ccc', padding: '10px', marginBottom: '10px' }}>
                <h3>General Stages</h3>
                <p>Manage stages that apply to all agents.</p>
                <button onClick={() => handleManageStages(null)}>
                    Manage General Stages
                </button>
            </div>

            <hr />

             <h3>Specific Agents</h3>
            {agents.length > 0 ? (
                agents.map(agent => (
                    <div key={agent.agent_id} style={{ border: '1px solid #eee', padding: '10px', marginBottom: '10px' }}>
                        <h4>{agent.agent_name}</h4>
                        <p>Role: {agent.agent_role || 'N/A'}</p>
                        <p>ID: {agent.agent_id}</p>
                        <div style={{ display: 'flex', gap: '10px' }}>
                            <button onClick={() => handleManageStages(agent.agent_id)}>
                                Manage Stages for {agent.agent_name}
                            </button>
                            <button 
                                onClick={() => handleDeleteAgent(agent.agent_id, agent.agent_name)}
                                style={{ backgroundColor: '#f44336', color: 'white' }}
                            >
                                Delete Agent
                            </button>
                        </div>
                    </div>
                ))
            ) : (
                <p>No specific agents found for this business.</p>
            )}
        </div>
    );
}

export default AgentsListView;


================================================================================
File: BusinessDetailsView.jsx
Path: .\front-end\src\components\BusinessDetailsView\BusinessDetailsView.jsx
Size: 21198
Modified: 2025-04-08T21:39:42.027965
Created: 2025-04-02T20:28:12.052402
Hash: e12c5f5c6a970afae730fbe7833649b962acb01e93994b166bb1ec237d24ee86
Lines: 580
================================================================================
import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import AgentSection from '../AgentSection';
import { 
  Snackbar, 
  Alert, 
  Box, 
  IconButton, 
  Typography, 
  Container, 
  Paper,
  Button,
  TextField,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  CircularProgress
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import EditIcon from '@mui/icons-material/Edit';
import DescriptionIcon from '@mui/icons-material/Description';
import LogoutIcon from '@mui/icons-material/Logout';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';

// Import services FIRST
import {
    getBusiness, 
    updateBusiness, 
    setDefaultStage 
} from '../../services/businessService'; 

import { 
    fetchStages 
} from '../../services/stageService';

import {
    fetchAgents, 
    createAgent, 
    updateAgent, 
    deleteAgent 
} from '../../services/agentService'; 

// Define your backend API base URL AFTER imports
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:5000';

function BusinessDetailsView() {
  const navigate = useNavigate();
  const [businessData, setBusinessData] = useState(null);
  const [editFormData, setEditFormData] = useState({}); // State for form data
  const [agents, setAgents] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false); // Added saving state
  const [error, setError] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  const [isEditingAgent, setIsEditingAgent] = useState(false);
  const [editingAgent, setEditingAgent] = useState(null);
  const [newAgentData, setNewAgentData] = useState({
    agent_name: '',
    agent_description: ''
  });

  // State for default stage selection
  const [availableStages, setAvailableStages] = useState([]); 
  const [selectedStageId, setSelectedStageId] = useState(''); 

  // Get the business ID from localStorage instead of hardcoding
  const businessId = localStorage.getItem('businessId');

  const handleSnackbarOpen = useCallback((message, severity = 'success') => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  }, []);

  const handleSnackbarClose = () => {
    setSnackbar({ ...snackbar, open: false });
  };

  const handleNavigateToLogin = () => {
    navigate('/login');
  };

  const handleLogout = useCallback(() => {
    // Clear localStorage
    localStorage.removeItem('userId');
    localStorage.removeItem('businessId');
    localStorage.removeItem('businessApiKey');
    
    // Show logout message
    handleSnackbarOpen('Logged out successfully', 'success');
    
    // Navigate to login page
    navigate('/login');
  }, [navigate, handleSnackbarOpen]);

  // Navigate to stage management for a specific agent
  const navigateToStageManagement = useCallback((agentId, agentName) => {
    console.log(`Navigating to stages for agent: ${agentName} (${agentId})`);
    
    // Store agent ID in localStorage for persistence
    localStorage.setItem('agentId', agentId);
    
    // Navigate to stages with proper URL format
    navigate(`/stages?business_id=${businessId}&agent_id=${agentId}`);
  }, [navigate, businessId]);

  // Fetch business data, stages, and agents
  const fetchData = useCallback(async () => {
    if (!businessId) {
      setError("Business ID not found. Please login again.");
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    setError(null); // Clear previous errors
    console.log(`Fetching data for business ID: ${businessId}`);

    try {
      // Fetch Business Details (ensure service includes first_stage_id)
      // Use await Promise.all for concurrent fetching
      const [fetchedBusinessData, fetchedStages, fetchedAgents] = await Promise.all([
        getBusiness(businessId),
        fetchStages(businessId),
        fetchAgents(businessId)
      ]);

      console.log('Fetched business data:', fetchedBusinessData);
      setBusinessData(fetchedBusinessData);
      setEditFormData(fetchedBusinessData); // Initialize form data with current values
      setSelectedStageId(fetchedBusinessData.first_stage_id || ''); // Set initial dropdown value
      
      console.log('Fetched stages:', fetchedStages);
      setAvailableStages(fetchedStages || []);

      console.log('Fetched agents:', fetchedAgents);
      setAgents(fetchedAgents || []);
      
    } catch (err) {
      console.error('Error fetching data:', err);
      setError(`Failed to load data: ${err.message}`);
      handleSnackbarOpen(`Error loading data: ${err.message}`, 'error');
    } finally {
      setIsLoading(false);
    }
  }, [businessId, handleSnackbarOpen]);

  useEffect(() => {
    fetchData();
  }, [fetchData]); // Run fetchData when component mounts or fetchData changes

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setEditFormData(prevData => ({
      ...prevData,
      [name]: value
    }));
  };

  const handleEditToggle = () => {
    if (!isEditing && businessData) {
      setEditFormData({
        business_name: businessData.business_name || '',
        business_description: businessData.business_description || '',
        address: businessData.address || '',
        phone_number: businessData.phone_number || '',
        website: businessData.website || ''
      });
    }
    setIsEditing(!isEditing);
    setError(null); // Clear errors when toggling mode
  };

  const handleSaveChanges = async (e) => {
    e.preventDefault(); // Prevent default form submission
    setIsSaving(true); // Indicate saving process
    setError(null);
    console.log("Saving business changes:", editFormData);

    try {
      // Extract only updatable fields
      const dataToUpdate = { 
        business_name: editFormData.business_name, 
        business_description: editFormData.business_description,
        address: editFormData.address,
        phone_number: editFormData.phone_number,
        website: editFormData.website
      }; 
      await updateBusiness(businessId, dataToUpdate);

      // Update the main business data state after successful save
      setBusinessData(prev => ({ ...prev, ...dataToUpdate })); 
      setIsEditing(false); // Exit edit mode
      handleSnackbarOpen('Business details updated successfully!', 'success');
    } catch (err) {
      console.error('Error saving business details:', err);
      setError(`Save failed: ${err.message}`);
      handleSnackbarOpen(`Error saving details: ${err.message}`, 'error');
    } finally {
      setIsSaving(false);
    }
  };

  // --- Default Stage Logic ---
  const handleStageSelectChange = (event) => {
    setSelectedStageId(event.target.value);
  };

  const handleSaveDefaultStage = async () => {
    if (!businessId) return;
    setIsSaving(true);
    setError(null);
    try {
      const stageIdToSave = selectedStageId === '' ? null : selectedStageId;
      await setDefaultStage(businessId, stageIdToSave);
      // Update local state optimistically or refetch
      setBusinessData(prev => ({ ...prev, first_stage_id: stageIdToSave })); 
      handleSnackbarOpen('Default starting stage updated successfully!', 'success');
    } catch (err) {
      console.error('Error saving default stage:', err);
      setError(`Failed to save default stage: ${err.message}`);
      handleSnackbarOpen(`Error saving default stage: ${err.message}`, 'error');
    } finally {
      setIsSaving(false);
    }
  };

  // Handle edit agent
  const handleEditAgent = (agent) => {
    setEditingAgent(agent);
    setIsEditingAgent(true);
  };

  // Handle delete agent
  const handleDeleteAgent = async (agentId) => {
    if (!window.confirm('Are you sure you want to delete this agent?')) {
      return;
    }
    
    setIsLoading(true);
    try {
      await deleteAgent(businessId, agentId);
      setAgents(prev => prev.filter(agent => agent.agent_id !== agentId));
      handleSnackbarOpen('Agent deleted successfully', 'success');
    } catch (error) {
      console.error('Error deleting agent:', error);
      handleSnackbarOpen(`Error deleting agent: ${error.message}`, 'error');
    } finally {
      setIsLoading(false);
    }
  };

  const handleAgentDialogClose = () => {
    setIsEditingAgent(false);
    setEditingAgent(null);
    setNewAgentData({ agent_name: '', agent_description: '' }); // Reset form
  };

  const handleAgentFormChange = (event) => {
    const { name, value } = event.target;
    if (editingAgent) {
      setEditingAgent(prev => ({ ...prev, [name]: value }));
    } else {
      setNewAgentData(prev => ({ ...prev, [name]: value }));
    }
  };

  const handleAgentFormSubmit = async (event) => {
    event.preventDefault();
    const agentData = editingAgent || newAgentData;
    if (!agentData.agent_name?.trim()) {
      handleSnackbarOpen('Agent name cannot be empty', 'warning');
      return;
    }

    setIsSaving(true); // Use general saving indicator
    try {
      let savedAgent;
      if (editingAgent) {
        savedAgent = await updateAgent(editingAgent.agent_id, agentData);
        setAgents(prev => prev.map(a => a.agent_id === savedAgent.agent_id ? savedAgent : a));
      } else {
        savedAgent = await createAgent(agentData);
        setAgents(prev => [...prev, savedAgent]);
      }
      handleSnackbarOpen(editingAgent ? 'Agent updated' : 'Agent created', 'success');
      handleAgentDialogClose();
    } catch (error) {
      console.error('Error saving agent:', error);
      handleSnackbarOpen(`Error saving agent: ${error.message}`, 'error');
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return <Container><Box display="flex" justifyContent="center" mt={5}><CircularProgress /></Box></Container>;
  }

  // Show login prompt if no businessId (e.g., localStorage cleared)
  if (!businessId) {
    return (
      <Container>
        <Alert severity="warning" sx={{ mt: 2 }}>
          Business ID not found. Please log in or configure your application.
        </Alert>
        <Button onClick={() => navigate('/login')} sx={{ mt: 1 }}>Go to Login</Button>
      </Container>
    );
  }

  // Show error if data fetching failed (and not just loading)
  if (error && !businessData) { // Only show main error if data failed completely
    return <Container><Alert severity="error" sx={{ mt: 2 }}>{error}</Alert></Container>;
  }

  // Should ideally not happen if businessId exists, but good fallback
  if (!businessData) { 
    return <Container><Alert severity="info" sx={{ mt: 2 }}>No business data loaded.</Alert></Container>;
  }

  return (
    <Container maxWidth="lg">
      <Paper elevation={3} sx={{ p: 3, mt: 2 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <IconButton onClick={() => navigate(-1)}> {/* Go back */} 
            <ArrowBackIcon />
          </IconButton>
          <Typography variant="h4" component="h1">
            Business Dashboard
          </Typography>
          <Button 
            variant="outlined" 
            startIcon={<LogoutIcon />} 
            onClick={handleLogout}
          >
            Logout
          </Button>
        </Box>

        {/* Display any general saving error */} 
        {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

        {/* --- Business Details Section --- */} 
        <Box mb={4}>
          <Typography variant="h5" gutterBottom>Business Details</Typography>
          {!isEditing ? (
            <Box>
              <Typography><strong>Name:</strong> {businessData.business_name}</Typography>
              <Typography><strong>Description:</strong> {businessData.business_description || 'N/A'}</Typography>
              <Typography><strong>Address:</strong> {businessData.address || 'N/A'}</Typography>
              <Typography><strong>Phone:</strong> {businessData.phone_number || 'N/A'}</Typography>
              <Typography><strong>Website:</strong> {businessData.website ? <a href={businessData.website} target="_blank" rel="noopener noreferrer">{businessData.website}</a> : 'N/A'}</Typography>
              <Typography><strong>Business ID:</strong> {businessData.business_id}</Typography>
              <Typography><strong>Owner ID:</strong> {businessData.owner_id}</Typography>
              <Button 
                variant="contained" 
                startIcon={<EditIcon />} 
                onClick={handleEditToggle} 
                sx={{ mt: 2 }}
              >
                Edit Details
              </Button>
            </Box>
          ) : (
            <Box component="form" onSubmit={handleSaveChanges} noValidate autoComplete="off">
              <TextField 
                label="Business Name"
                name="business_name"
                value={editFormData.business_name || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
                required
                disabled={isSaving}
              />
              <TextField 
                label="Description"
                name="business_description"
                value={editFormData.business_description || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
                multiline
                rows={3}
                disabled={isSaving}
              />
              <TextField 
                label="Address"
                name="address"
                value={editFormData.address || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
                disabled={isSaving}
              />
              <TextField 
                label="Phone Number"
                name="phone_number"
                value={editFormData.phone_number || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
                disabled={isSaving}
              />
              <TextField 
                label="Website"
                name="website"
                value={editFormData.website || ''}
                onChange={handleInputChange}
                fullWidth 
                margin="normal"
                type="url"
                disabled={isSaving}
              />
              <Box sx={{ mt: 2 }}>
                <Button 
                  type="submit" 
                  variant="contained" 
                  disabled={isSaving}
                  sx={{ mr: 1 }}
                >
                  {isSaving ? <CircularProgress size={24} /> : 'Save Changes'}
                </Button>
                <Button variant="outlined" onClick={handleEditToggle} disabled={isSaving}>
                  Cancel
                </Button>
              </Box>
            </Box>
          )}
        </Box>

        <hr />

        {/* --- Default Stage Selection Section --- */} 
        <Box mt={4} mb={4}>
          <Typography variant="h6" gutterBottom>Conversation Settings</Typography>
          <FormControl fullWidth margin="normal">
            <InputLabel id="default-stage-label">Default Starting Stage</InputLabel>
            <Select
              labelId="default-stage-label"
              id="default-stage-select"
              value={selectedStageId} // Bind to state
              label="Default Starting Stage"
              onChange={handleStageSelectChange} // Handle change
              disabled={isSaving || isLoading} // Disable while loading/saving
            >
              {/* "None" option */}
              <MenuItem value="">
                <em>None (System will pick first available)</em>
              </MenuItem>
              {/* Map available stages */} 
              {availableStages.length > 0 ? (
                availableStages.map((stage) => {
                  // --- DEBUGGING LOG --- 
                  console.log("Rendering stage:", stage);
                  // ---------------------
                  
                  // Find the agent name using the stage's agent_id
                  // Ensure agents state is populated before trying to find
                  const linkedAgent = agents && agents.find(agent => agent.agent_id === stage.agent_id);
                  const agentNameDisplay = linkedAgent ? ` (Agent: ${linkedAgent.agent_name})` : ''; // Display agent name if found
                  const displayText = `${stage.stage_name}${agentNameDisplay}`;

                  // --- DEBUGGING LOG --- 
                  console.log("Display text:", displayText);
                  // ---------------------
                  
                  return (
                    <MenuItem key={stage.stage_id} value={stage.stage_id}>
                      {/* Display Stage Name and potentially Agent Name */} 
                      {displayText}
                    </MenuItem>
                  );
                })
              ) : (
                <MenuItem disabled>No stages available for this business</MenuItem>
              )}
            </Select>
          </FormControl>
          <Button 
            variant="contained" 
            onClick={handleSaveDefaultStage} // Save handler
            disabled={isSaving || isLoading || selectedStageId === (businessData.first_stage_id || '')} // Disable if no change
            sx={{ mt: 2 }}
          >
            {isSaving ? <CircularProgress size={24} /> : 'Save Default Stage'}
          </Button>
        </Box>
        
        <hr />

        {/* --- Agent Section --- */} 
        {/* Pass necessary props and handlers to AgentSection */}
        <AgentSection 
          agents={agents}
          isLoading={isLoading} // Pass loading state if needed by AgentSection
          isSaving={isSaving} // Pass saving state
          businessId={businessId}
          onEditAgent={handleEditAgent} 
          onDeleteAgent={handleDeleteAgent}
          onNavigateToStages={navigateToStageManagement} 
          onAddAgent={() => { setEditingAgent(null); setIsEditingAgent(true); }} // Open dialog for new agent
          handleSnackbarOpen={handleSnackbarOpen} // Pass snackbar handler
        />

        {/* --- Dialog for Adding/Editing Agent --- */} 
        <Dialog open={isEditingAgent} onClose={handleAgentDialogClose} fullWidth maxWidth="sm">
          <DialogTitle>{editingAgent ? 'Edit Agent' : 'Add New Agent'}</DialogTitle>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              name="agent_name"
              label="Agent Name"
              type="text"
              fullWidth
              variant="standard"
              value={editingAgent ? editingAgent.agent_name : newAgentData.agent_name}
              onChange={handleAgentFormChange}
              required
              disabled={isSaving}
            />
            <TextField
              margin="dense"
              name="agent_description"
              label="Agent Description"
              type="text"
              fullWidth
              variant="standard"
              multiline
              rows={3}
              value={editingAgent ? editingAgent.agent_description : newAgentData.agent_description}
              onChange={handleAgentFormChange}
              disabled={isSaving}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={handleAgentDialogClose} disabled={isSaving}>Cancel</Button>
            <Button 
              onClick={handleAgentFormSubmit} 
              variant="contained" 
              disabled={isSaving || !(editingAgent || newAgentData).agent_name?.trim()} // Disable if name empty
            >
              {isSaving ? <CircularProgress size={24} /> : (editingAgent ? 'Save Changes' : 'Create Agent')}
            </Button>
          </DialogActions>
        </Dialog>

      </Paper>

      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={6000} 
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>

    </Container>
  );
}

export default BusinessDetailsView;


================================================================================
File: FilteredStageListView.jsx
Path: .\front-end\src\components\FilteredStageListView\FilteredStageListView.jsx
Size: 10383
Modified: 2025-04-06T23:22:37.619185
Created: 2025-04-02T20:42:36.371776
Hash: cd7d2582062d516638ae8dc871a0053587ab716b9d70225061344f7abb1bbd9f
Lines: 246
================================================================================
import React, { useState, useEffect } from 'react';
// Import routing hooks
import { useLocation, useNavigate } from 'react-router-dom';

// Define your backend API base URL
const API_BASE_URL = 'http://localhost:5000';

function FilteredStageListView() {
    const [stages, setStages] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const [contextAgentId, setContextAgentId] = useState(null); // agent_id or 'null' for general
    const [contextAgentName, setContextAgentName] = useState('General'); // For display
    const navigate = useNavigate();
    const location = useLocation();

    // Get business and agent ID from query params
    const queryParams = new URLSearchParams(location.search);
    const businessId = queryParams.get('business_id') || localStorage.getItem('businessId');
    const agentIdParam = queryParams.get('agent_id') || '';
    
    // Fetch agent details when agent_id is available
    useEffect(() => {
        const fetchAgentDetails = async () => {
            if (!agentIdParam || agentIdParam === 'null' || agentIdParam === '') {
                setContextAgentId('');
                setContextAgentName('General');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/agents/${agentIdParam}?business_id=${businessId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch agent details');
                }
                
                const agentData = await response.json();
                setContextAgentId(agentIdParam);
                setContextAgentName(agentData.agent_name || `Agent ${agentIdParam}`);
            } catch (err) {
                console.error("Error fetching agent details:", err);
                setContextAgentId(agentIdParam);
                setContextAgentName(`Agent ${agentIdParam}`); // Fallback
            }
        };
        
        fetchAgentDetails();
    }, [agentIdParam, businessId]);

    // Fetch stages when businessId or contextAgentId is determined
    useEffect(() => {
        const fetchStages = async () => {
            if (!businessId) { 
                 setError("Business ID not available.");
                 setIsLoading(false);
                 return;
            }

            setIsLoading(true);
            setError(null);
            console.log(`Fetching stages for business ID: ${businessId}, Agent Context: ${contextAgentId || 'General'}`);

            // Construct the URL with the agent_id filter
            let url = `${API_BASE_URL}/stages?business_id=${businessId}`;
            if (contextAgentId) {
                url += `&agent_id=${contextAgentId}`;
            }

            try {
                const response = await fetch(url, {
                    method: 'GET',
                    credentials: 'include', // Send cookies
                    headers: {
                        'Accept': 'application/json',
                    },
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`HTTP error ${response.status}: ${errorData.message || 'Failed to fetch stages'}`);
                }

                const fetchedStages = await response.json();
                setStages(fetchedStages);

            } catch (err) {
                console.error("Error fetching stages:", err);
                setError(err.message || "An unexpected error occurred while fetching stages.");
                setStages([]);
            } finally {
                setIsLoading(false);
            }
        };

        if (businessId) {
            fetchStages();
        }

    }, [businessId, contextAgentId]); // Refetch if business or agent context changes

    const handleAddStage = () => {
        console.log(`Navigate to Add Stage form for agent context: ${contextAgentId}`);
         // TODO: Use navigate to go to the Add/Edit Stage form, passing context
         // Example: navigate(`/stages/new?agent_id=${contextAgentId}`);
    };

    const handleEditStage = (stageId) => {
        console.log(`Navigate to Edit Stage form for stage: ${stageId}, agent context: ${contextAgentId}`);
        // TODO: Use navigate
        // Example: navigate(`/stages/edit/${stageId}?agent_id=${contextAgentId}`);
    };

    const handleDeleteStage = async (stageId, stageName) => {
        if (!window.confirm(`Are you sure you want to delete the stage "${stageName}"?`)) {
            return;
        }

        console.log(`Deleting stage: ${stageId} with businessId: ${businessId}`);
        setError(null); // Clear previous errors

        try {
             // Make sure we have a business ID
             if (!businessId) {
                 throw new Error("Business ID is required for deletion");
             }
             
             // Get the business API key from localStorage for authorization
             const businessApiKey = localStorage.getItem('businessApiKey');
             if (!businessApiKey) {
                 throw new Error("Business API Key is required for deletion");
             }
             
             // Note: DELETE request needs business_id in query args or body for the backend endpoint
             const deleteUrl = `${API_BASE_URL}/stages/${stageId}?business_id=${businessId}`;
             console.log(`Making DELETE request to: ${deleteUrl}`);
             
             const response = await fetch(deleteUrl, {
                 method: 'DELETE',
                 credentials: 'include',
                 headers: {
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${businessApiKey}`
                 }
             });

             console.log(`Delete response status: ${response.status}`);
             
             // Handle response based on status code
             if (response.status === 204) {
                // 204 No Content is a success response for DELETE
                console.log(`Stage ${stageId} deleted successfully with 204 response.`);
                // Remove stage from local state
                setStages(prevStages => prevStages.filter(s => s.stage_id !== stageId));
                return; // Exit successfully
             } else if (response.status === 200) {
                // Some APIs return 200 OK for successful DELETE
                console.log(`Stage ${stageId} deleted successfully with 200 response.`);
                // Remove stage from local state
                setStages(prevStages => prevStages.filter(s => s.stage_id !== stageId));
                return; // Exit successfully
             } else if (!response.ok) {
                // Try to get error details from response body
                const errorText = await response.text();
                console.error(`Failed to delete stage. Status: ${response.status}, Response: ${errorText}`);
                
                try {
                    const errorData = JSON.parse(errorText);
                    throw new Error(`Failed to delete stage: ${errorData.error || errorData.message || 'Unknown error'}`);
                } catch (parseError) {
                    throw new Error(`Failed to delete stage: HTTP error ${response.status}`);
                }
             }

        } catch (err) {
             console.error("Error deleting stage:", err);
             setError(err.message || "An unexpected error occurred while deleting the stage.");
        }
    };


    if (isLoading) {
        return <div>Loading stages for {contextAgentName}...</div>;
    }

    // Display error prominently
    if (error) {
        return <div style={{ color: 'red' }}>Error: {error}</div>;
    }

    return (
        <div>
            {/* Display which agent context we are viewing */}
            <h2>Manage Stages for: {contextAgentName}</h2>

            {/* Add New Stage Button */}
            {/* TODO: Use Link or navigate onClick */}
            <button onClick={handleAddStage} style={{ marginBottom: '15px' }}>
                Add New Stage
            </button>

             {/* TODO: Improve table styling */}
            <table border="1" style={{ width: '100%', borderCollapse: 'collapse' }}>
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Created At</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {stages.length > 0 ? (
                        stages.map(stage => (
                            <tr key={stage.stage_id}>
                                <td>{stage.stage_name}</td>
                                <td>{stage.stage_type}</td>
                                <td>{stage.stage_description}</td>
                                <td>{new Date(stage.created_at).toLocaleString()}</td>
                                <td>
                                     {/* TODO: Use Link or navigate onClick */}
                                    <button onClick={() => handleEditStage(stage.stage_id)} style={{ marginRight: '5px' }}>
                                        Edit
                                    </button>
                                    <button onClick={() => handleDeleteStage(stage.stage_id, stage.stage_name)}>
                                        Delete
                                    </button>
                                </td>
                            </tr>
                        ))
                    ) : (
                        <tr>
                            <td colSpan="5" style={{ textAlign: 'center' }}>No stages found for this context.</td>
                        </tr>
                    )}
                </tbody>
            </table>
        </div>
    );
}

export default FilteredStageListView;


================================================================================
File: BusinessSection.js
Path: .\front-end\src\components\teste\BusinessSection.js
Size: 1259
Modified: 2025-04-02T01:33:57.512567
Created: 2025-04-02T01:33:55.058997
Hash: d63ad8838c58f1d2014cbd66e4425fc80c5c0565208ff1aaeced7adac50843c7
Lines: 46
================================================================================
import React from 'react';
import useBusiness from '../../hooks/useBusiness';
import { Box, Typography, Paper } from '@mui/material';

const BusinessSection = ({ handleSnackbarOpen }) => {
  const { businessDetails, isLoading, error } = useBusiness(handleSnackbarOpen);

  if (isLoading) {
    return (
      <Paper elevation={1} sx={{ p: 2, my: 2 }}>
        <Typography>Loading Business Details...</Typography>
      </Paper>
    );
  }

  if (error) {
    return (
      <Paper elevation={1} sx={{ p: 2, my: 2 }}>
        <Typography color="error">Error loading business details</Typography>
      </Paper>
    );
  }

  if (!businessDetails) {
    return (
      <Paper elevation={1} sx={{ p: 2, my: 2 }}>
        <Typography>Business details will load here</Typography>
      </Paper>
    );
  }

  return (
    <Paper elevation={1} sx={{ p: 2, my: 2 }}>
      <Box>
        <Typography variant="h6" gutterBottom>
          {businessDetails.name}
        </Typography>
        <Typography>{businessDetails.address}</Typography>
        <Typography>{businessDetails.phone}</Typography>
        <Typography>{businessDetails.email}</Typography>
      </Box>
    </Paper>
  );
};

export default BusinessSection; 

================================================================================
File: BusinessSection.test.js
Path: .\front-end\src\components\teste\BusinessSection.test.js
Size: 4707
Modified: 2025-04-05T02:47:11.285933
Created: 2025-04-01T07:16:45.900497
Hash: 5f29c23257ea17304b7ad62a253b4e38dd8cb115865b08aec7b84d9eea395672
Lines: 146
================================================================================
import React from 'react';
import { screen, waitFor, fireEvent } from '@testing-library/react';
import { render } from '../../test-utils';
import '@testing-library/jest-dom';
import BusinessSection from '../BusinessSection';

// Mock the useBusiness hook
jest.mock('../../hooks/useBusiness', () => ({
  __esModule: true,
  default: jest.fn()
}));

describe('BusinessSection', () => {
  const mockHandleSnackbarOpen = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock localStorage
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
        clear: jest.fn()
      },
      writable: true
    });
    
    // Mock localStorage to return a valid business ID
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      return null;
    });
    
    // Clear cookies
    document.cookie = '';
  });

  it('displays loading state initially', async () => {
    require('../../hooks/useBusiness').default.mockImplementation(() => ({
      businessDetails: null,
      isLoading: true,
      error: null
    }));

    render(<BusinessSection handleSnackbarOpen={mockHandleSnackbarOpen} />);
    await screen.findByTestId('loading-state');
  });

  it('renders business details when loaded', async () => {
    const mockBusinessDetails = {
      business_name: 'Test Business',
      address: '123 Test St',
      phone: '123-456-7890',
      email: 'test@business.com'
    };

    require('../../hooks/useBusiness').default.mockImplementation(() => ({
      businessDetails: mockBusinessDetails,
      isLoading: false,
      error: null
    }));

    render(<BusinessSection handleSnackbarOpen={mockHandleSnackbarOpen} />);
    await screen.findByTestId('business-details');
    expect(screen.getByText(mockBusinessDetails.business_name)).toBeInTheDocument();
  });

  it('renders error state', async () => {
    const errorMessage = 'Failed to load business details';
    require('../../hooks/useBusiness').default.mockImplementation(() => ({
      businessDetails: null,
      isLoading: false,
      error: errorMessage
    }));

    render(<BusinessSection handleSnackbarOpen={mockHandleSnackbarOpen} />);
    await screen.findByTestId('error-state');
    expect(screen.getByText(new RegExp(errorMessage))).toBeInTheDocument();
  });

  it('renders empty state when no details available', async () => {
    require('../../hooks/useBusiness').default.mockImplementation(() => ({
      businessDetails: null,
      isLoading: false,
      error: null
    }));

    render(<BusinessSection handleSnackbarOpen={mockHandleSnackbarOpen} />);
    await screen.findByTestId('empty-state');
  });
  
  it('passes business ID from localStorage to useBusiness hook', async () => {
    // Spy on the useBusiness hook
    const useBusiness = require('../../hooks/useBusiness').default;
    
    render(<BusinessSection handleSnackbarOpen={mockHandleSnackbarOpen} />);
    
    // Verify hook was called with business ID from localStorage
    expect(useBusiness).toHaveBeenCalledWith('test-business-id');
  });
  
  it('shows credential error when business ID is missing', async () => {
    // Mock localStorage to return no business ID
    window.localStorage.getItem.mockImplementation(() => null);
    
    require('../../hooks/useBusiness').default.mockImplementation(() => ({
      businessDetails: null,
      isLoading: false,
      error: 'Business ID is required'
    }));
    
    render(<BusinessSection handleSnackbarOpen={mockHandleSnackbarOpen} />);
    
    // Verify error message
    await waitFor(() => {
      expect(mockHandleSnackbarOpen).toHaveBeenCalledWith(
        'Business ID is required. Please check your configuration.',
        'error'
      );
    });
  });
  
  it('handles refresh button click', async () => {
    const mockRefresh = jest.fn();
    
    require('../../hooks/useBusiness').default.mockImplementation(() => ({
      businessDetails: null,
      isLoading: false,
      error: 'Failed to load',
      refreshBusinessDetails: mockRefresh
    }));
    
    render(<BusinessSection handleSnackbarOpen={mockHandleSnackbarOpen} />);
    
    // Find and click refresh button
    const refreshButton = await screen.findByTestId('refresh-button');
    fireEvent.click(refreshButton);
    
    // Verify refresh function was called
    expect(mockRefresh).toHaveBeenCalled();
  });
});


================================================================================
File: TemplateSection.test.js
Path: .\front-end\src\components\teste\TemplateSection.test.js
Size: 5204
Modified: 2025-04-05T02:58:44.808519
Created: 2025-04-01T07:11:44.512485
Hash: 6c2578d5c5517c990f32e0ff174aa08d721d8c26e73d062f5d29efa92629566e
Lines: 165
================================================================================
import React from 'react';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import { render } from '../../test-utils';
import '@testing-library/jest-dom';
import TemplateSection from '../TemplateSection';

// Mock console.log to suppress useEffect logs
const originalConsoleLog = console.log;
beforeAll(() => {
  console.log = jest.fn();
});

afterAll(() => {
  console.log = originalConsoleLog;
});

// Mock API calls
jest.mock('../../services/api', () => ({
  createTemplate: jest.fn(),
  fetchTemplateDetails: jest.fn(),
}));

describe('TemplateSection', () => {
  const mockSetTemplateID = jest.fn();
  const mockSetTemplateName = jest.fn();
  const mockSetTemplateText = jest.fn();
  const mockCreateTemplate = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock localStorage
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
        clear: jest.fn()
      },
      writable: true
    });
    
    // Mock localStorage to return a valid business ID
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      return null;
    });
    
    // Clear cookies
    document.cookie = '';
  });

  const renderComponent = (props = {}) => {
    return render(
      <TemplateSection
        templateID=""
        setTemplateID={mockSetTemplateID}
        templateName=""
        setTemplateName={mockSetTemplateName}
        templateText=""
        setTemplateText={mockSetTemplateText}
        createTemplate={mockCreateTemplate}
        businessId="test-business-id"
        {...props}
      />
    );
  };

  it('renders template section with correct title', async () => {
    renderComponent();
    expect(await screen.findByTestId('template-section-title')).toHaveTextContent('Template Management');
  });

  it('renders template ID input field', async () => {
    renderComponent();
    expect(await screen.findByTestId('template-id-input')).toBeInTheDocument();
  });

  it('updates template ID when input changes', async () => {
    renderComponent();
    const input = await screen.findByTestId('template-id-input');
    const inputElement = input.querySelector('input');
    await waitFor(() => {
      fireEvent.change(inputElement, { target: { value: 'test-template' } });
    });
    expect(mockSetTemplateID).toHaveBeenCalledWith('test-template');
  });

  it('renders template text textarea', async () => {
    renderComponent();
    expect(await screen.findByTestId('template-text-input')).toBeInTheDocument();
  });

  it('updates template content when textarea changes', async () => {
    renderComponent();
    const textareaContainer = await screen.findByTestId('template-text-input');
    const textareaElement = textareaContainer.querySelector('textarea');
    await waitFor(() => {
      fireEvent.change(textareaElement, { target: { value: 'Test content' } });
    });
    expect(mockSetTemplateText).toHaveBeenCalledWith('Test content');
  });

  it('renders create template button', async () => {
    renderComponent();
    expect(await screen.findByTestId('create-template-button')).toHaveTextContent('Create Template');
  });

  it('calls createTemplate when create button is clicked', async () => {
    renderComponent();
    const button = await screen.findByTestId('create-template-button');
    fireEvent.click(button);
    expect(mockCreateTemplate).toHaveBeenCalled();
  });
  
  it('checks for business ID in localStorage before template operations', async () => {
    // Mock localStorage to return no business ID
    window.localStorage.getItem.mockImplementation(() => null);
    
    const component = renderComponent();
    const button = await screen.findByTestId('create-template-button');
    
    // Create a spy on the console.error method
    const consoleSpy = jest.spyOn(console, 'error');
    
    // Click create button without a business ID
    fireEvent.click(button);
    
    // Verify error is logged
    expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Business ID is required'));
    
    // Clean up
    consoleSpy.mockRestore();
  });
  
  it('includes business ID from props when creating template', async () => {
    renderComponent({ businessId: 'custom-business-id' });
    const button = await screen.findByTestId('create-template-button');
    
    fireEvent.click(button);
    
    // Verify createTemplate was called with business ID
    expect(mockCreateTemplate).toHaveBeenCalledWith(
      expect.objectContaining({
        business_id: 'custom-business-id'
      })
    );
  });
  
  it('falls back to localStorage business ID when not in props', async () => {
    renderComponent({ businessId: undefined });
    const button = await screen.findByTestId('create-template-button');
    
    fireEvent.click(button);
    
    // Verify createTemplate was called with business ID from localStorage
    expect(mockCreateTemplate).toHaveBeenCalledWith(
      expect.objectContaining({
        business_id: 'test-business-id'
      })
    );
  });
});


================================================================================
File: UserSection.test.js
Path: .\front-end\src\components\teste\UserSection.test.js
Size: 5826
Modified: 2025-04-05T02:47:40.892933
Created: 2025-04-01T07:13:01.577311
Hash: 668118d8db1ac912eb407df69df27c1b0f9be3f3bb187574f95f5631b3118797
Lines: 186
================================================================================
import React from 'react';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import { render } from '../../test-utils';
import '@testing-library/jest-dom';
import UserSection from '../UserSection';

describe('UserSection', () => {
  const mockSetFirstName = jest.fn();
  const mockSetLastName = jest.fn();
  const mockSetEmail = jest.fn();
  const mockSetPhone = jest.fn();
  const mockCreateUser = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock localStorage
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
        clear: jest.fn()
      },
      writable: true
    });
    
    // Mock localStorage to return a valid business ID
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      if (key === 'userId') return 'test-user-id';
      return null;
    });
    
    // Clear cookies
    document.cookie = '';
    
    // Mock fetch API
    global.fetch = jest.fn();
  });
  
  afterEach(() => {
    jest.resetAllMocks();
  });

  const renderComponent = (props = {}) => {
    return render(
      <UserSection
        firstName=""
        setFirstName={mockSetFirstName}
        lastName=""
        setLastName={mockSetLastName}
        email=""
        setEmail={mockSetEmail}
        phone=""
        setPhone={mockSetPhone}
        createUser={mockCreateUser}
        businessId="test-business-id"
        {...props}
      />
    );
  };

  it('renders user section with correct title', () => {
    renderComponent();
    expect(screen.getByText('User Management')).toBeInTheDocument();
  });

  it('updates first name on input change', () => {
    renderComponent();
    const input = screen.getByLabelText('First Name');
    fireEvent.change(input, { target: { value: 'John' } });
    expect(mockSetFirstName).toHaveBeenCalledWith('John');
  });

  it('renders create user button', () => {
    renderComponent();
    expect(screen.getByRole('button', { name: 'Create User' })).toBeInTheDocument();
  });
  
  it('includes business ID when creating a user', async () => {
    renderComponent();
    
    // Fill form fields
    fireEvent.change(screen.getByLabelText('First Name'), { target: { value: 'John' } });
    fireEvent.change(screen.getByLabelText('Last Name'), { target: { value: 'Doe' } });
    fireEvent.change(screen.getByLabelText('Email'), { target: { value: 'john@example.com' } });
    fireEvent.change(screen.getByLabelText('Phone'), { target: { value: '555-1234' } });
    
    // Mock successful API response
    global.fetch.mockImplementationOnce(() => 
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ user_id: 'new-user-id' })
      })
    );
    
    // Click create button
    fireEvent.click(screen.getByRole('button', { name: 'Create User' }));
    
    // Verify createUser was called with business ID
    await waitFor(() => {
      expect(mockCreateUser).toHaveBeenCalledWith(
        expect.objectContaining({
          business_id: 'test-business-id'
        })
      );
    });
  });
  
  it('falls back to localStorage business ID when not in props', async () => {
    renderComponent({ businessId: undefined });
    
    // Fill form fields
    fireEvent.change(screen.getByLabelText('First Name'), { target: { value: 'John' } });
    fireEvent.change(screen.getByLabelText('Last Name'), { target: { value: 'Doe' } });
    
    // Click create button
    fireEvent.click(screen.getByRole('button', { name: 'Create User' }));
    
    // Verify createUser was called with business ID from localStorage
    await waitFor(() => {
      expect(mockCreateUser).toHaveBeenCalledWith(
        expect.objectContaining({
          business_id: 'test-business-id'
        })
      );
    });
  });
  
  it('shows error when no business ID is available', async () => {
    // Mock localStorage to return no business ID
    window.localStorage.getItem.mockImplementation(() => null);
    
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
    
    renderComponent({ businessId: undefined });
    
    // Click create button without a business ID
    fireEvent.click(screen.getByRole('button', { name: 'Create User' }));
    
    // Verify error is logged
    await waitFor(() => {
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Business ID is required'));
    });
    
    // Clean up
    consoleSpy.mockRestore();
  });
  
  it('loads user info when userId is available', async () => {
    // Mock API response
    global.fetch.mockImplementationOnce(() => 
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ 
          first_name: 'John',
          last_name: 'Doe',
          email: 'john@example.com',
          phone: '555-1234'
        })
      })
    );
    
    renderComponent();
    
    // Verify user info is fetched and state is updated
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/users/test-user-id'),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': 'test-api-key'
          })
        })
      );
      
      expect(mockSetFirstName).toHaveBeenCalledWith('John');
      expect(mockSetLastName).toHaveBeenCalledWith('Doe');
      expect(mockSetEmail).toHaveBeenCalledWith('john@example.com');
      expect(mockSetPhone).toHaveBeenCalledWith('555-1234');
    });
  });
});


================================================================================
File: Configuration.test.js
Path: .\front-end\src\components\__tests__\Configuration.test.js
Size: 5612
Modified: 2025-04-05T02:48:04.537742
Created: 2025-04-02T00:08:43.250034
Hash: c70dfc913fa032d5f9a4bc14699d3b504790af0daed3d57a764e8b59d7bc74cd
Lines: 181
================================================================================
import React from 'react';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import { render } from '../../test-utils';
import '@testing-library/jest-dom';
import Configuration from '../Configuration';

const mockNavigate = jest.fn();
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => mockNavigate
}));

describe('Configuration Component', () => {
  let mockProps;
  
  beforeEach(() => {
    mockProps = {
      userId: '',
      setUserId: jest.fn(),
      businessId: '',
      setBusinessId: jest.fn(),
      businessApiKey: '',
      setBusinessApiKey: jest.fn(),
      handleSnackbarOpen: jest.fn(),
      handleLogout: jest.fn()
    };
    jest.clearAllMocks();
    global.fetch = jest.fn();
    
    // Mock localStorage
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
        clear: jest.fn()
      },
      writable: true
    });
    
    // Clear cookies
    document.cookie = '';
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  const renderWithProps = (props = mockProps) => {
    return render(<Configuration {...props} />);
  };

  it('renders remaining input fields', async () => {
    renderWithProps();

    const businessKeyInput = await screen.findByTestId('business-api-key-input');
    const userIdInput = await screen.findByTestId('user-id-input');
    const businessIdInput = await screen.findByTestId('business-id-input');

    expect(businessKeyInput).toBeInTheDocument();
    expect(userIdInput).toBeInTheDocument();
    expect(businessIdInput).toBeInTheDocument();
  });

  it('shows validation errors for empty fields', async () => {
    renderWithProps();

    await waitFor(() => {
      fireEvent.click(screen.getByText(/Save Config/i));
    });

    expect(mockProps.handleSnackbarOpen).toHaveBeenCalledWith(
      'Please enter all the configuration values',
      'warning'
    );
  });

  it('handles successful configuration validation', async () => {
    const mockResponse = { ok: true, json: () => Promise.resolve({ success: true }) };
    global.fetch.mockImplementationOnce(() => Promise.resolve(mockResponse));

    const filledProps = {
      ...mockProps,
      userId: 'test_user',
      businessId: 'test_business',
      businessApiKey: 'test_business_key'
    };

    renderWithProps(filledProps);

    await waitFor(() => {
      fireEvent.click(screen.getByText(/Save Config/i));
    });

    expect(global.fetch).toHaveBeenCalledWith('/api/save-config', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({
        userId: 'test_user',
        businessId: 'test_business',
        businessApiKey: 'test_business_key'
      })
    });

    expect(mockProps.handleSnackbarOpen).toHaveBeenCalledWith(
      'Configuration saved successfully',
      'success'
    );
    expect(mockNavigate).toHaveBeenCalledWith('/business');
    
    // Verify credentials are stored in localStorage
    await waitFor(() => {
      expect(window.localStorage.setItem).toHaveBeenCalledWith('businessId', 'test_business');
      expect(window.localStorage.setItem).toHaveBeenCalledWith('businessApiKey', 'test_business_key');
      expect(window.localStorage.setItem).toHaveBeenCalledWith('userId', 'test_user');
    });
  });

  it('handles configuration validation error', async () => {
    const mockResponse = { ok: false, json: () => Promise.resolve({ message: 'Invalid credentials' }) };
    global.fetch.mockImplementationOnce(() => Promise.resolve(mockResponse));

    const filledProps = {
      ...mockProps,
      userId: 'test_user',
      businessId: 'test_business',
      businessApiKey: 'test_business_key'
    };

    renderWithProps(filledProps);

    await waitFor(() => {
      fireEvent.click(screen.getByText(/Save Config/i));
    });

    expect(mockProps.handleSnackbarOpen).toHaveBeenCalledWith(
      'Invalid credentials',
      'error'
    );
    
    // Ensure localStorage is not called when validation fails
    expect(window.localStorage.setItem).not.toHaveBeenCalled();
  });

  it('handles logout correctly', async () => {
    renderWithProps();

    await waitFor(() => {
      fireEvent.click(screen.getByText(/Logout/i));
    });

    expect(mockProps.handleLogout).toHaveBeenCalled();
    expect(mockNavigate).toHaveBeenCalledWith('/login');
    
    // Ensure logout clears credentials from localStorage
    expect(window.localStorage.removeItem).toHaveBeenCalledTimes(3);
  });
  
  it('loads saved credentials from localStorage on mount', async () => {
    // Mock localStorage to return saved credentials
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'saved_business_id';
      if (key === 'businessApiKey') return 'saved_api_key';
      if (key === 'userId') return 'saved_user_id';
      return null;
    });
    
    renderWithProps();
    
    // Verify props are updated with stored values
    await waitFor(() => {
      expect(mockProps.setBusinessId).toHaveBeenCalledWith('saved_business_id');
      expect(mockProps.setBusinessApiKey).toHaveBeenCalledWith('saved_api_key');
      expect(mockProps.setUserId).toHaveBeenCalledWith('saved_user_id');
    });
  });
});

================================================================================
File: StageEditor.test.js
Path: .\front-end\src\components\__tests__\StageEditor.test.js
Size: 11493
Modified: 2025-04-06T00:34:20.474030
Created: 2025-04-05T02:44:55.712826
Hash: 17029429cced4fa091234667a458b29a9f419df6584a0cd9a91f38e0762a528d
Lines: 352
================================================================================
import React from 'react';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import { render } from '../../test-utils';
import '@testing-library/jest-dom';
import StageEditor from '../StageEditor';

// Mock useNavigate and useParams
const mockNavigate = jest.fn();
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => mockNavigate,
  useParams: () => ({ stageId: 'new' }),
  useLocation: () => ({
    search: '?business_id=test-business-id',
    state: {
      businessId: 'test-business-id',
      agentId: 'test-agent-id',
      isNewStage: true
    }
  })
}));

// Mock the API service
jest.mock('../../services/api', () => ({
  createTemplate: jest.fn(),
  fetchTemplateDetails: jest.fn(),
  apiService: {
    getStages: jest.fn(),
    createStage: jest.fn(),
    getBusinessDetails: jest.fn()
  },
  handleApiResponse: jest.fn()
}));

// Mock the cachedFetch utility
jest.mock('../../utils/fetchUtils', () => ({
  cachedFetch: jest.fn().mockImplementation((url, options) => {
    // Mock different responses based on the URL
    if (url.includes('/templates')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([
          {
            template_id: 'template1',
            template_name: 'Test Template',
            template_type: 'stage_selection',
            template_text: 'Test template text'
          }
        ])
      });
    }
    return Promise.resolve({
      ok: true,
      json: () => Promise.resolve([])
    });
  })
}));

// Mock the fetch API
global.fetch = jest.fn();

// Helper to setup successful response
const mockSuccessResponse = (data) => {
  global.fetch.mockImplementationOnce(() => 
    Promise.resolve({
      ok: true,
      json: () => Promise.resolve(data)
    })
  );
};

// Helper to setup failed response
const mockFailedResponse = (errorMessage) => {
  global.fetch.mockImplementationOnce(() => 
    Promise.resolve({
      ok: false,
      json: () => Promise.resolve({ message: errorMessage })
    })
  );
};

describe('StageEditor Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Mock localStorage and cookies
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
        clear: jest.fn()
      },
      writable: true
    });
    
    document.cookie = '';
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  it('displays business credentials form when credentials are missing', async () => {
    // Mock localStorage to return no credentials
    window.localStorage.getItem.mockImplementation(() => null);
    
    await render(<StageEditor />);
    
    expect(screen.getByText('Business Credentials Required')).toBeInTheDocument();
    
    // Use getByPlaceholderText instead of getByLabelText for Material-UI inputs
    expect(screen.getByPlaceholderText('Enter your business ID')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('Enter your business API key')).toBeInTheDocument();
  });

  it('validates credentials before proceeding', async () => {
    // Mock localStorage to return no credentials
    window.localStorage.getItem.mockImplementation(() => null);
    
    await render(<StageEditor />);
    
    // Fill in credentials using placeholder text
    fireEvent.change(screen.getByPlaceholderText('Enter your business ID'), { 
      target: { value: 'test-business-id' } 
    });
    
    fireEvent.change(screen.getByPlaceholderText('Enter your business API key'), { 
      target: { value: 'test-api-key' } 
    });
    
    // Mock the validation response
    mockSuccessResponse({ business_id: 'test-business-id' });
    
    // Click validate button
    fireEvent.click(screen.getByText('Validate & Save Credentials'));
    
    // Expect localStorage and cookie to be set
    await waitFor(() => {
      expect(window.localStorage.setItem).toHaveBeenCalledWith('businessId', 'test-business-id');
      expect(window.localStorage.setItem).toHaveBeenCalledWith('businessApiKey', 'test-api-key');
    });
  });

  it('shows appropriate error when validation fails', async () => {
    // Mock localStorage to return no credentials
    window.localStorage.getItem.mockImplementation(() => null);
    
    // Mock the validation response to fail
    mockFailedResponse('Invalid business ID or API key');
    
    await render(<StageEditor />);
    
    // Wait for the component to initialize
    await waitFor(() => {
      expect(screen.getByText('Business Credentials Required')).toBeInTheDocument();
    });
    
    // Fill in credentials using placeholder text
    fireEvent.change(screen.getByPlaceholderText('Enter your business ID'), { 
      target: { value: 'test-business-id' } 
    });
    
    fireEvent.change(screen.getByPlaceholderText('Enter your business API key'), { 
      target: { value: 'invalid-api-key' } 
    });
    
    // Click validate button
    fireEvent.click(screen.getByText('Validate & Save Credentials'));
    
    // Expect error message
    await waitFor(() => {
      expect(screen.getByText(/Failed to validate credentials/)).toBeInTheDocument();
    });
  });

  it('loads templates when credentials are valid', async () => {
    // Mock localStorage to return valid credentials
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      return null;
    });
    
    // Mock successful validation
    mockSuccessResponse({ business_id: 'test-business-id' });
    
    await render(<StageEditor />);
    
    // Check that templates are loaded
    await waitFor(() => {
      expect(screen.getByText('Stage Information')).toBeInTheDocument();
    });
  });

  it('handles template selection and saving', async () => {
    // Mock localStorage to return valid credentials
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      return null;
    });
    
    // Mock successful validation
    mockSuccessResponse({ business_id: 'test-business-id' });
    
    await render(<StageEditor />);
    
    // Wait for component to initialize
    await waitFor(() => {
      expect(screen.getByText('Stage Information')).toBeInTheDocument();
    });
    
    // Select a template type using the tab
    const stageSelectionTab = screen.getByText('Stage Selection');
    fireEvent.click(stageSelectionTab);
    
    // Check if template options are displayed - use getAllByText and check the first one
    await waitFor(() => {
      const templateElements = screen.getAllByText('Template');
      expect(templateElements.length).toBeGreaterThan(0);
    });
  });

  it('shows appropriate error when template loading fails', async () => {
    // Mock localStorage to return valid credentials
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      return null;
    });
    
    // Mock successful validation but failed template loading
    mockSuccessResponse({ business_id: 'test-business-id' });
    
    // Override the cachedFetch mock for this test
    jest.spyOn(require('../../utils/fetchUtils'), 'cachedFetch')
      .mockImplementationOnce(() => Promise.reject(new Error('Failed to load templates')));
    
    await render(<StageEditor />);
    
    // Check for error message
    await waitFor(() => {
      expect(screen.getByText(/Failed to fetch templates/)).toBeInTheDocument();
    });
  });

  it('saves a template successfully', async () => {
    // Mock localStorage to return valid credentials
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      return null;
    });
    
    // Mock successful validation
    mockSuccessResponse({ business_id: 'test-business-id' });
    
    // Mock templates fetch
    mockSuccessResponse([]);
    
    await render(<StageEditor />);
    
    // Wait for component to initialize
    await waitFor(() => {
      expect(screen.getByText('Stage Selection')).toBeInTheDocument();
    });
    
    // Enter template text
    fireEvent.change(screen.getByPlaceholderText('Enter template text with variables in {curly_braces}'), {
      target: { value: 'Test template content' }
    });
    
    // Mock successful template save
    mockSuccessResponse({ template_id: 'new-template-id' });
    
    // Click save template
    fireEvent.click(screen.getByText('Save Template'));
    
    // Confirm in dialog
    await waitFor(() => {
      expect(screen.getByText(/Are you sure you want to create a new/)).toBeInTheDocument();
    });
    
    fireEvent.click(screen.getByText('Save'));
    
    // Check success message appears
    await waitFor(() => {
      expect(screen.getByText(/template saved successfully/)).toBeInTheDocument();
    });
  });

  it('creates a stage successfully', async () => {
    // Mock localStorage to return valid credentials
    window.localStorage.getItem.mockImplementation((key) => {
      if (key === 'businessId') return 'test-business-id';
      if (key === 'businessApiKey') return 'test-api-key';
      return null;
    });
    
    // Mock successful validation
    mockSuccessResponse({ business_id: 'test-business-id' });
    
    // Mock templates fetch
    mockSuccessResponse([]);
    
    await render(<StageEditor />);
    
    // Wait for component to initialize
    await waitFor(() => {
      expect(screen.getByText('Stage Information')).toBeInTheDocument();
    });
    
    // Find the stage name input by its ID pattern
    const stageNameInput = screen.getByRole('textbox', { name: /stage name/i });
    fireEvent.change(stageNameInput, {
      target: { value: 'Test Stage' }
    });
    
    // Find the stage description input by its role
    const stageDescriptionInput = screen.getByRole('textbox', { name: /stage description/i });
    fireEvent.change(stageDescriptionInput, {
      target: { value: 'Test stage description' }
    });
    
    // Mock successful stage creation
    mockSuccessResponse({ stage_id: 'new-stage-id' });
    
    // Click create stage
    fireEvent.click(screen.getByText('Create Stage'));
    
    // Check that the API was called with correct data
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/stages?business_id=test-business-id'),
        expect.objectContaining({
          method: 'POST',
          body: expect.stringContaining('Test Stage')
        })
      );
    });
    
    // Check success message appears
    await waitFor(() => {
      expect(screen.getByText('Stage created successfully')).toBeInTheDocument();
    });
    
    // Check navigation occurs
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalled();
    });
  });
}); 

================================================================================
File: AuthContext.js
Path: .\front-end\src\contexts\AuthContext.js
Size: 1492
Modified: 2025-04-12T15:34:54.614604
Created: 2025-04-12T15:34:52.039520
Hash: d7cf7c1714163515a1f1455b60f4155017b815d219965ca26625e8adee213466
Lines: 53
================================================================================
import React, { createContext, useContext, useState, useEffect } from 'react';
import { isLoggedIn, getStoredCredentials, logout } from '../services/authService';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userId, setUserId] = useState('');
  const [businessId, setBusinessId] = useState('');
  const [businessApiKey, setBusinessApiKey] = useState('');

  useEffect(() => {
    // Check if user is logged in on component mount
    const loggedIn = isLoggedIn();
    if (loggedIn) {
      const { userId, businessId, businessApiKey } = getStoredCredentials();
      setUserId(userId);
      setBusinessId(businessId);
      setBusinessApiKey(businessApiKey);
      setIsAuthenticated(true);
    }
  }, []);

  const handleLogout = () => {
    logout();
    setUserId('');
    setBusinessId('');
    setBusinessApiKey('');
    setIsAuthenticated(false);
  };

  const value = {
    isAuthenticated,
    userId,
    businessId,
    businessApiKey,
    setUserId,
    setBusinessId,
    setBusinessApiKey,
    setIsAuthenticated,
    handleLogout
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}; 

================================================================================
File: useAgents.js
Path: .\front-end\src\hooks\useAgents.js
Size: 2442
Modified: 2025-04-11T21:31:34.719370
Created: 2025-04-01T16:07:22.238485
Hash: e132ec81410b53f3e82f655fc6862e8728dc6cdcf9cc466bcb968e8d4d981948
Lines: 59
================================================================================
import { useState, useEffect, useCallback } from 'react';
// Assuming an agentService.js file will export fetchAgents
// We might need to create/update this service file later
import { fetchAgents } from '../services/agentService';
import useConfig from './useConfig';
import { normalizeUUID } from './useConfig';

const useAgents = (handleSnackbarOpen) => {
    const [agents, setAgents] = useState([]); // Initialize as empty array
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const { businessId } = useConfig(); // Get businessId from config
    const normalizedBusinessId = normalizeUUID(businessId);

    const fetchAgentsData = useCallback(async () => {
        if (!normalizedBusinessId) {
            setAgents([]); // Clear agents if no businessId
            return;
        }

        setIsLoading(true);
        setError(null);
        console.log(`Fetching agents for business ID: ${normalizedBusinessId}`);

        try {
            // Fetch agents from the API
            const data = await fetchAgents(normalizedBusinessId);
            console.log("Fetched agents:", data);
            // Ensure data is always an array, even if API returns null/undefined
            setAgents(Array.isArray(data) ? data : []);
        } catch (err) {
            console.error("Error fetching agents:", err);
            const errorMessage = err.message || 'Failed to fetch agents';
            setError(errorMessage);
            setAgents([]); // Clear agents on error
             if (handleSnackbarOpen) {
                // Use the extracted error message for the snackbar
                handleSnackbarOpen(`Error fetching agents: ${errorMessage}`, "error");
            }
        } finally {
            setIsLoading(false);
        }
    }, [normalizedBusinessId, handleSnackbarOpen]);

    // useEffect to trigger fetch when businessId changes
    useEffect(() => {
        fetchAgentsData();
    }, [fetchAgentsData]); // Dependency array includes fetchAgents (memoized via useCallback)

    return {
        agents,          // The array of agent objects
        isLoading,       // Boolean indicating if fetch is in progress
        error,           // Error object/message if fetch failed
        refreshAgents: fetchAgentsData // Function to manually trigger a refresh
    };
};

export default useAgents;


================================================================================
File: useBusiness.js
Path: .\front-end\src\hooks\useBusiness.js
Size: 1062
Modified: 2025-04-02T01:21:34.388968
Created: 2025-03-31T00:12:51.044906
Hash: ea67c3e6eb56e214d2681e16005362d65d36ad240b7a44100e34e0dc8b129ad8
Lines: 33
================================================================================
// src/hooks/useBusiness.js
import { useState, useEffect } from 'react';
import axios from 'axios';

const useBusiness = (handleSnackbarOpen) => {
    const [businessDetails, setBusinessDetails] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchBusinessDetails = async () => {
            setIsLoading(true);
            try {
                const response = await axios.get('/api/business');
                setBusinessDetails(response.data);
                setError(null);
            } catch (err) {
                setError(err.message);
                if (handleSnackbarOpen) {
                    handleSnackbarOpen('Failed to load business details', 'error');
                }
            } finally {
                setIsLoading(false);
            }
        };

        fetchBusinessDetails();
    }, [handleSnackbarOpen]);

    return { businessDetails, isLoading, error };
};

export default useBusiness;

================================================================================
File: useConfig.js
Path: .\front-end\src\hooks\useConfig.js
Size: 2651
Modified: 2025-04-12T12:11:16.044154
Created: 2025-03-31T00:34:35.705822
Hash: 08ca0578bd0b9e1b0c22bf0a045d2f0b4ab393fefc02b8973434606da689b7b7
Lines: 71
================================================================================
// src/hooks/useConfig.js
import { useState, useEffect, useCallback } from 'react';
import { API_CONFIG, AUTH_CONFIG } from '../config';

// Normalize UUID to ensure it passes backend validation
export const normalizeUUID = (uuid) => {
  if (!uuid) return null;
  
  try {
    // Convert to lowercase and trim whitespace
    const normalizedUUID = uuid.toLowerCase().trim();
    // Check if it's a valid UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
    
    if (uuidRegex.test(normalizedUUID)) {
      return normalizedUUID;
    }
    
    // Try to add dashes if missing but the uuid has the right length
    if (normalizedUUID.length === 32 && /^[0-9a-f]{32}$/.test(normalizedUUID)) {
      const formatted = `${normalizedUUID.slice(0, 8)}-${normalizedUUID.slice(8, 12)}-${normalizedUUID.slice(12, 16)}-${normalizedUUID.slice(16, 20)}-${normalizedUUID.slice(20)}`;
      if (uuidRegex.test(formatted)) {
        console.log(`Reformatted UUID from ${normalizedUUID} to ${formatted}`);
        return formatted;
      }
    }
    
    console.warn('Invalid UUID format:', uuid);
    return uuid; // Return original if not matching pattern
  } catch (error) {
    console.error('Error normalizing UUID:', error);
    return uuid; // Return original on error
  }
};

const useConfig = () => {
    // API keys should not be stored in localStorage. Initialize as empty.
    // They will be handled via httpOnly cookies set by the backend.
    const [apiKey, setApiKey] = useState(''); 
    const [userId, setUserId] = useState(localStorage.getItem('userId') || '');
    const [businessId, setBusinessId] = useState(localStorage.getItem('businessId') || '');
    // Business API key should also not be stored in localStorage.
    const [businessApiKey, setBusinessApiKey] = useState(''); 

    // No need to memoize simple setters like this unless performance profiling proves it necessary.
    // const memoizedSetApiKey = useCallback((newApiKey) => {
    //     setApiKey(newApiKey);
    // }, []);

    // Persist userId and businessId to localStorage when they change
    useEffect(() => {
        localStorage.setItem('userId', userId);
    }, [userId]);

    useEffect(() => {
        localStorage.setItem('businessId', businessId);
    }, [businessId]);

    return {
        apiKey,
        setApiKey, // Return the direct setter
        userId,
        setUserId,
        businessId,
        setBusinessId,
        businessApiKey,
        setBusinessApiKey, // Return the direct setter
    };
};

export default useConfig;

================================================================================
File: useStageDetails.js
Path: .\front-end\src\hooks\useStageDetails.js
Size: 2380
Modified: 2025-04-01T16:19:13.853571
Created: 2025-04-01T16:19:01.654128
Hash: 4e11656d2c5f24d36466aed84cf16de142282f4dbfa6154a72e98facd3505ac9
Lines: 59
================================================================================
import { useState, useEffect, useCallback } from 'react';
// Assuming a stageService.js file will export fetchStageDetails
// We might need to create/update this service file later
import { fetchStageDetails as fetchStageDetailsApi } from '../services/stageService';

// This hook takes the stageId to fetch details for
const useStageDetails = (stageId, handleSnackbarOpen) => {
    const [stageDetails, setStageDetails] = useState(null); // Initialize as null
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);

    const fetchDetails = useCallback(async () => {
        // Only fetch if a stage ID is provided
        if (!stageId) {
            setStageDetails(null); // Clear details if no stageId
            return;
        }

        setIsLoading(true);
        setError(null);
        console.log(`Fetching details for stage ID: ${stageId}`);

        try {
            // API key relies on httpOnly cookie
            const data = await fetchStageDetailsApi(stageId);
            console.log("Fetched stage details:", data);
            setStageDetails(data); // Store the fetched object
            // Optional: Snackbar notification
            // if (handleSnackbarOpen) {
            //      handleSnackbarOpen("Stage details loaded!", "info");
            // }
        } catch (err) {
            console.error("Error fetching stage details:", err);
            const errorMessage = err.message || 'Failed to fetch stage details';
            setError(errorMessage);
            setStageDetails(null); // Clear details on error
             if (handleSnackbarOpen) {
                handleSnackbarOpen(`Error fetching stage details: ${errorMessage}`, "error");
            }
        } finally {
            setIsLoading(false);
        }
    }, [stageId, handleSnackbarOpen]); // Depend on stageId

    // useEffect to trigger fetch when stageId changes
    useEffect(() => {
        fetchDetails();
    }, [fetchDetails]);

    return {
        stageDetails,    // The stage detail object (or null)
        isLoading,       // Boolean indicating if fetch is in progress
        error,           // Error object/message if fetch failed
        refreshDetails: fetchDetails // Function to manually trigger a refresh
    };
};

export default useStageDetails;


================================================================================
File: useStages.js
Path: .\front-end\src\hooks\useStages.js
Size: 2501
Modified: 2025-04-01T16:13:32.566071
Created: 2025-04-01T16:12:45.002605
Hash: 973692c43de47a573794a50ac8d5ac9ef3e1475d15db0e13dfccc144310ecffa
Lines: 61
================================================================================
// src/hooks/useStages.js
import { useState, useEffect, useCallback } from 'react';
// Assuming a stageService.js file will export fetchStages
// We might need to create/update this service file later
import { fetchStages as fetchStagesApi } from '../services/stageService';

// This hook takes the selectedAgentId as an argument
const useStages = (selectedAgentId, handleSnackbarOpen) => {
    const [stages, setStages] = useState([]); // Initialize as empty array
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);

    const fetchStages = useCallback(async () => {
        // Only fetch if an agent is selected
        if (!selectedAgentId) {
            setStages([]); // Clear stages if no agent is selected
            return;
        }

        setIsLoading(true);
        setError(null);
        console.log(`Fetching stages for agent ID: ${selectedAgentId}`);

        try {
            // API key relies on httpOnly cookie sent automatically by browser
            const data = await fetchStagesApi(selectedAgentId);
            console.log("Fetched stages:", data);
            // Ensure data is always an array
            setStages(Array.isArray(data) ? data : []);
            // Optional: Snackbar notification
            // if (handleSnackbarOpen) {
            //      handleSnackbarOpen("Stages loaded!", "info");
            // }
        } catch (err) {
            console.error("Error fetching stages:", err);
            const errorMessage = err.message || 'Failed to fetch stages';
            setError(errorMessage);
            setStages([]); // Clear stages on error
             if (handleSnackbarOpen) {
                handleSnackbarOpen(`Error fetching stages: ${errorMessage}`, "error");
            }
        } finally {
            setIsLoading(false);
        }
    }, [selectedAgentId, handleSnackbarOpen]); // Depend on selectedAgentId

    // useEffect to trigger fetch when selectedAgentId changes
    useEffect(() => {
        fetchStages();
    }, [fetchStages]); // Dependency array includes fetchStages (memoized by useCallback)

    return {
        stages,          // The array of stage objects
        isLoading,       // Boolean indicating if fetch is in progress
        error,           // Error object/message if fetch failed
        refreshStages: fetchStages // Function to manually trigger a refresh
    };
};

export default useStages;


================================================================================
File: useTemplates.js
Path: .\front-end\src\hooks\useTemplates.js
Size: 2577
Modified: 2025-04-11T21:54:54.001139
Created: 2025-04-11T21:54:51.823815
Hash: 63d48ed8a0a0fe8915ec9b28ffe2e185d4086562d715ea2c508c3f354ee2e285
Lines: 57
================================================================================
import { useState, useEffect, useCallback } from 'react';
import { fetchTemplates } from '../services/templateService';
import useConfig from './useConfig';
import { normalizeUUID } from './useConfig';

const useTemplates = (handleSnackbarOpen, agentId) => {
    const [templates, setTemplates] = useState([]); // Initialize as empty array
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const { businessId } = useConfig(); // Get businessId from config
    const normalizedBusinessId = normalizeUUID(businessId);
    const normalizedAgentId = normalizeUUID(agentId);

    const fetchTemplatesData = useCallback(async () => {
        if (!normalizedBusinessId || !normalizedAgentId) {
            setTemplates([]); // Clear templates if no businessId or agentId
            return;
        }

        setIsLoading(true);
        setError(null);
        console.log(`Fetching templates for business ID: ${normalizedBusinessId}, agent ID: ${normalizedAgentId}`);

        try {
            // Fetch templates from the API
            const data = await fetchTemplates(normalizedBusinessId, normalizedAgentId);
            console.log("Fetched templates:", data);
            // Ensure data is always an array, even if API returns null/undefined
            setTemplates(Array.isArray(data) ? data : []);
        } catch (err) {
            console.error("Error fetching templates:", err);
            const errorMessage = err.message || 'Failed to fetch templates';
            setError(errorMessage);
            setTemplates([]); // Clear templates on error
            if (handleSnackbarOpen) {
                // Use the extracted error message for the snackbar
                handleSnackbarOpen(`Error fetching templates: ${errorMessage}`, "error");
            }
        } finally {
            setIsLoading(false);
        }
    }, [normalizedBusinessId, normalizedAgentId, handleSnackbarOpen]);

    // useEffect to trigger fetch when businessId or agentId changes
    useEffect(() => {
        fetchTemplatesData();
    }, [fetchTemplatesData]); // Dependency array includes fetchTemplatesData (memoized via useCallback)

    return {
        templates,       // The array of template objects
        isLoading,       // Boolean indicating if fetch is in progress
        error,           // Error object/message if fetch failed
        refreshTemplates: fetchTemplatesData // Function to manually trigger a refresh
    };
};

export default useTemplates; 

================================================================================
File: MessageDebugPage.js
Path: .\front-end\src\pages\MessageDebugPage.js
Size: 6752
Modified: 2025-04-08T22:36:28.443239
Created: 2025-04-08T22:36:25.630930
Hash: 0bcca5ec5633b641a512d195d73085c6483bff83b7c229f215baf0162b5fff4c
Lines: 167
================================================================================
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { Box, Paper, Typography, Grid, CircularProgress, Divider } from '@mui/material';
import { debugService } from '../services/debugService';

// Component to display prompt details
const PromptDisplay = ({ title, prompt, response }) => (
    <Paper sx={{ p: 2, mb: 2 }}>
        <Typography variant="h6" gutterBottom>{title}</Typography>
        <Box sx={{ bgcolor: 'grey.100', p: 2, mb: 2, borderRadius: 1 }}>
            <Typography variant="subtitle2" color="text.secondary">Prompt:</Typography>
            <Typography component="pre" sx={{ whiteSpace: 'pre-wrap', fontFamily: 'monospace' }}>
                {prompt}
            </Typography>
        </Box>
        <Box sx={{ bgcolor: 'grey.100', p: 2, borderRadius: 1 }}>
            <Typography variant="subtitle2" color="text.secondary">Response:</Typography>
            <Typography component="pre" sx={{ whiteSpace: 'pre-wrap', fontFamily: 'monospace' }}>
                {response}
            </Typography>
        </Box>
    </Paper>
);

// Component to display stage navigation
const StageNavigation = ({ stages }) => (
    <Paper sx={{ p: 2, mb: 2 }}>
        <Typography variant="h6" gutterBottom>Stage Navigation</Typography>
        <Box sx={{ display: 'flex', overflowX: 'auto', pb: 1 }}>
            {stages.map((stage, index) => (
                <React.Fragment key={stage.id}>
                    <Box sx={{ 
                        p: 1, 
                        bgcolor: stage.current ? 'primary.main' : 'grey.100',
                        color: stage.current ? 'white' : 'text.primary',
                        borderRadius: 1,
                        minWidth: 'fit-content'
                    }}>
                        <Typography variant="body2">{stage.name}</Typography>
                        <Typography variant="caption" display="block">
                            Confidence: {stage.confidence}
                        </Typography>
                    </Box>
                    {index < stages.length - 1 && (
                        <Box sx={{ display: 'flex', alignItems: 'center', px: 1 }}></Box>
                    )}
                </React.Fragment>
            ))}
        </Box>
    </Paper>
);

// Component to display extracted data
const DataExtraction = ({ data }) => (
    <Paper sx={{ p: 2, mb: 2 }}>
        <Typography variant="h6" gutterBottom>Extracted Data</Typography>
        <Box component="pre" sx={{ 
            bgcolor: 'grey.100', 
            p: 2, 
            borderRadius: 1,
            whiteSpace: 'pre-wrap',
            fontFamily: 'monospace'
        }}>
            {JSON.stringify(data, null, 2)}
        </Box>
    </Paper>
);

// Main debug page component
const MessageDebugPage = () => {
    const { conversationId } = useParams();
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [debugData, setDebugData] = useState(null);
    const [realTimeEvents, setRealTimeEvents] = useState([]);

    useEffect(() => {
        const loadDebugData = async () => {
            try {
                const data = await debugService.getConversationDebug(conversationId);
                setDebugData(data);
            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };

        // Subscribe to real-time events
        const cleanup = debugService.subscribeToDebugEvents(conversationId, (event) => {
            setRealTimeEvents(prev => [...prev, event]);
        });

        loadDebugData();
        return cleanup; // Cleanup subscription on unmount
    }, [conversationId]);

    if (loading) return <CircularProgress />;
    if (error) return <Typography color="error">{error}</Typography>;
    if (!debugData) return <Typography>No debug data available</Typography>;

    return (
        <Box sx={{ p: 3 }}>
            <Typography variant="h4" gutterBottom>
                Message Processing Debug View
            </Typography>
            <Typography variant="subtitle1" gutterBottom>
                Conversation ID: {conversationId}
            </Typography>
            
            <Grid container spacing={3}>
                <Grid item xs={12}>
                    <StageNavigation stages={debugData.stages} />
                </Grid>

                <Grid item xs={12}>
                    <PromptDisplay 
                        title="Stage Selection"
                        prompt={debugData.stageSelection.prompt}
                        response={debugData.stageSelection.response}
                    />
                </Grid>

                <Grid item xs={12}>
                    <PromptDisplay 
                        title="Data Extraction"
                        prompt={debugData.dataExtraction.prompt}
                        response={debugData.dataExtraction.response}
                    />
                </Grid>

                <Grid item xs={12}>
                    <DataExtraction data={debugData.extractedData} />
                </Grid>

                <Grid item xs={12}>
                    <PromptDisplay 
                        title="Response Generation"
                        prompt={debugData.responseGeneration.prompt}
                        response={debugData.responseGeneration.response}
                    />
                </Grid>

                {realTimeEvents.length > 0 && (
                    <Grid item xs={12}>
                        <Paper sx={{ p: 2 }}>
                            <Typography variant="h6" gutterBottom>Real-time Events</Typography>
                            <Box sx={{ maxHeight: 200, overflow: 'auto' }}>
                                {realTimeEvents.map((event, index) => (
                                    <Box key={index} sx={{ mb: 1 }}>
                                        <Typography variant="caption" color="text.secondary">
                                            {new Date(event.timestamp).toLocaleTimeString()}
                                        </Typography>
                                        <Typography>{event.message}</Typography>
                                        <Divider sx={{ my: 1 }} />
                                    </Box>
                                ))}
                            </Box>
                        </Paper>
                    </Grid>
                )}
            </Grid>
        </Box>
    );
};

export default MessageDebugPage; 

================================================================================
File: StageEditorPage.js
Path: .\front-end\src\pages\StageEditorPage.js
Size: 3595
Modified: 2025-04-12T15:08:16.178925
Created: 2025-04-07T00:33:05.136332
Hash: 42813cf495f7a91eb8137a66d39aea40638c08f3d21d1811173ffd1b863c17e4
Lines: 124
================================================================================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { 
  Box, 
  Typography, 
  Paper, 
  Breadcrumbs, 
  Link, 
  Container,
  CircularProgress,
  Alert
} from '@mui/material';
import AddEditStageForm from '../components/AddEditStageForm/AddEditStageForm';
import { getStoredCredentials } from '../utils/authUtils';

const StageEditorPage = () => {
  const { stageId } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [stageName, setStageName] = useState('');
  
  // Get stored credentials
  const { businessId, businessApiKey } = getStoredCredentials();
  
  useEffect(() => {
    // Check if we have the required credentials
    if (!businessId || !businessApiKey) {
      setError('Authentication required. Please log in.');
      setLoading(false);
      return;
    }
    
    // If we're creating a new stage, no need to fetch stage data
    if (stageId === 'new') {
      setLoading(false);
      return;
    }
    
    // Fetch stage data to get the name for the breadcrumb
    const fetchStageData = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/stages/${stageId}?business_id=${businessId}`, {
          headers: {
            'Authorization': `Bearer ${businessApiKey}`
          }
        });
        
        if (!response.ok) {
          throw new Error(`Failed to fetch stage: ${response.status}`);
        }
        
        const data = await response.json();
        setStageName(data.stage_name || 'Unnamed Stage');
      } catch (err) {
        console.error('Error fetching stage:', err);
        setError(`Failed to load stage: ${err.message}`);
      } finally {
        setLoading(false);
      }
    };
    
    fetchStageData();
  }, [stageId, businessId, businessApiKey]);
  
  const handleNavigateBack = () => {
    navigate('/stage-management');
  };
  
  if (loading) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
          <CircularProgress />
        </Box>
      </Container>
    );
  }
  
  if (error) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
        <Box sx={{ mt: 2 }}>
          <Link component="button" variant="body1" onClick={handleNavigateBack}>
            Return to Stage Management
          </Link>
        </Box>
      </Container>
    );
  }
  
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
          <Link 
            component="button" 
            variant="body1" 
            onClick={handleNavigateBack}
            color="inherit"
            underline="hover"
          >
            Stage Management
          </Link>
          <Typography color="text.primary">
            {stageId === 'new' ? 'Create New Stage' : stageName}
          </Typography>
        </Breadcrumbs>
        
        <Typography variant="h4" component="h1" gutterBottom>
          {stageId === 'new' ? 'Create New Stage' : `Edit Stage: ${stageName}`}
        </Typography>
      </Paper>
      
      <AddEditStageForm />
    </Container>
  );
};

export default StageEditorPage; 

================================================================================
File: StageViewPage.jsx
Path: .\front-end\src\pages\StageViewPage.jsx
Size: 1159
Modified: 2025-04-12T16:06:39.755749
Created: 2025-04-08T13:28:27.184806
Hash: 8eb337c8a42427999bcc9ef8ead4a5bb1993a019e9b2a5c2471acfc5c0b82c42
Lines: 33
================================================================================
import React from 'react';
import { useParams, Link } from 'react-router-dom';
import { Box, Breadcrumbs, Typography, Button } from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import StageView from '../components/StageView';

function StageViewPage() {
    const { stageId } = useParams();

    return (
        <Box>
            <Box mb={3} display="flex" justifyContent="space-between" alignItems="center">
                <Breadcrumbs aria-label="breadcrumb">
                    <Link to="/stages" style={{ textDecoration: 'none', color: 'inherit' }}>
                        Stage Management
                    </Link>
                    <Typography color="text.primary">View Stage</Typography>
                </Breadcrumbs>
                <Button
                    variant="outlined"
                    startIcon={<ArrowBackIcon />}
                    component={Link}
                    to="/stages"
                >
                    Back to Stages
                </Button>
            </Box>
            <StageView />
        </Box>
    );
}

export default StageViewPage; 

================================================================================
File: agentService.js
Path: .\front-end\src\services\agentService.js
Size: 4099
Modified: 2025-04-11T21:31:56.293208
Created: 2025-04-01T16:29:07.252629
Hash: 78e50d84e22958b0a29480d4ab95653cfbcd5cb2ed39c64d99ea5991354fc324
Lines: 133
================================================================================
// src/services/agentService.js
import { API_CONFIG } from '../config';
import { getAuthHeaders } from '../services/authService';
import { normalizeUUID } from '../hooks/useConfig';

// Fetch agents for a business
export const fetchAgents = async (businessId) => {
  try {
    const normalizedBusinessId = normalizeUUID(businessId);
    console.log(`Fetching agents for business: ${normalizedBusinessId}`);
    const response = await fetch(`${API_CONFIG.BASE_URL}/agents?business_id=${normalizedBusinessId}`, {
      method: 'GET',
      credentials: 'include',
      headers: getAuthHeaders()
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to fetch agents');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in fetchAgents:', error);
    throw error;
  }
};

// Create a new agent
export const createAgent = async (agentData) => {
  try {
    // Make sure business_id is normalized
    const normalizedData = {
      ...agentData,
      business_id: normalizeUUID(agentData.business_id)
    };
    
    console.log('Creating agent:', normalizedData);
    const response = await fetch(`${API_CONFIG.BASE_URL}/agents`, {
      method: 'POST',
      credentials: 'include',
      headers: getAuthHeaders(),
      body: JSON.stringify(normalizedData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to create agent');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in createAgent:', error);
    throw error;
  }
};

// Update an existing agent
export const updateAgent = async (agentId, agentData) => {
  try {
    // Make sure business_id is normalized
    const normalizedData = {
      ...agentData,
      business_id: normalizeUUID(agentData.business_id)
    };
    
    console.log(`Updating agent ${agentId}:`, normalizedData);
    const response = await fetch(`${API_CONFIG.BASE_URL}/agents/${agentId}`, {
      method: 'PUT',
      credentials: 'include',
      headers: getAuthHeaders(),
      body: JSON.stringify(normalizedData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to update agent');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in updateAgent:', error);
    throw error;
  }
};

// Delete an agent
export const deleteAgent = async (agentId, businessId) => {
  try {
    const normalizedBusinessId = normalizeUUID(businessId);
    console.log(`Deleting agent ${agentId} for business ${normalizedBusinessId}`);
    const response = await fetch(`${API_CONFIG.BASE_URL}/agents/${agentId}?business_id=${normalizedBusinessId}`, {
      method: 'DELETE',
      credentials: 'include',
      headers: getAuthHeaders(),
      body: JSON.stringify({ business_id: normalizedBusinessId })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to delete agent');
    }

    return true;
  } catch (error) {
    console.error('Error in deleteAgent:', error);
    throw error;
  }
};

// Get a specific agent
export const getAgent = async (agentId, businessId) => {
  try {
    const normalizedBusinessId = normalizeUUID(businessId);
    console.log(`Fetching agent ${agentId} for business ${normalizedBusinessId}`);
    const response = await fetch(`${API_CONFIG.BASE_URL}/agents/${agentId}?business_id=${normalizedBusinessId}`, {
      method: 'GET',
      credentials: 'include',
      headers: getAuthHeaders()
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to fetch agent');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in getAgent:', error);
    throw error;
  }
};


================================================================================
File: api.js
Path: .\front-end\src\services\api.js
Size: 3184
Modified: 2025-04-09T12:43:27.798117
Created: 2025-04-01T13:51:20.886389
Hash: 8cb513c3131e10735f97dc19e77d43cae619ed350c37d8cbbabe4045b3829f31
Lines: 106
================================================================================
import { API_CONFIG } from '../config';
import { getAuthHeaders, getStoredCredentials } from './authService';

/**
 * Standardized handler for API responses
 * @param {Response} response - The fetch Response object
 * @returns {Promise<any>} - The parsed response data
 * @throws {Error} - Throws an error with details from the response if not ok
 */
export const handleApiResponse = async (response) => {
  // Handle non-OK responses
  if (!response.ok) {
    // Try to get detailed error from response
    try {
      const errorData = await response.json();
      throw new Error(errorData.message || errorData.error || `API error: ${response.status}`);
    } catch (jsonError) {
      // If response isn't valid JSON, use status text
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }
  }
  
  // For successful responses, parse JSON or return empty object
  try {
    return await response.json();
  } catch (error) {
    // Some successful responses may not have a body (e.g., 204 No Content)
    return {};
  }
};

/**
 * Make an API request with authentication
 * @param {string} endpoint - API endpoint
 * @param {Object} options - Request options
 * @returns {Promise<any>} - Response data
 */
const apiRequest = async (endpoint, options = {}) => {
  const url = `${API_CONFIG.BASE_URL}${endpoint}`;
  const defaultOptions = {
    headers: getAuthHeaders(),
    credentials: 'include',
  };

  const response = await fetch(url, { ...defaultOptions, ...options });
  return handleApiResponse(response);
};

export const apiService = {
  // Businesses
  getBusinessDetails: async (businessId) => {
    return apiRequest(`${API_CONFIG.ENDPOINTS.BUSINESSES}/${businessId}`);
  },
  
  // Stages
  getStages: async (businessId) => {
    return apiRequest(`${API_CONFIG.ENDPOINTS.STAGES}?business_id=${businessId}`);
  },
  
  createStage: async (stageData) => {
    return apiRequest(API_CONFIG.ENDPOINTS.STAGES, {
      method: 'POST',
      body: JSON.stringify(stageData),
    });
  },
  
  // Authentication
  saveConfig: async (config) => {
    return apiRequest(API_CONFIG.ENDPOINTS.LOGIN, {
      method: 'POST',
      body: JSON.stringify(config),
    });
  },
  
  // Templates
  createTemplate: async (templateData) => {
    return apiRequest(API_CONFIG.ENDPOINTS.TEMPLATES, {
      method: 'POST',
      body: JSON.stringify(templateData),
    });
  },
  
  fetchTemplateDetails: async (templateId) => {
    return apiRequest(`${API_CONFIG.ENDPOINTS.TEMPLATES}/${templateId}`);
  },
  
  // Messages
  sendMessage: async (messageData) => {
    return apiRequest(API_CONFIG.ENDPOINTS.MESSAGE, {
      method: 'POST',
      body: JSON.stringify(messageData),
    });
  },
  
  // Conversations
  getConversations: async (userId, businessId) => {
    return apiRequest(`${API_CONFIG.ENDPOINTS.CONVERSATIONS}/${userId}?business_id=${businessId}`);
  },
  
  // Debug
  getDebugInfo: async (conversationId) => {
    return apiRequest(`${API_CONFIG.ENDPOINTS.DEBUG}/conversation/${conversationId}`);
  }
};

export default apiService; 

================================================================================
File: authService.js
Path: .\front-end\src\services\authService.js
Size: 6045
Modified: 2025-04-15T15:50:38.817288
Created: 2025-04-09T12:42:39.783767
Hash: d7ac4d3995b30c2510423e093c2c94c8ec4db756404cca4c87aa17bd823d9664
Lines: 170
================================================================================
// Authentication service for handling login, logout, and session management
import { API_CONFIG, AUTH_CONFIG } from '../config';

/**
 * Handles API responses and throws errors for non-OK responses
 * @param {Response} response - The fetch Response object
 * @returns {Promise<any>} - The parsed response data
 * @throws {Error} - Throws an error with details from the response if not ok
 */
const handleApiResponse = async (response) => {
  console.log('API Response Status:', response.status, response.statusText);
  console.log('Response Headers:', Object.fromEntries(response.headers.entries()));
  
  // Clone the response so we can try both JSON and text parsing if needed
  const responseClone = response.clone();
  
  // Handle non-OK responses
  if (!response.ok) {
    // Try to get detailed error from response
    try {
      const errorData = await response.json();
      console.error('Error response data:', errorData);
      throw new Error(errorData.message || errorData.error || `API error: ${response.status}`);
    } catch (jsonError) {
      // If response isn't valid JSON, use status text
      console.error('Error parsing response:', jsonError);
      try {
        const errorText = await responseClone.text();
        console.error('Response text:', errorText);
        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorText}`);
      } catch (textError) {
        // If both JSON and text parsing fail, just use the status
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }
    }
  }
  
  // For successful responses, parse JSON or return empty object
  try {
    const data = await response.json();
    console.log('API Response Data:', data);
    return data;
  } catch (error) {
    // Some successful responses may not have a body (e.g., 204 No Content)
    console.log('No JSON in successful response');
    return {};
  }
};

/**
 * Login with business and user credentials
 * @param {string} userId - User ID
 * @param {string} businessId - Business ID
 * @param {string} businessApiKey - Business API Key
 * @returns {Promise<Object>} - Login response data
 */
export const login = async (userId, businessId, businessApiKey) => {
  try {
    // Trim whitespace from all inputs
    const trimmedUserId = userId.trim();
    const trimmedBusinessId = businessId.trim();
    const trimmedBusinessApiKey = businessApiKey.trim();
    
    console.log('Login attempt with:', { 
      userId: trimmedUserId, 
      businessId: trimmedBusinessId, 
      businessApiKey: '***' 
    });
    console.log('Login URL:', `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.LOGIN}`);
    
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.LOGIN}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      credentials: 'include',
      body: JSON.stringify({
        userId: trimmedUserId,
        businessId: trimmedBusinessId,
        businessApiKey: trimmedBusinessApiKey
      })
    });

    const data = await handleApiResponse(response);
    
    // Check if the response indicates success
    if (data.success || data.message === 'Configuration saved successfully') {
      console.log('Login successful, storing credentials');
      // Store credentials in localStorage for persistent login
      localStorage.setItem(AUTH_CONFIG.STORAGE_KEYS.USER_ID, trimmedUserId);
      localStorage.setItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_ID, trimmedBusinessId);
      localStorage.setItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_API_KEY, trimmedBusinessApiKey);
      
      // Return a standardized success response
      return { success: true, message: 'Login successful' };
    } else {
      console.error('Login response indicates failure:', data);
      return { success: false, message: data.error || 'Login failed' };
    }
  } catch (error) {
    console.error('Login error:', error);
    return { success: false, message: error.message || 'Login failed' };
  }
};

/**
 * Logout and clear stored credentials
 */
export const logout = () => {
  // Clear stored credentials
  localStorage.removeItem(AUTH_CONFIG.STORAGE_KEYS.USER_ID);
  localStorage.removeItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_ID);
  localStorage.removeItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_API_KEY);
  
  return { success: true, message: 'Logged out successfully' };
};

/**
 * Check if user is logged in
 * @returns {boolean} - True if user is logged in
 */
export const isLoggedIn = () => {
  const userId = localStorage.getItem(AUTH_CONFIG.STORAGE_KEYS.USER_ID);
  const businessId = localStorage.getItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_ID);
  const businessApiKey = localStorage.getItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_API_KEY);
  
  return !!(userId && businessId && businessApiKey);
};

/**
 * Get stored credentials
 * @returns {Object} - Stored credentials
 */
export const getStoredCredentials = () => {
  return {
    userId: localStorage.getItem(AUTH_CONFIG.STORAGE_KEYS.USER_ID) || '',
    businessId: localStorage.getItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_ID) || '',
    businessApiKey: localStorage.getItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_API_KEY) || ''
  };
};

/**
 * Get authentication headers for API requests
 * @returns {Object} - Headers object with authentication
 */
export const getAuthHeaders = () => {
  const businessApiKey = localStorage.getItem(AUTH_CONFIG.STORAGE_KEYS.BUSINESS_API_KEY);
  
  if (!businessApiKey) {
    throw new Error('No API key found. Please log in first.');
  }
  
  return {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    'businessapikey': businessApiKey
  };
};

// Create a named export object
const authService = {
  login,
  logout,
  isLoggedIn,
  getStoredCredentials,
  getAuthHeaders
};

export default authService; 

================================================================================
File: businessService.js
Path: .\front-end\src\services\businessService.js
Size: 1908
Modified: 2025-04-09T13:40:44.047741
Created: 2025-04-08T21:21:51.870072
Hash: 6ca9fd02b87ca0e7fd4cb8625631a26f9fc6a719aaa9004690421774fbf445db
Lines: 50
================================================================================
import { API_CONFIG } from '../config';
import { getAuthHeaders } from '../services/authService';

// Helper to handle API responses (can be moved to a shared api.js)
const handleApiResponse = async (response) => {
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({})); // Try to parse error, fallback
    throw new Error(errorData.message || errorData.error || `HTTP error ${response.status}`);
  }
  // Handle 204 No Content
  if (response.status === 204) {
      return null; 
  }
  return response.json();
};

// Fetch business details by ID
export const getBusiness = async (businessId) => {
  console.log(`[Service] Fetching business details for ID: ${businessId}`);
  const response = await fetch(`${API_CONFIG.BASE_URL}/businesses/${businessId}`, {
    method: 'GET',
    credentials: 'include', // Send cookies
    headers: getAuthHeaders()
  });
  return handleApiResponse(response);
};

// Update business details
export const updateBusiness = async (businessId, businessData) => {
  console.log(`[Service] Updating business ${businessId} with:`, businessData);
  const response = await fetch(`${API_CONFIG.BASE_URL}/businesses/${businessId}`, {
    method: 'PUT',
    credentials: 'include',
    headers: getAuthHeaders(),
    body: JSON.stringify(businessData),
  });
  return handleApiResponse(response);
};

// Set the default starting stage for a business
export const setDefaultStage = async (businessId, stageId) => {
  console.log(`[Service] Setting default stage for business ${businessId} to: ${stageId}`);
  const response = await fetch(`${API_CONFIG.BASE_URL}/businesses/${businessId}/default-stage`, {
    method: 'PUT',
    credentials: 'include',
    headers: getAuthHeaders(),
    body: JSON.stringify({ stage_id: stageId }), // Send stage_id in the body
  });
  return handleApiResponse(response);
}; 

================================================================================
File: debugService.js
Path: .\front-end\src\services\debugService.js
Size: 3587
Modified: 2025-04-09T14:37:58.496912
Created: 2025-04-08T22:35:58.819367
Hash: f4a854324e910a4edd342b9844d7c2840dc9247e31fa44861c649fabf783589d
Lines: 103
================================================================================
// Debug service for message handling diagnostics
import { API_CONFIG } from '../config';
import { getAuthHeaders } from './authService';

/**
 * Handles API responses and throws errors for non-OK responses
 * @param {Response} response - The fetch Response object
 * @returns {Promise<any>} - The parsed response data
 * @throws {Error} - Throws an error with details from the response if not ok
 */
const handleApiResponse = async (response) => {
    // Handle non-OK responses
    if (!response.ok) {
        // Try to get detailed error from response
        try {
            const errorData = await response.json();
            throw new Error(errorData.message || errorData.error || `API error: ${response.status}`);
        } catch (jsonError) {
            // If response isn't valid JSON, use status text
            throw new Error(`API error: ${response.status} ${response.statusText}`);
        }
    }
    
    // For successful responses, parse JSON or return empty object
    try {
        return await response.json();
    } catch (error) {
        // Some successful responses may not have a body (e.g., 204 No Content)
        return {};
    }
};

/**
 * Make an API request with authentication
 * @param {string} endpoint - API endpoint
 * @param {Object} options - Request options
 * @returns {Promise<any>} - Response data
 */
const apiRequest = async (endpoint, options = {}) => {
    const url = `${endpoint}`;
    const defaultOptions = {
        headers: getAuthHeaders(),
        credentials: 'include',
    };

    const response = await fetch(url, { ...defaultOptions, ...options });
    return handleApiResponse(response);
};

export const debugService = {
    // Get debug information for a specific conversation
    getConversationDebug: (conversationId) => {
        return apiRequest(`${API_CONFIG.ENDPOINTS.DEBUG}/conversation/${conversationId}`);
    },

    // Get real-time message processing debug info
    getMessageProcessingDebug: (messageId) => {
        return apiRequest(`${API_CONFIG.ENDPOINTS.DEBUG}/message/${messageId}`);
    },

    // Get stage navigation history
    getStageNavigationDebug: (conversationId) => {
        return apiRequest(`${API_CONFIG.ENDPOINTS.DEBUG}/stages/${conversationId}`);
    },

    // Get prompt generation details
    getPromptGenerationDebug: (messageId) => {
        return apiRequest(`${API_CONFIG.ENDPOINTS.DEBUG}/prompts/${messageId}`);
    },

    // Get data extraction results
    getDataExtractionDebug: (messageId) => {
        return apiRequest(`${API_CONFIG.ENDPOINTS.DEBUG}/extraction/${messageId}`);
    },

    // Subscribe to real-time debug events for a conversation
    subscribeToDebugEvents: (conversationId, callback) => {
        const eventSource = new EventSource(`${API_CONFIG.ENDPOINTS.DEBUG}/events/${conversationId}`);
        
        eventSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                callback(data);
            } catch (error) {
                console.error('Error parsing event data:', error);
            }
        };
        
        eventSource.onerror = (error) => {
            console.error('EventSource error:', error);
            eventSource.close();
        };

        // Return cleanup function
        return () => {
            if (eventSource.readyState !== EventSource.CLOSED) {
                eventSource.close();
            }
        };
    }
};

export default debugService; 

================================================================================
File: messageService.js
Path: .\front-end\src\services\messageService.js
Size: 3549
Modified: 2025-04-09T14:37:46.181100
Created: 2025-04-09T12:43:00.851293
Hash: 7df92c845aaf2c0c8e80697a8951e0d325fc252637cd206daf58d5501fe76007
Lines: 121
================================================================================
// Message service for handling message sending and conversation history
import { API_CONFIG } from '../config';
import { getAuthHeaders, getStoredCredentials } from './authService';

/**
 * Handles API responses and throws errors for non-OK responses
 * @param {Response} response - The fetch Response object
 * @returns {Promise<any>} - The parsed response data
 * @throws {Error} - Throws an error with details from the response if not ok
 */
const handleApiResponse = async (response) => {
  // Handle non-OK responses
  if (!response.ok) {
    // Try to get detailed error from response
    try {
      const errorData = await response.json();
      throw new Error(errorData.message || errorData.error || `API error: ${response.status}`);
    } catch (jsonError) {
      // If response isn't valid JSON, use status text
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }
  }
  
  // For successful responses, parse JSON or return empty object
  try {
    return await response.json();
  } catch (error) {
    // Some successful responses may not have a body (e.g., 204 No Content)
    return {};
  }
};

/**
 * Send a message to the API
 * @param {string} message - Message content
 * @param {Object} options - Additional options
 * @param {string} options.conversationId - Optional conversation ID
 * @param {string} options.agentId - Optional agent ID
 * @returns {Promise<Object>} - Response data
 */
export const sendMessage = async (message, options = {}) => {
  try {
    const { userId, businessId } = getStoredCredentials();
    
    const requestData = {
      business_id: businessId,
      user_id: userId,
      message: message
    };
    
    // Add optional fields if provided
    if (options.conversationId) {
      requestData.conversation_id = options.conversationId;
    }
    
    if (options.agentId) {
      requestData.agent_id = options.agentId;
    }
    
    const response = await fetch(`${API_CONFIG.ENDPOINTS.MESSAGE}`, {
      method: 'POST',
      headers: getAuthHeaders(),
      credentials: 'include',
      body: JSON.stringify(requestData)
    });
    
    return await handleApiResponse(response);
  } catch (error) {
    console.error('Send message error:', error);
    throw error;
  }
};

/**
 * Fetch conversation history for a user
 * @returns {Promise<Array>} - Conversation history
 */
export const fetchConversationHistory = async () => {
  try {
    const { userId, businessId } = getStoredCredentials();
    
    const response = await fetch(
      `${API_CONFIG.ENDPOINTS.CONVERSATIONS}/${userId}?business_id=${businessId}`,
      {
        method: 'GET',
        headers: getAuthHeaders(),
        credentials: 'include'
      }
    );
    
    return await handleApiResponse(response);
  } catch (error) {
    console.error('Fetch conversation history error:', error);
    throw error;
  }
};

/**
 * Test backend connection
 * @returns {Promise<Object>} - Connection test result
 */
export const testConnection = async () => {
  try {
    const response = await fetch(`/`, {
      method: 'GET',
      credentials: 'include'
    });
    
    const text = await response.text();
    return { success: true, message: text };
  } catch (error) {
    console.error('Connection test error:', error);
    return { success: false, message: error.message };
  }
};

export default {
  sendMessage,
  fetchConversationHistory,
  testConnection
}; 

================================================================================
File: stageService.js
Path: .\front-end\src\services\stageService.js
Size: 5494
Modified: 2025-04-09T14:37:21.772142
Created: 2025-04-01T16:29:34.419987
Hash: 8a698796be4bebc9391c4723c93a1c4b3dfd60aa73210850527ab639738f5c63
Lines: 163
================================================================================
// src/services/stageService.js

import { API_CONFIG } from '../config';
import { getAuthHeaders } from '../services/authService';

// Helper to handle API responses (reuse or import)
const handleApiResponse = async (response) => {
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({})); 
    throw new Error(errorData.message || errorData.error || `HTTP error ${response.status}`);
  }
  if (response.status === 204) {
      return null; 
  }
  // Assume the response is JSON if OK and not 204
  return response.json(); 
};

// Fetch all stages for a given business
export const fetchStages = async (businessId) => {
  if (!businessId) {
    console.error("[Service Error] fetchStages requires a businessId.");
    throw new Error("Business ID is required to fetch stages.");
  }
  console.log(`[Service] Fetching stages for business: ${businessId}`);
  
  // Log the headers for debugging
  const headers = getAuthHeaders();
  console.log("[Service] Using headers:", headers);
  
  const response = await fetch(`/stages?business_id=${businessId}`, {
    method: 'GET',
    credentials: 'include', // Send cookies
    headers: headers
  });
  
  // Log the response status for debugging
  console.log(`[Service] Response status: ${response.status}`);
  
  return handleApiResponse(response);
};

// Create a new stage
export const createStage = async (stageData) => {
  if (!stageData.business_id) {
    console.error("[Service Error] createStage requires a business_id.");
    throw new Error("Business ID is required to create a stage.");
  }
  
  console.log(`[Service] Creating stage for business: ${stageData.business_id}`);
  console.log(`[Service] Stage data:`, stageData);
  
  // Log the headers for debugging
  const headers = getAuthHeaders();
  console.log("[Service] Using headers:", headers);
  
  const response = await fetch(`/stages`, {
    method: 'POST',
    credentials: 'include',
    headers: headers,
    body: JSON.stringify(stageData)
  });
  
  // Log the response status for debugging
  console.log(`[Service] Response status: ${response.status}`);
  
  return handleApiResponse(response);
};

// Fetch details for a specific stage
export const fetchStageDetails = async (stageId) => {
    try {
        const businessId = localStorage.getItem('businessId');
        if (!businessId || !stageId) {
            throw new Error('Missing required parameters: ' + 
                (!businessId ? 'businessId ' : '') + 
                (!stageId ? 'stageId' : ''));
        }

        console.log(`[Service] Fetching stage details for stage ${stageId} and business ${businessId}`);
        
        // Log the headers for debugging
        const headers = getAuthHeaders();
        console.log("[Service] Using headers:", headers);
        
        const response = await fetch(`/stages/${stageId}?business_id=${businessId}`, {
            method: 'GET',
            credentials: 'include',
            headers: headers
        });

        // Log the response status for debugging
        console.log(`[Service] Response status: ${response.status}`);
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('Error response:', errorData);
            throw new Error(errorData.error || `Failed to fetch stage details (HTTP ${response.status})`);
        }

        const data = await response.json();
        console.log('Received stage details:', data);
        
        if (!data || typeof data !== 'object') {
            throw new Error('Invalid response format from server');
        }

        return data;
    } catch (error) {
        console.error('Error fetching stage details:', error);
        throw error;
    }
};

// Update an existing stage
export const updateStage = async (stageId, stageData) => {
    if (!stageId || !stageData.business_id) {
        throw new Error('Missing required parameters: stageId and business_id');
    }
    
    console.log(`[Service] Updating stage ${stageId} for business ${stageData.business_id}`);
    
    // Log the headers for debugging
    const headers = getAuthHeaders();
    console.log("[Service] Using headers:", headers);
    
    const response = await fetch(`/stages/${stageId}`, {
        method: 'PUT',
        credentials: 'include',
        headers: headers,
        body: JSON.stringify(stageData)
    });
    
    // Log the response status for debugging
    console.log(`[Service] Response status: ${response.status}`);
    
    return handleApiResponse(response);
};

// Delete a stage
export const deleteStage = async (stageId, businessId) => {
    if (!stageId || !businessId) {
        throw new Error('Missing required parameters: stageId and businessId');
    }
    
    console.log(`[Service] Deleting stage ${stageId} for business ${businessId}`);
    
    // Log the headers for debugging
    const headers = getAuthHeaders();
    console.log("[Service] Using headers:", headers);
    
    const response = await fetch(`/stages/${stageId}?business_id=${businessId}`, {
        method: 'DELETE',
        credentials: 'include',
        headers: headers
    });
    
    // Log the response status for debugging
    console.log(`[Service] Response status: ${response.status}`);
    
    return handleApiResponse(response);
};


================================================================================
File: templateService.js
Path: .\front-end\src\services\templateService.js
Size: 5385
Modified: 2025-04-12T12:11:44.710371
Created: 2025-04-11T21:53:51.783794
Hash: 46e48b0b8dbcbfa43d62ca7e144cea62172395888770c11a2df2b3bb4dee36ed
Lines: 165
================================================================================
import { API_CONFIG } from '../config';
import { getAuthHeaders } from './authService';
import { normalizeUUID } from '../hooks/useConfig';

// Fetch templates
export const fetchTemplates = async (businessId, agentId) => {
  try {
    const normalizedBusinessId = normalizeUUID(businessId);
    const normalizedAgentId = normalizeUUID(agentId);

    console.log(`Fetching templates for business: ${normalizedBusinessId}, agent: ${normalizedAgentId}`);
    const response = await fetch(`${API_CONFIG.BASE_URL}/templates?business_id=${normalizedBusinessId}&agent_id=${normalizedAgentId}`, {
      method: 'GET',
      credentials: 'include',
      headers: getAuthHeaders()
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to fetch templates');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in fetchTemplates:', error);
    throw error;
  }
};

// Get a template by ID
export const getTemplate = async (templateId, businessId) => {
  try {
    const normalizedBusinessId = normalizeUUID(businessId);
    
    console.log(`Fetching template ${templateId} for business: ${normalizedBusinessId}`);
    const response = await fetch(`${API_CONFIG.BASE_URL}/templates/${templateId}?business_id=${normalizedBusinessId}`, {
      method: 'GET',
      credentials: 'include',
      headers: getAuthHeaders()
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to fetch template');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in getTemplate:', error);
    throw error;
  }
};

// Create a new template
export const createTemplate = async (templateData) => {
  try {
    // Make sure business_id and agent_id are normalized
    const normalizedData = {
      ...templateData,
      business_id: normalizeUUID(templateData.business_id),
      agent_id: templateData.agent_id ? normalizeUUID(templateData.agent_id) : null
    };
    
    // Log the normalized data for debugging
    console.log('Creating template with data:', {
      original: templateData.business_id,
      normalized: normalizedData.business_id
    });
    
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.TEMPLATES}`, {
      method: 'POST',
      credentials: 'include',
      headers: getAuthHeaders(),
      body: JSON.stringify(normalizedData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to create template');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in createTemplate:', error);
    throw error;
  }
};

// Update an existing template
export const updateTemplate = async (templateId, templateData) => {
  try {
    // Make sure business_id and agent_id are normalized
    const normalizedData = {
      ...templateData,
      business_id: normalizeUUID(templateData.business_id),
      agent_id: templateData.agent_id ? normalizeUUID(templateData.agent_id) : null
    };
    
    // Log the normalized data for debugging
    console.log(`Updating template ${templateId}:`, {
      original: templateData.business_id,
      normalized: normalizedData.business_id
    });
    
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.TEMPLATES}/${templateId}`, {
      method: 'PUT',
      credentials: 'include',
      headers: getAuthHeaders(),
      body: JSON.stringify(normalizedData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to update template');
    }

    return await response.json();
  } catch (error) {
    console.error('Error in updateTemplate:', error);
    throw error;
  }
};

// Delete a template
export const deleteTemplate = async (templateId, businessId) => {
  try {
    const normalizedBusinessId = normalizeUUID(businessId);
    
    console.log(`Deleting template ${templateId} for business: ${normalizedBusinessId}`);
    const response = await fetch(`${API_CONFIG.BASE_URL}/templates/${templateId}?business_id=${normalizedBusinessId}`, {
      method: 'DELETE',
      credentials: 'include',
      headers: getAuthHeaders()
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to delete template');
    }

    return true;
  } catch (error) {
    console.error('Error in deleteTemplate:', error);
    throw error;
  }
};

// Duplicate a template
export const duplicateTemplate = async (templateData) => {
  try {
    // Make sure business_id and agent_id are normalized
    const normalizedData = {
      ...templateData,
      business_id: normalizeUUID(templateData.business_id),
      agent_id: normalizeUUID(templateData.agent_id),
      template_name: `${templateData.template_name} (Copy)`
    };
    
    console.log('Duplicating template as:', normalizedData);
    return await createTemplate(normalizedData);
  } catch (error) {
    console.error('Error in duplicateTemplate:', error);
    throw error;
  }
}; 

================================================================================
File: testService.js
Path: .\front-end\src\services\testService.js
Size: 5724
Modified: 2025-04-09T14:38:24.518508
Created: 2025-03-29T03:02:43.663042
Hash: c196366a0b99d25ced8e25c99f80b6d34cfe3eb400bc2cb0b4ef26d7fa52af3c
Lines: 170
================================================================================
// File: src/services/testService.js
// Last Modified: 2026-03-29
import axios from 'axios';
import { API_CONFIG } from '../config';
import { getAuthHeaders } from './authService';

// Helper function to handle API calls and error responses
const handleApiCall = async (url, method, data = null) => {
    const headers = {
        'Content-Type': 'application/json',
        ...getAuthHeaders()
    };

    try {
        const response = await axios({
            method: method,
            url: url,
            headers: headers,
            data: data,
            withCredentials: true
        });

        if (response.status >= 200 && response.status < 300) {
            return response.data;
        } else {
            console.error("API call failed:", response);
            throw new Error(`API call failed with status ${response.status}`);
        }
    } catch (error) {
        console.error("API call failed:", error);
        throw error; // Re-throw the error for the component to handle
    }
};

// --------------------------------------------------------
// Configuration Service (Saving to localStorage - Insecure)
// --------------------------------------------------------
export const saveConfig = async (apiKey, userId, businessId, businessApiKey) => {
    // This function doesn't actually call an API. It only saves to localStorage.
    return new Promise((resolve) => {
        localStorage.setItem('icmpApiKey', apiKey);
        localStorage.setItem('userId', userId);
        localStorage.setItem('businessId', businessId);
        localStorage.setItem('businessApiKey', businessApiKey);
        resolve({ success: true, message: 'Configuration saved to localStorage' });
    });
};

// --------------------------------------------------------
// User Management Service (Simulated)
// --------------------------------------------------------
export const createUser = async (firstName, lastName, email) => {
    try {
        return await handleApiCall(`/users`, 'POST', {
            firstName,
            lastName,
            email
        });
    } catch (error) {
        console.error("createUser API call failed:", error);
        throw error;
    }
};

// --------------------------------------------------------
// Business Management Service
// --------------------------------------------------------
export const fetchBusinessDetails = async (businessId) => {
    try {
        return await handleApiCall(`/businesses/${businessId}`, 'GET');
    } catch (error) {
        console.error("fetchBusinessDetails API call failed:", error);
        throw error;
    }
};

// --------------------------------------------------------
// Template Management Service
// --------------------------------------------------------
export const createTemplate = async (templateData) => {
    try {
        return await handleApiCall(`/templates`, 'POST', templateData);
    } catch (error) {
        console.error("createTemplate API call failed:", error);
        throw error;
    }
};

export const fetchTemplates = async () => {
    try {
        return await handleApiCall(`/templates/defaultTemplates`, 'GET');
    } catch (error) {
        console.error("fetchTemplates API call failed:", error);
        throw error;
    }
};

// --------------------------------------------------------
// Stage Management Service
// --------------------------------------------------------
export const createStage = async (stageData) => {
    try {
        const API_ENDPOINT = `/stages`;
        return await handleApiCall(API_ENDPOINT, 'POST', stageData);
    } catch (error) {
        console.error("createStage API call failed:", error);
        throw error;
    }
};

export const fetchStages = async (businessId) => {
    try {
        const API_ENDPOINT = `/stages`;
        return await handleApiCall(API_ENDPOINT, 'GET');
    } catch (error) {
        console.error("fetchStages API call failed:", error);
        throw error;
    }
};

// --------------------------------------------------------
// Message Handling Service
// --------------------------------------------------------
export const processMessage = async (messageData) => {
    try {
        return await handleApiCall(`/message`, 'POST', messageData);
    } catch (error) {
        console.error("processMessage API call failed:", error);
        throw error;
    }
};

// --------------------------------------------------------
// defaultTemplates Management Service
// --------------------------------------------------------
export const getDefaultTemplates = async () => {
    try {
        return await handleApiCall(`/templates/defaultTemplates`, 'GET');
    } catch (error) {
        console.error("getDefaultTemplates API call failed:", error);
        throw error;
    }
};

export const saveDefaultTemplate = async (templateData) => {
    try {
        return await handleApiCall(`/templates/defaultTemplates`, 'POST', templateData);
    } catch (error) {
        console.error("saveDefaultTemplate API call failed:", error);
        throw error;
    }
};

export const getStage = async (stageId) => {
    try {
        return await handleApiCall(`/stage/${stageId}`, 'GET');
    } catch (error) {
        console.error("getStage API call failed:", error);
        throw error;
    }
};

export const updateStage = async (stageId, stageData) => {
    try {
        return await handleApiCall(`/stage/${stageId}`, 'PUT', stageData);
    } catch (error) {
        console.error("updateStage API call failed:", error);
        throw error;
    }
};

================================================================================
File: apiTest.js
Path: .\front-end\src\utils\apiTest.js
Size: 10060
Modified: 2025-04-06T15:45:05.401538
Created: 2025-04-06T12:16:49.624524
Hash: 5f66eaa5687b08c43b28e9551aae596c3161ef1e2aecd8d6f37eeb50d70ac858
Lines: 326
================================================================================
// API Test Utility
// This file contains functions to test API connectivity and authentication

import { getStoredCredentials } from './fetchUtils';

/**
 * Test API key authentication
 * @param {string} [businessId] - The business ID (optional, will use stored credentials if not provided)
 * @param {string} [apiKey] - The API key (optional, will use stored credentials if not provided)
 * @returns {Promise<Object>} - The test result
 */
export const testApiKeyAuth = async (businessId, apiKey) => {
  console.log('Testing API key authentication...');
  
  try {
    // If businessId or apiKey is not provided, try to get them from stored credentials
    if (!businessId || !apiKey) {
      const storedCredentials = getStoredCredentials();
      businessId = businessId || storedCredentials.businessId;
      apiKey = apiKey || storedCredentials.businessApiKey;
      
      if (!businessId || !apiKey) {
        return {
          success: false,
          error: 'Business ID and API Key are required'
        };
      }
    }
    
    // Test with different authentication methods
    const authMethods = [
      // Method 1: API key as query parameter
      {
        url: `/businesses/validate-credentials?business_id=${businessId}&api_key=${apiKey}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      },
      // Method 2: API key in X-API-Key header
      {
        url: `/businesses/validate-credentials?business_id=${businessId}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-API-Key': apiKey
        }
      },
      // Method 3: API key in Authorization header as Bearer token
      {
        url: `/businesses/validate-credentials?business_id=${businessId}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        }
      }
    ];
    
    const results = [];
    
    for (const method of authMethods) {
      try {
        console.log(`Testing with URL: ${method.url} and headers:`, method.headers);
        
        const response = await fetch(method.url, {
          method: 'GET',
          headers: method.headers,
          credentials: 'include'
        });
        
        const status = response.status;
        const data = await response.json().catch(() => ({}));
        
        results.push({
          method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
          status,
          data,
          success: response.ok
        });
        
        // If any method succeeds, we can stop testing
        if (response.ok) {
          break;
        }
      } catch (err) {
        console.error(`Error testing authentication method:`, err);
        results.push({
          method: Object.keys(method.headers).find(h => h.includes('API') || h.includes('Authorization')) || 'query',
          error: err.message,
          success: false
        });
      }
    }
    
    // Check if any method succeeded
    const successfulResult = results.find(r => r.success);
    
    return {
      success: !!successfulResult,
      results,
      message: successfulResult ? 'Authentication successful' : 'All authentication methods failed'
    };
  } catch (err) {
    console.error('Error in testApiKeyAuth:', err);
    return {
      success: false,
      error: err.message
    };
  }
};

/**
 * Test template operations
 * @param {string} [businessId] - The business ID (optional, will use stored credentials if not provided)
 * @param {string} [apiKey] - The API key (optional, will use stored credentials if not provided)
 * @returns {Promise<Object>} - The test result
 */
export const testTemplateOperations = async (businessId, apiKey) => {
  console.log('Testing template operations...');
  
  try {
    // If businessId or apiKey is not provided, try to get them from stored credentials
    if (!businessId || !apiKey) {
      const storedCredentials = getStoredCredentials();
      businessId = businessId || storedCredentials.businessId;
      apiKey = apiKey || storedCredentials.businessApiKey;
      
      if (!businessId || !apiKey) {
        return {
          success: false,
          error: 'Business ID and API Key are required'
        };
      }
    }
    
    // Test fetching templates
    const fetchResult = await testFetchTemplates(businessId, apiKey);
    
    // Test creating a template
    const createResult = await testCreateTemplate(businessId, apiKey);
    
    return {
      success: fetchResult.success && createResult.success,
      fetchResult,
      createResult
    };
  } catch (err) {
    console.error('Template operations test error:', err);
    return {
      success: false,
      error: err.message
    };
  }
};

/**
 * Test fetching templates
 * @param {string} businessId - The business ID
 * @param {string} apiKey - The API key
 * @returns {Promise<Object>} - The test result
 */
const testFetchTemplates = async (businessId, apiKey) => {
  console.log('Testing fetching templates...');
  
  try {
    // Try both methods: GET with params and POST with body
    const methods = [
      // Method 1: GET request with business_id as query parameter
      {
        method: 'GET',
        url: `/templates?business_id=${businessId}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
          'X-API-Key': apiKey
        },
        body: null
      },
      // Method 2: POST request with business_id in body
      {
        method: 'POST',
        url: '/templates',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
          'X-API-Key': apiKey
        },
        body: JSON.stringify({ business_id: businessId })
      }
    ];
    
    // Try each method until one succeeds
    for (const method of methods) {
      try {
        console.log(`Trying to fetch templates with ${method.method} request:`, method);
        
        const response = await fetch(method.url, {
          method: method.method,
          headers: method.headers,
          body: method.body,
          credentials: 'include'
        });
        
        const status = response.status;
        const data = await response.json().catch(() => ({}));
        
        console.log(`${method.method} templates result:`, { status, data });
        
        if (response.ok) {
          return {
            success: true,
            status,
            data,
            method: method.method
          };
        }
      } catch (err) {
        console.error(`Error with ${method.method} templates request:`, err);
      }
    }
    
    return {
      success: false,
      error: "All template fetch methods failed"
    };
  } catch (err) {
    console.error('Fetch templates error:', err);
    return {
      success: false,
      error: err.message
    };
  }
};

/**
 * Test creating a template
 * @param {string} businessId - The business ID
 * @param {string} apiKey - The API key
 * @returns {Promise<Object>} - The test result
 */
const testCreateTemplate = async (businessId, apiKey) => {
  console.log('Testing creating a template...');
  
  try {
    const templateData = {
      template_name: `Test Template ${Date.now()}`,
      template_text: 'This is a test template with {variable1} and {variable2}.',
      template_type: 'test_template',
      business_id: businessId,
      variables: ['variable1', 'variable2'],
      template_description: 'A test template for API testing'
    };
    
    const response = await fetch('/templates/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      credentials: 'include',
      body: JSON.stringify(templateData)
    });
    
    const status = response.status;
    const data = await response.json().catch(() => ({}));
    
    console.log('Create template result:', { status, data });
    
    return {
      success: response.ok,
      status,
      data
    };
  } catch (err) {
    console.error('Create template error:', err);
    return {
      success: false,
      error: err.message
    };
  }
};

/**
 * Run all API tests
 * @param {string} [businessId] - The business ID (optional, will use stored credentials if not provided)
 * @param {string} [apiKey] - The API key (optional, will use stored credentials if not provided)
 * @returns {Promise<Object>} - The test results
 */
export const runAllApiTests = async (businessId, apiKey) => {
  console.log('Running all API tests...');
  
  try {
    // If businessId or apiKey is not provided, try to get them from stored credentials
    if (!businessId || !apiKey) {
      const storedCredentials = getStoredCredentials();
      businessId = businessId || storedCredentials.businessId;
      apiKey = apiKey || storedCredentials.businessApiKey;
      
      if (!businessId || !apiKey) {
        return {
          success: false,
          error: 'Business ID and API Key are required'
        };
      }
    }
    
    const authResult = await testApiKeyAuth(businessId, apiKey);
    const templateResult = await testTemplateOperations(businessId, apiKey);
    
    return {
      success: authResult.success && templateResult.success,
      authResult,
      templateResult
    };
  } catch (err) {
    console.error('API tests error:', err);
    return {
      success: false,
      error: err.message
    };
  }
}; 

================================================================================
File: authUtils.js
Path: .\front-end\src\utils\authUtils.js
Size: 1206
Modified: 2025-04-07T00:33:22.415568
Created: 2025-04-07T00:33:20.219294
Hash: 6bd41e9b6b02696dd6a9709f775c79f85c495e645a93ac8f9b75d8c057664ab5
Lines: 44
================================================================================
/**
 * Authentication utility functions
 */

/**
 * Get stored credentials from localStorage
 * @returns {Object} Object containing businessId and businessApiKey
 */
export const getStoredCredentials = () => {
  const businessId = localStorage.getItem('businessId');
  const businessApiKey = localStorage.getItem('businessApiKey');
  
  return {
    businessId,
    businessApiKey
  };
};

/**
 * Check if user is authenticated
 * @returns {boolean} True if user is authenticated, false otherwise
 */
export const isAuthenticated = () => {
  const { businessId, businessApiKey } = getStoredCredentials();
  return !!(businessId && businessApiKey);
};

/**
 * Store credentials in localStorage
 * @param {string} businessId - The business ID
 * @param {string} businessApiKey - The business API key
 */
export const storeCredentials = (businessId, businessApiKey) => {
  localStorage.setItem('businessId', businessId);
  localStorage.setItem('businessApiKey', businessApiKey);
};

/**
 * Clear stored credentials from localStorage
 */
export const clearCredentials = () => {
  localStorage.removeItem('businessId');
  localStorage.removeItem('businessApiKey');
}; 

================================================================================
File: fetchUtils.js
Path: .\front-end\src\utils\fetchUtils.js
Size: 3337
Modified: 2025-04-06T14:22:53.652860
Created: 2025-04-06T00:27:44.942986
Hash: 0f8dd0f00c087d652dad6f1d1adbb4d69ff2be0c2f68c5ef401c704981a724f3
Lines: 109
================================================================================
// Global request cache to prevent duplicate API calls
const apiCache = {
  cache: {},
  get: function(url) {
    return this.cache[url]?.data;
  },
  set: function(url, data, ttl = 60000) { // Default TTL: 1 minute
    this.cache[url] = {
      data,
      expiry: Date.now() + ttl
    };
  },
  isValid: function(url) {
    const item = this.cache[url];
    return item && item.expiry > Date.now();
  },
  clear: function() {
    this.cache = {};
  }
};

/**
 * Get stored credentials from localStorage
 * @returns {Object} Object containing businessId and businessApiKey
 */
export const getStoredCredentials = () => {
  const businessId = localStorage.getItem('businessId');
  const businessApiKey = localStorage.getItem('businessApiKey');
  return { businessId, businessApiKey };
};

/**
 * Fetches data with caching support
 * @param {string} url - The URL to fetch
 * @param {Object} options - Fetch options
 * @returns {Promise<Response>} - The fetch response
 */
export const cachedFetch = async (url, options = {}) => {
  // Ensure URL ends with trailing slash for POST/PUT requests
  if ((options.method === 'POST' || options.method === 'PUT') && !url.endsWith('/')) {
    url = `${url}/`;
  }
  
  // Add business_id to URL if not already present
  const urlObj = new URL(url, window.location.origin);
  if (!urlObj.searchParams.has('business_id')) {
    const businessId = localStorage.getItem('businessId');
    if (businessId) {
      urlObj.searchParams.append('business_id', businessId);
      url = urlObj.toString();
    }
  }
  
  // Create cache key
  const cacheKey = `${url}-${options.method || 'GET'}-${JSON.stringify(options.body || {})}`;
  
  // Check cache for GET requests
  if (options.method === 'GET' || !options.method) {
    const cachedData = apiCache.get(cacheKey);
    if (cachedData && apiCache.isValid(cacheKey)) {
      console.log(`Using cached data for ${url}`);
      return new Response(JSON.stringify(cachedData), {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
  
  // Prepare headers
  const headers = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    ...options.headers
  };
  
  // Add API key in both headers for redundancy
  const apiKey = localStorage.getItem('businessApiKey');
  if (apiKey) {
    // Use both X-API-Key and Authorization header to maximize compatibility
    headers['X-API-Key'] = apiKey;
    headers['Authorization'] = `Bearer ${apiKey}`;
  }
  
  // Prepare fetch options
  const fetchOptions = {
    ...options,
    headers,
    credentials: 'include' // Important: Send cookies with request
  };
  
  // Stringify body if it's an object
  if (fetchOptions.body && typeof fetchOptions.body === 'object') {
    fetchOptions.body = JSON.stringify(fetchOptions.body);
  }
  
  // Make the fetch request
  console.log(`Fetching ${url} with options:`, fetchOptions);
  const response = await fetch(url, fetchOptions);
  
  // Cache successful GET responses
  if ((options.method === 'GET' || !options.method) && response.ok) {
    const data = await response.clone().json().catch(() => null);
    if (data) {
      apiCache.set(cacheKey, data);
    }
  }
  
  return response;
}; 

================================================================================
File: fileMock.js
Path: .\front-end\__mocks__\fileMock.js
Size: 35
Modified: 2025-04-02T01:04:20.556739
Created: 2025-04-02T01:04:18.492098
Hash: 0da11e906d3210954fdd642b2d6570cedeaf6cdcde76997d9b7698b69cb3caac
Lines: 1
================================================================================
module.exports = 'test-file-stub'; 

