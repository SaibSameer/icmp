{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\n// Assuming an agentService.js file will export fetchAgents\n// We might need to create/update this service file later\nimport { fetchAgents as fetchAgentsApi } from '../services/agentService';\nimport useConfig from './useConfig';\nconst useAgents = handleSnackbarOpen => {\n  _s();\n  const [agents, setAgents] = useState([]); // Initialize as empty array\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const {\n    businessId\n  } = useConfig(); // Get businessId from config\n\n  const fetchAgents = useCallback(async () => {\n    if (!businessId) {\n      setAgents([]); // Clear agents if no businessId\n      return;\n    }\n    setIsLoading(true);\n    setError(null);\n    console.log(`Fetching agents for business ID: ${businessId}`);\n    try {\n      // API key relies on httpOnly cookie sent automatically by browser\n      const data = await fetchAgentsApi(businessId);\n      console.log(\"Fetched agents:\", data);\n      // Ensure data is always an array, even if API returns null/undefined\n      setAgents(Array.isArray(data) ? data : []);\n      // Optional: Add snackbar notification on success\n      // if (handleSnackbarOpen) {\n      //      handleSnackbarOpen(\"Agents loaded!\", \"info\");\n      // }\n    } catch (err) {\n      console.error(\"Error fetching agents:\", err);\n      const errorMessage = err.message || 'Failed to fetch agents';\n      setError(errorMessage);\n      setAgents([]); // Clear agents on error\n      if (handleSnackbarOpen) {\n        // Use the extracted error message for the snackbar\n        handleSnackbarOpen(`Error fetching agents: ${errorMessage}`, \"error\");\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [businessId, handleSnackbarOpen]);\n\n  // useEffect to trigger fetch when businessId changes\n  useEffect(() => {\n    fetchAgents();\n  }, [fetchAgents]); // Dependency array includes fetchAgents (memoized via useCallback)\n\n  return {\n    agents,\n    // The array of agent objects\n    isLoading,\n    // Boolean indicating if fetch is in progress\n    error,\n    // Error object/message if fetch failed\n    refreshAgents: fetchAgents // Function to manually trigger a refresh\n  };\n};\n_s(useAgents, \"rKS/UKWeCvrDp2KfOe7T0gBlJtk=\", false, function () {\n  return [useConfig];\n});\nexport default useAgents;","map":{"version":3,"names":["useState","useEffect","useCallback","fetchAgents","fetchAgentsApi","useConfig","useAgents","handleSnackbarOpen","_s","agents","setAgents","isLoading","setIsLoading","error","setError","businessId","console","log","data","Array","isArray","err","errorMessage","message","refreshAgents"],"sources":["C:/icmp_events_api/front-end/src/hooks/useAgents.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\n// Assuming an agentService.js file will export fetchAgents\r\n// We might need to create/update this service file later\r\nimport { fetchAgents as fetchAgentsApi } from '../services/agentService';\r\nimport useConfig from './useConfig';\r\n\r\nconst useAgents = (handleSnackbarOpen) => {\r\n    const [agents, setAgents] = useState([]); // Initialize as empty array\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [error, setError] = useState(null);\r\n    const { businessId } = useConfig(); // Get businessId from config\r\n\r\n    const fetchAgents = useCallback(async () => {\r\n        if (!businessId) {\r\n            setAgents([]); // Clear agents if no businessId\r\n            return;\r\n        }\r\n\r\n        setIsLoading(true);\r\n        setError(null);\r\n        console.log(`Fetching agents for business ID: ${businessId}`);\r\n\r\n        try {\r\n            // API key relies on httpOnly cookie sent automatically by browser\r\n            const data = await fetchAgentsApi(businessId);\r\n            console.log(\"Fetched agents:\", data);\r\n            // Ensure data is always an array, even if API returns null/undefined\r\n            setAgents(Array.isArray(data) ? data : []);\r\n            // Optional: Add snackbar notification on success\r\n            // if (handleSnackbarOpen) {\r\n            //      handleSnackbarOpen(\"Agents loaded!\", \"info\");\r\n            // }\r\n        } catch (err) {\r\n            console.error(\"Error fetching agents:\", err);\r\n            const errorMessage = err.message || 'Failed to fetch agents';\r\n            setError(errorMessage);\r\n            setAgents([]); // Clear agents on error\r\n             if (handleSnackbarOpen) {\r\n                // Use the extracted error message for the snackbar\r\n                handleSnackbarOpen(`Error fetching agents: ${errorMessage}`, \"error\");\r\n            }\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [businessId, handleSnackbarOpen]);\r\n\r\n    // useEffect to trigger fetch when businessId changes\r\n    useEffect(() => {\r\n        fetchAgents();\r\n    }, [fetchAgents]); // Dependency array includes fetchAgents (memoized via useCallback)\r\n\r\n    return {\r\n        agents,          // The array of agent objects\r\n        isLoading,       // Boolean indicating if fetch is in progress\r\n        error,           // Error object/message if fetch failed\r\n        refreshAgents: fetchAgents // Function to manually trigger a refresh\r\n    };\r\n};\r\n\r\nexport default useAgents;\r\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACxD;AACA;AACA,SAASC,WAAW,IAAIC,cAAc,QAAQ,0BAA0B;AACxE,OAAOC,SAAS,MAAM,aAAa;AAEnC,MAAMC,SAAS,GAAIC,kBAAkB,IAAK;EAAAC,EAAA;EACtC,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGV,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;EAC1C,MAAM,CAACW,SAAS,EAAEC,YAAY,CAAC,GAAGZ,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACa,KAAK,EAAEC,QAAQ,CAAC,GAAGd,QAAQ,CAAC,IAAI,CAAC;EACxC,MAAM;IAAEe;EAAW,CAAC,GAAGV,SAAS,CAAC,CAAC,CAAC,CAAC;;EAEpC,MAAMF,WAAW,GAAGD,WAAW,CAAC,YAAY;IACxC,IAAI,CAACa,UAAU,EAAE;MACbL,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;MACf;IACJ;IAEAE,YAAY,CAAC,IAAI,CAAC;IAClBE,QAAQ,CAAC,IAAI,CAAC;IACdE,OAAO,CAACC,GAAG,CAAC,oCAAoCF,UAAU,EAAE,CAAC;IAE7D,IAAI;MACA;MACA,MAAMG,IAAI,GAAG,MAAMd,cAAc,CAACW,UAAU,CAAC;MAC7CC,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEC,IAAI,CAAC;MACpC;MACAR,SAAS,CAACS,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,GAAGA,IAAI,GAAG,EAAE,CAAC;MAC1C;MACA;MACA;MACA;IACJ,CAAC,CAAC,OAAOG,GAAG,EAAE;MACVL,OAAO,CAACH,KAAK,CAAC,wBAAwB,EAAEQ,GAAG,CAAC;MAC5C,MAAMC,YAAY,GAAGD,GAAG,CAACE,OAAO,IAAI,wBAAwB;MAC5DT,QAAQ,CAACQ,YAAY,CAAC;MACtBZ,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;MACd,IAAIH,kBAAkB,EAAE;QACrB;QACAA,kBAAkB,CAAC,0BAA0Be,YAAY,EAAE,EAAE,OAAO,CAAC;MACzE;IACJ,CAAC,SAAS;MACNV,YAAY,CAAC,KAAK,CAAC;IACvB;EACJ,CAAC,EAAE,CAACG,UAAU,EAAER,kBAAkB,CAAC,CAAC;;EAEpC;EACAN,SAAS,CAAC,MAAM;IACZE,WAAW,CAAC,CAAC;EACjB,CAAC,EAAE,CAACA,WAAW,CAAC,CAAC,CAAC,CAAC;;EAEnB,OAAO;IACHM,MAAM;IAAW;IACjBE,SAAS;IAAQ;IACjBE,KAAK;IAAY;IACjBW,aAAa,EAAErB,WAAW,CAAC;EAC/B,CAAC;AACL,CAAC;AAACK,EAAA,CAnDIF,SAAS;EAAA,QAIYD,SAAS;AAAA;AAiDpC,eAAeC,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}