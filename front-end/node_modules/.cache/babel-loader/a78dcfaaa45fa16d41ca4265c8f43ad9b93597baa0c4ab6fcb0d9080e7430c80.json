{"ast":null,"code":"// Global request cache to prevent duplicate API calls\nconst apiCache = {\n  cache: {},\n  get: function (url) {\n    var _this$cache$url;\n    return (_this$cache$url = this.cache[url]) === null || _this$cache$url === void 0 ? void 0 : _this$cache$url.data;\n  },\n  set: function (url, data, ttl = 60000) {\n    // Default TTL: 1 minute\n    this.cache[url] = {\n      data,\n      expiry: Date.now() + ttl\n    };\n  },\n  isValid: function (url) {\n    const item = this.cache[url];\n    return item && item.expiry > Date.now();\n  },\n  clear: function () {\n    this.cache = {};\n  }\n};\n\n// Get stored credentials\nconst getStoredCredentials = () => {\n  const businessId = localStorage.getItem('businessId');\n  const businessApiKey = localStorage.getItem('businessApiKey');\n  return {\n    businessId,\n    businessApiKey\n  };\n};\n\n// Cached fetch function\nexport const cachedFetch = async (url, options = {}, ttl = 60000) => {\n  // Get stored credentials\n  const {\n    businessId,\n    businessApiKey\n  } = getStoredCredentials();\n\n  // Ensure URL ends with trailing slash for POST/PUT requests\n  let urlWithCredentials = url;\n  if ((options.method === 'POST' || options.method === 'PUT') && !url.endsWith('/')) {\n    urlWithCredentials = url + '/';\n  }\n\n  // Add credentials to URL if not already present\n  if (businessId && !urlWithCredentials.includes('business_id=')) {\n    urlWithCredentials += (urlWithCredentials.includes('?') ? '&' : '?') + `business_id=${businessId}`;\n  }\n  if (businessApiKey && !urlWithCredentials.includes('api_key=')) {\n    urlWithCredentials += (urlWithCredentials.includes('?') ? '&' : '?') + `api_key=${businessApiKey}`;\n  }\n\n  // Add credentials to headers if not already present\n  const headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json',\n    ...(businessApiKey ? {\n      'Authorization': businessApiKey,\n      'X-API-Key': businessApiKey,\n      'API-Key': businessApiKey\n    } : {}),\n    ...options.headers\n  };\n\n  // Ensure body is properly stringified if present\n  let body = options.body;\n  if (body && typeof body === 'object') {\n    body = JSON.stringify(body);\n  }\n  const cacheKey = urlWithCredentials + (body ? body : '');\n\n  // Return cached data if available and not expired\n  if (!options.method || options.method === 'GET') {\n    if (apiCache.isValid(cacheKey)) {\n      console.log(`Using cached data for: ${urlWithCredentials}`);\n      return {\n        ok: true,\n        json: async () => apiCache.get(cacheKey)\n      };\n    }\n  }\n\n  // Perform the fetch with updated URL and headers\n  const response = await fetch(urlWithCredentials, {\n    ...options,\n    headers,\n    body\n  });\n\n  // Cache the result for GET requests\n  if (response.ok && (!options.method || options.method === 'GET')) {\n    const data = await response.json();\n    apiCache.set(cacheKey, data, ttl);\n\n    // Return an object that mimics the fetch response\n    return {\n      ok: true,\n      json: async () => data\n    };\n  }\n  return response;\n};","map":{"version":3,"names":["apiCache","cache","get","url","_this$cache$url","data","set","ttl","expiry","Date","now","isValid","item","clear","getStoredCredentials","businessId","localStorage","getItem","businessApiKey","cachedFetch","options","urlWithCredentials","method","endsWith","includes","headers","body","JSON","stringify","cacheKey","console","log","ok","json","response","fetch"],"sources":["C:/icmp_events_api/front-end/src/utils/fetchUtils.js"],"sourcesContent":["// Global request cache to prevent duplicate API calls\r\nconst apiCache = {\r\n  cache: {},\r\n  get: function(url) {\r\n    return this.cache[url]?.data;\r\n  },\r\n  set: function(url, data, ttl = 60000) { // Default TTL: 1 minute\r\n    this.cache[url] = {\r\n      data,\r\n      expiry: Date.now() + ttl\r\n    };\r\n  },\r\n  isValid: function(url) {\r\n    const item = this.cache[url];\r\n    return item && item.expiry > Date.now();\r\n  },\r\n  clear: function() {\r\n    this.cache = {};\r\n  }\r\n};\r\n\r\n// Get stored credentials\r\nconst getStoredCredentials = () => {\r\n  const businessId = localStorage.getItem('businessId');\r\n  const businessApiKey = localStorage.getItem('businessApiKey');\r\n  return { businessId, businessApiKey };\r\n};\r\n\r\n// Cached fetch function\r\nexport const cachedFetch = async (url, options = {}, ttl = 60000) => {\r\n  // Get stored credentials\r\n  const { businessId, businessApiKey } = getStoredCredentials();\r\n  \r\n  // Ensure URL ends with trailing slash for POST/PUT requests\r\n  let urlWithCredentials = url;\r\n  if ((options.method === 'POST' || options.method === 'PUT') && !url.endsWith('/')) {\r\n    urlWithCredentials = url + '/';\r\n  }\r\n  \r\n  // Add credentials to URL if not already present\r\n  if (businessId && !urlWithCredentials.includes('business_id=')) {\r\n    urlWithCredentials += (urlWithCredentials.includes('?') ? '&' : '?') + `business_id=${businessId}`;\r\n  }\r\n  if (businessApiKey && !urlWithCredentials.includes('api_key=')) {\r\n    urlWithCredentials += (urlWithCredentials.includes('?') ? '&' : '?') + `api_key=${businessApiKey}`;\r\n  }\r\n  \r\n  // Add credentials to headers if not already present\r\n  const headers = {\r\n    'Content-Type': 'application/json',\r\n    'Accept': 'application/json',\r\n    ...(businessApiKey ? {\r\n      'Authorization': businessApiKey,\r\n      'X-API-Key': businessApiKey,\r\n      'API-Key': businessApiKey\r\n    } : {}),\r\n    ...options.headers\r\n  };\r\n  \r\n  // Ensure body is properly stringified if present\r\n  let body = options.body;\r\n  if (body && typeof body === 'object') {\r\n    body = JSON.stringify(body);\r\n  }\r\n  \r\n  const cacheKey = urlWithCredentials + (body ? body : '');\r\n  \r\n  // Return cached data if available and not expired\r\n  if (!options.method || options.method === 'GET') {\r\n    if (apiCache.isValid(cacheKey)) {\r\n      console.log(`Using cached data for: ${urlWithCredentials}`);\r\n      return { \r\n        ok: true,\r\n        json: async () => apiCache.get(cacheKey)\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Perform the fetch with updated URL and headers\r\n  const response = await fetch(urlWithCredentials, { \r\n    ...options, \r\n    headers,\r\n    body\r\n  });\r\n  \r\n  // Cache the result for GET requests\r\n  if (response.ok && (!options.method || options.method === 'GET')) {\r\n    const data = await response.json();\r\n    apiCache.set(cacheKey, data, ttl);\r\n    \r\n    // Return an object that mimics the fetch response\r\n    return {\r\n      ok: true,\r\n      json: async () => data\r\n    };\r\n  }\r\n  \r\n  return response;\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}