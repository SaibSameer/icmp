{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useStages.js\nimport { useState, useEffect, useCallback } from 'react';\n// Assuming a stageService.js file will export fetchStages\n// We might need to create/update this service file later\nimport { fetchStages as fetchStagesApi } from '../services/stageService';\n\n// This hook takes the selectedAgentId as an argument\nconst useStages = (selectedAgentId, handleSnackbarOpen) => {\n  _s();\n  const [stages, setStages] = useState([]); // Initialize as empty array\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const fetchStages = useCallback(async () => {\n    // Only fetch if an agent is selected\n    if (!selectedAgentId) {\n      setStages([]); // Clear stages if no agent is selected\n      return;\n    }\n    setIsLoading(true);\n    setError(null);\n    console.log(`Fetching stages for agent ID: ${selectedAgentId}`);\n    try {\n      // API key relies on httpOnly cookie sent automatically by browser\n      const data = await fetchStagesApi(selectedAgentId);\n      console.log(\"Fetched stages:\", data);\n      // Ensure data is always an array\n      setStages(Array.isArray(data) ? data : []);\n      // Optional: Snackbar notification\n      // if (handleSnackbarOpen) {\n      //      handleSnackbarOpen(\"Stages loaded!\", \"info\");\n      // }\n    } catch (err) {\n      console.error(\"Error fetching stages:\", err);\n      const errorMessage = err.message || 'Failed to fetch stages';\n      setError(errorMessage);\n      setStages([]); // Clear stages on error\n      if (handleSnackbarOpen) {\n        handleSnackbarOpen(`Error fetching stages: ${errorMessage}`, \"error\");\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [selectedAgentId, handleSnackbarOpen]); // Depend on selectedAgentId\n\n  // useEffect to trigger fetch when selectedAgentId changes\n  useEffect(() => {\n    fetchStages();\n  }, [fetchStages]); // Dependency array includes fetchStages (memoized by useCallback)\n\n  return {\n    stages,\n    // The array of stage objects\n    isLoading,\n    // Boolean indicating if fetch is in progress\n    error,\n    // Error object/message if fetch failed\n    refreshStages: fetchStages // Function to manually trigger a refresh\n  };\n};\n_s(useStages, \"Ivk0nC7sBlXQ4EzUG8ghEGSp8/Q=\");\nexport default useStages;","map":{"version":3,"names":["useState","useEffect","useCallback","fetchStages","fetchStagesApi","useStages","selectedAgentId","handleSnackbarOpen","_s","stages","setStages","isLoading","setIsLoading","error","setError","console","log","data","Array","isArray","err","errorMessage","message","refreshStages"],"sources":["C:/icmp_events_api/front-end/src/hooks/useStages.js"],"sourcesContent":["// src/hooks/useStages.js\r\nimport { useState, useEffect, useCallback } from 'react';\r\n// Assuming a stageService.js file will export fetchStages\r\n// We might need to create/update this service file later\r\nimport { fetchStages as fetchStagesApi } from '../services/stageService';\r\n\r\n// This hook takes the selectedAgentId as an argument\r\nconst useStages = (selectedAgentId, handleSnackbarOpen) => {\r\n    const [stages, setStages] = useState([]); // Initialize as empty array\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [error, setError] = useState(null);\r\n\r\n    const fetchStages = useCallback(async () => {\r\n        // Only fetch if an agent is selected\r\n        if (!selectedAgentId) {\r\n            setStages([]); // Clear stages if no agent is selected\r\n            return;\r\n        }\r\n\r\n        setIsLoading(true);\r\n        setError(null);\r\n        console.log(`Fetching stages for agent ID: ${selectedAgentId}`);\r\n\r\n        try {\r\n            // API key relies on httpOnly cookie sent automatically by browser\r\n            const data = await fetchStagesApi(selectedAgentId);\r\n            console.log(\"Fetched stages:\", data);\r\n            // Ensure data is always an array\r\n            setStages(Array.isArray(data) ? data : []);\r\n            // Optional: Snackbar notification\r\n            // if (handleSnackbarOpen) {\r\n            //      handleSnackbarOpen(\"Stages loaded!\", \"info\");\r\n            // }\r\n        } catch (err) {\r\n            console.error(\"Error fetching stages:\", err);\r\n            const errorMessage = err.message || 'Failed to fetch stages';\r\n            setError(errorMessage);\r\n            setStages([]); // Clear stages on error\r\n             if (handleSnackbarOpen) {\r\n                handleSnackbarOpen(`Error fetching stages: ${errorMessage}`, \"error\");\r\n            }\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [selectedAgentId, handleSnackbarOpen]); // Depend on selectedAgentId\r\n\r\n    // useEffect to trigger fetch when selectedAgentId changes\r\n    useEffect(() => {\r\n        fetchStages();\r\n    }, [fetchStages]); // Dependency array includes fetchStages (memoized by useCallback)\r\n\r\n    return {\r\n        stages,          // The array of stage objects\r\n        isLoading,       // Boolean indicating if fetch is in progress\r\n        error,           // Error object/message if fetch failed\r\n        refreshStages: fetchStages // Function to manually trigger a refresh\r\n    };\r\n};\r\n\r\nexport default useStages;\r\n"],"mappings":";AAAA;AACA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACxD;AACA;AACA,SAASC,WAAW,IAAIC,cAAc,QAAQ,0BAA0B;;AAExE;AACA,MAAMC,SAAS,GAAGA,CAACC,eAAe,EAAEC,kBAAkB,KAAK;EAAAC,EAAA;EACvD,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGV,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;EAC1C,MAAM,CAACW,SAAS,EAAEC,YAAY,CAAC,GAAGZ,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACa,KAAK,EAAEC,QAAQ,CAAC,GAAGd,QAAQ,CAAC,IAAI,CAAC;EAExC,MAAMG,WAAW,GAAGD,WAAW,CAAC,YAAY;IACxC;IACA,IAAI,CAACI,eAAe,EAAE;MAClBI,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;MACf;IACJ;IAEAE,YAAY,CAAC,IAAI,CAAC;IAClBE,QAAQ,CAAC,IAAI,CAAC;IACdC,OAAO,CAACC,GAAG,CAAC,iCAAiCV,eAAe,EAAE,CAAC;IAE/D,IAAI;MACA;MACA,MAAMW,IAAI,GAAG,MAAMb,cAAc,CAACE,eAAe,CAAC;MAClDS,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEC,IAAI,CAAC;MACpC;MACAP,SAAS,CAACQ,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,GAAGA,IAAI,GAAG,EAAE,CAAC;MAC1C;MACA;MACA;MACA;IACJ,CAAC,CAAC,OAAOG,GAAG,EAAE;MACVL,OAAO,CAACF,KAAK,CAAC,wBAAwB,EAAEO,GAAG,CAAC;MAC5C,MAAMC,YAAY,GAAGD,GAAG,CAACE,OAAO,IAAI,wBAAwB;MAC5DR,QAAQ,CAACO,YAAY,CAAC;MACtBX,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;MACd,IAAIH,kBAAkB,EAAE;QACrBA,kBAAkB,CAAC,0BAA0Bc,YAAY,EAAE,EAAE,OAAO,CAAC;MACzE;IACJ,CAAC,SAAS;MACNT,YAAY,CAAC,KAAK,CAAC;IACvB;EACJ,CAAC,EAAE,CAACN,eAAe,EAAEC,kBAAkB,CAAC,CAAC,CAAC,CAAC;;EAE3C;EACAN,SAAS,CAAC,MAAM;IACZE,WAAW,CAAC,CAAC;EACjB,CAAC,EAAE,CAACA,WAAW,CAAC,CAAC,CAAC,CAAC;;EAEnB,OAAO;IACHM,MAAM;IAAW;IACjBE,SAAS;IAAQ;IACjBE,KAAK;IAAY;IACjBU,aAAa,EAAEpB,WAAW,CAAC;EAC/B,CAAC;AACL,CAAC;AAACK,EAAA,CAlDIH,SAAS;AAoDf,eAAeA,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}